21.06.20

# 알고리즘
알고리즘과 일주일 내내 씨름하면서 약간 정신수양도 함께 된 것 같다. 알고리즘은 개발공부 중 재밌는 단계라고 생각했는데 모르는 문제들로 스트레스를 꽤 받은 것 같다. 처음으로 dp, 백트래킹 문제들을 만났을땐 벽을 만난 것 같았다. 아무리 오래 코드를 붙잡고 있어도 통과가 되지 않아 포기하고 답을 봤다. 솔직히, 감탄스러웠다. 이런 해결 방식을 생각해낸 사람은 천재가 아닐까 싶었다. 아마 처음 생각해낸 사람은 천재가 맞을 것이다. 이런 해결 방식 자체에 이런 이름이 붙은 것이라는 것도 이해하게 되었다. 어렴풋이 알고 있던 개념을 부딪혀 체감하는 순간이었다. 동시에 내가 이런 수준에 도달 할 수 있을까 하는 걱정도 했던 것 같다.

# 알고리즘도 정석이 있다
위와 같은 걱정도 잠시였다. 그런 문제들을 몇개정도 답을 외울정도로 들여다보고 나니 다른 문제들에 대한 풀이를 어렴풋이 알 것 같았다. 물론 적용에 성공한 것도 있지만 실패한 것도 있다. 다만 내가 깨달은 것은, 아이큐테스트처럼 보이는 이런 듣도보도 못한 문제들도 이쪽 세계에선 어느정도 정해진 풀이 방식이 있다는 것이었다. 마치 수학의 정석처럼 말이다. 그리고 왜 모르는 문제들을 오래 잡고 있는걸 추천하지 않는 지를 깨닫게 되었다. 오래 고민하는 것도 좋지만 일단 나같은 초보자들은 모방이 비교할 수 없이 중요하다. 좋은 방식, 좋은 코드를 따라하는 것. 그리고 그것을 내것으로 만드는 것.
그것이 낮은 수준에서 낑낑대는 것보다 훨씬 성장하기 좋은 방식이었던 것이다. 알고리즘 문제들만 풀면서도 이렇게 많은 깨달음을 얻을 수 있다니, 앞으로 정신 수양은 알고리즘 문제로 하는 것이 어떨까 싶다. 문제를 보고 쫄 필요없고, 모르면 배우면 된다는 간단한 마음정리를 할 수 있었다.

# 여전히 공부는 재미있는가(1) 이 질문은 매주 해야겠다
재밌다. 다만 나에 대한 의심을 며칠했다. 배움에 대한 의심은 아니었고, 현실적인 가능성에 대한 의심이었다. 그래서 재미없어질뻔 했다. 내 걱정의 주요골자는 취직의 가능성이 있는가였다.
개발공부 자체는 개발자 안하더라도 하고 싶다. 이만큼 적성에 맞는 공부를 해본 적이 없다. 그러나 어릴때부터, 심지어 10살부터 코딩했다는 개발자들도 있는 판국에 내가 지금 도전해서 기회를 얻을 수 있을까 하는 현실적인 고민이었다. 아무리 재밌어도 수입을 배제할 순 없다. 취직을 통한 실무경험도 뒤로 미룰 수 없다. 그것을 과연 성취할 수 있는가 였다.

결론적으로, 의심하지 않기로 했다. 
결국 중요한 것은 나의 실력뿐이다. 다른 모든 것은 핑계다. 어떻게든 실력을 늘리고 또 그것을 어필할 수 있는 방법을 찾아내는 것만 고민해야겠다.
그리고 지금 돌아선다면 너무 큰 후회가 남을 것 같았다.

# javascript에 대해 책을 사서 공부하기 시작했다

내가 구매한 책은 '코어 자바스크립트'이다. 이 책의 내용을 모두 이해하게 되면 다른 책도 사서 읽어볼 생각이다. 책 한권 읽은 사람보다 무서운건 없는 법이니까.

# 왜 갑자기 책을?
지금까지 항상 구글링으로만 배웠으면서 왜 갑자기 책을 샀는가. 언어에 대한 깊은 이해가 필요하다는걸 느꼈기 때문이다. 많은 개발자들이 입을 모아 얘기한다. '언어 하나만 잘해도 다른 언어는 금방 배운다'. 왜일까 생각해보았다. 언어를 잘한다는 것은 무엇일까. 그 언어가 어떻게 동작하는지 원리를 파악하고, 그 원리를 자신의 코드에 자유롭게 적용하는 것이 아닐까싶다. 언어의 특성을 정확히 파악해서 사용하는 것. 그것이 가능하려면 언어가 어떻게 동작하는 지를 메모리단계에서부터 이해해야 할 것 같았다. 그리고 이 언어가 가진 특성들이 무엇인지 이해해야 할 것이다. 그렇다면 이런 것이 왜 다른 언어를 배울때 도움이 될까. 확실한 이해가 잡혀 있는 하나의 언어가 생기면 비교학습이 가능하기 때문이 아닐까 싶다. 다른 언어를 배우면서 내가 알고있는 언어와 무엇이 다른지 바로 비교가 가능해진다는 소리다. 그 비교는 곧 그 언어의 특성을 파악하는 것과 같은 것이고, 어떤 언어의 특성을 파악한다는 것은 그 언어를 잘 할 수 있는 기반이 된다는 것이지 싶다.

그래서 하나의 언어를 깊게 이해하고 싶었고, 책을 사서 정리하기 시작했다.


# '개발자'라는 마인드
친구가 뜬금없이 나에게 영상을 하나 보내주었다. 그리고 많은 것을 느꼈다.

https://www.youtube.com/watch?v=3H4umWD5bwI

1. 문제 해결 능력을 갖출 것(문제 해결의 80%는 문제를 정확히 이해하는 것)
2. 코딩에 자체에 집중하지 말고, 비즈니스 밸류를 창출할 것
3. 커뮤니케이션에 적극적일 것
4. 개인보다 조직 전체의 생산성에 힘쓸 것

개발자는, 문제를 해결하는 사람이고 커뮤니케이션으로 조직의 생산성을 돕는 사람이다.
기억해야겠다.


# 이번 주의 팁

하노이의 탑: 알고리즘의 교과서 같은 문제였다. 알고리즘 공부 좀 했다는 사람들은 모르는 사람이 없었다. 재귀자체는 이해하기 쉬웠으나 하노이를 재귀로 구현하는 것은 상당히 애를 먹었다.
유클리드 호제법: 소인수분해를 구현해서 문제를 풀었었는데 유클리드 호제법을 사용하면 정말 간단하게 해결이 됐다.
이항계수: 조합의 갯수를 구하는데 기본적인 원리가 된다. 
삼항연산자: True_value if True else False_value 구조로 파이썬에서 사용할 수 있다. 삼항연산자 기능은 다른 언어들에도 존재한다. 코드 길이를 줄여줘서 아주 잘 쓰고 있다. 
에라스토테네스의 체: 소수를 구하는 연산의 복잡도를 획기적으로 줄여주는 알고리즘. 처음쓸땐 조금 걸렸던것 같은데 다른 문제들에서 잘 써먹고 있다. 
walrus operator: 변수 선언과 동시에 사용 할 수 있는 기능. := 모양이 바다코끼리 엄니와 비슷하다고 하여 walrus라는 이름이 붙었다. 상황에 따라 아주 유용하다.
제너레이터(제너레이터 문법, iter(), next(), iterator and iterable): effective python에서 list comprehension대신 generator를 사용해보라는 글을 보고 사용해보았는데 신선했다.
comprehension처럼 전체를 생성하여 메모리에 할당시키는게 아니라, next매직메소드를 쓰던지 아니면 next()로 값을 하나씩 전진시킨다. 메모리를 효율적으로 사용할 수 있게해주고 코드의 직관성도 높여준다. 그러나 이터레이터와 이터러블의 차이를 아직 확실히 이해하지 못했다. iter의 활용을 정리해볼 생각이다. 아래는 iter()의 첫번째 argument가 callable을 요구하는 것에 대한 불편함을
해소시켜줄 수 있는 itertools의 takewhile 활용 예제이다.

```python
# 마치 iter의 sentinel 처럼 쓸 수 있다. iter는 iter(callable, sentinel)로 동작하는 반면, takewhile은 type 즉, list 등에도 활용할 수 있다.
import itertools
for val in itertools.takewhile(l, lambda x: x!= 4):
    print(val)
```
매직 메소드: 파이썬의 언더바 두개가 양쪽에 있는 메소드들을 의미한다. 왜 매직 메소드라는 이름이 붙은 것이냐면, 그 메소드들은 각각이 미리 정해진 고유한 기능들을 담당하고 있기 때문이다. 대표적으로 init혹은 위에서 예를 든 iter등이 있다. 
집합 연산을 좀 더 적극적으로 활용하자 : 알고리즘을 풀면서 문득, 값을 걸러낼때 집합연산을 왜 지금까지 안 을까하는 생각이 스치고 지나갔다. 중복제거 혹은 차집합 교집합 등의 개념을 사용하면 값을 추출할때 훨씬 편하게 뽑아냈을 문제들이 몇개 있었던 것 같았다.

