# Docker부터 시작하면 안된다
뜬금없는 소리로 시작하고 싶다. 도커는 잠시 잊고 process부터 제대로 이해해보자.

먼저 당연한 소리들 부터 짚겠다.
윈도우를 예로 들면 .exe 실행파일들이 존재할 것이다. 이 프로그램을 실행시키면 그 프로그램의 인스턴스가 생성되는데, 이를 두고 process라고 한다. 운영체제 입장에서 조금 더 개념적인 표현으로는 Task라고 한다. 작업관리자를 열어보면 PID항목을 볼 수 있는데, 모두 양의 정수로 되어 있는 것을 볼 수 있다. PID가 나눠져있다는 것은 같은 프로그램일지라도 각 하나하나가 모두 인스턴스라는 말이다. 이는 단순한 명령어 집합 덩어리(파일)가 실제로 연산이 일어나게 되었음(프로세스)을 말한다. 크롬프로세스가 여러개 돌아가고 있는 것처럼 말이다. Task라는 표현에 이어 작업을 처리하는 것 자체를 Tasking이라는 표현을 사용하고, 여러 프로세스가 동시에 돌아가고 있는 것을 Multi-Tasking이라고 한다. 요즘에는 잘 사용하지 않지만 Program을 Routine 혹은 Procedure이라고 부르기도 했다. 결국 Process라는 말에는 Program, Task, Routine, Procedure라는 말이 모두 연관이 있다.

실제 프로세스의 구동을 머릿속에 그려보기 위해 간단한 예를 들어보자. 축약된 H/W구조를 일단 그려보자. Multi core CPU, 일정량의 RAM, 종류가 무엇이던 2차 Memory가 존재한다고 가정하겠다. 또한 현재 이 컴퓨터는 Multi tasking중이다.
Kernel은 자원할당의 책임이 있다. User mode에서 연산을 요구하는 프로세스가 두 개 있다고 가정하자. PID는 간단하게 1,2로 가정한다. Kernel이 Process 1에게 CPU의 첫 번째 코어와 RAM의 유휴 구간을 골라 할당하였다. Process 2에게는 CPU 코어가 두번째 인것을 제외하곤 같은 동작을 수행하였다. 이 때, Process 1은 Process 2에게 할당된 메모리에 절대 접근해선 안된다. 즉시 크래시를 내며 프로세스가 종료될 것이다. 

자, 이상태에서 도커 컨테이너를 가동한다고 생각해보자. 컨테이너는 엄청 sophisticated하게 뭔가 다른 방식으로 작동할까? 아니다. 같은 하드웨어에서 구동되는 이상 Process 1과 Process 2와 다를바 없이 자원을 할당받는다. 즉, Host 입장에서는 Container라는 말은 아무 의미도 없다. 그냥 Process 3인 것이다. 컨테이너 설명할때 항상 나오는 Kernel을 공유한다는 말이 이것이다.
그러나, 결정적인 차이가 있다. 컨테이너 자신은 자신이 이 Host에 있다는 것을 알 수가 없다. 컨테이너라는 말의 뜻이 바로 여기에 있다! 프로세스가 컨테이너라는 boundary안에 철저히 격리되어 있는 상태로 구동되게 된다. 그렇다면 그 boundary는 어떻게 만들어질까? 

# 가상화
가상메모리의 개념을 숙지한 상태로 진행할 것을 권장한다.


