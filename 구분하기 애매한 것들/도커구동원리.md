# Docker부터 시작하면 안된다
뜬금없는 소리로 시작하고 싶다. 도커는 잠시 잊고 process부터 제대로 이해해보자.

먼저 당연한 소리들 부터 짚겠다.
윈도우를 예로 들면 .exe 실행파일들이 존재할 것이다. 이 프로그램을 실행시키면 그 프로그램의 인스턴스가 생성되는데, 이를 두고 process라고 한다. 운영체제 입장에서 조금 더 개념적인 표현으로는 Task라고 한다. 작업관리자를 열어보면 PID항목을 볼 수 있는데, 모두 양의 정수로 되어 있는 것을 볼 수 있다. PID가 나눠져있다는 것은 같은 프로그램일지라도 각 하나하나가 모두 인스턴스라는 말이다. 이는 단순한 명령어 집합 덩어리(파일)가 실제로 연산이 일어나게 되었음(프로세스)을 말한다. 크롬프로세스가 여러개 돌아가고 있는 것처럼 말이다. Task라는 표현에 이어 작업을 처리하는 것 자체를 Tasking이라는 표현을 사용하고, 여러 프로세스가 동시에 돌아가고 있는 것을 Multi-Tasking이라고 한다. 요즘에는 잘 사용하지 않지만 Program을 Routine 혹은 Procedure이라고 부르기도 했다. 결국 Process라는 말에는 Program, Task, Routine, Procedure라는 말이 모두 연관이 있다.

실제 프로세스의 구동을 머릿속에 그려보기 위해 간단한 예를 들어보자. 축약된 H/W구조를 일단 그려보자. Multi core CPU, 일정량의 RAM, 종류가 무엇이던 2차 Memory가 존재한다고 가정하겠다. 또한 현재 이 컴퓨터는 Multi tasking중이다.
Kernel은 자원할당의 책임이 있다. User mode에서 연산을 요구하는 프로세스가 두 개 있다고 가정하자. PID는 간단하게 1,2로 가정한다. Kernel이 Process 1에게 CPU의 첫 번째 코어와 RAM의 유휴 구간을 골라 할당하였다. Process 2에게는 CPU 코어가 두번째 인것을 제외하곤 같은 동작을 수행하였다. 이 때, Process 1은 Process 2에게 할당된 메모리에 절대 접근해선 안된다. 즉시 크래시를 내며 프로세스가 종료될 것이다. 

자, 이상태에서 도커 컨테이너를 가동한다고 생각해보자. 컨테이너는 엄청 sophisticated하게 뭔가 다른 방식으로 작동할까? 아니다. 같은 하드웨어에서 구동되는 이상 Process 1과 Process 2와 다를바 없이 자원을 할당받는다. 즉, Host 입장에서는 Container라는 말은 아무 의미도 없다. 그냥 Process 3인 것이다. 컨테이너 설명할때 항상 나오는 Kernel을 공유한다는 말이 이것이다.
그러나, 결정적인 차이가 있다. 컨테이너 자신은 자신이 이 Host에 있다는 것을 알 수가 없다. 컨테이너라는 말의 뜻이 바로 여기에 있다! 프로세스가 컨테이너라는 boundary안에 철저히 격리되어 있는 상태로 구동되게 된다. 그렇다면 그 boundary는 어떻게 만들어질까? 

# 가상화
먼저 가상머신을 생각해보자. 대체 어떻게 가상머신은 독립된 컴퓨터처럼 구동될 수 있을까? NIC를 예로 들어보자. 일반적인 컴퓨터에는 보통 1개의 NIC가 설치되어있을 것이다. 그럼 그 NIC를 구동하기 위한 Driver가 있을 것이고, 커널이 그 드라이버와 소통하고 있을 것이다. 장치관리자를 살펴보았을 때 네트워크 드라이버가 바로 이 녀석이다. 어쨌든, 결론적으로 NIC가 하나이니 드라이버도 하나가 표시될 것이다.

VM을 구동하면 Driver가 더 생성되는 것을 확인할 수 있다. 이것이 의미하는 바는, Physical NIC 뿐 아니라, Logical NIC가 설치되었다는 것이다. 어떻게 이런 것이 가능할까? 기본적으로 VM은 컴퓨터의 구조를 그대로 따른다. 그 말은 즉, H/W, S/W그리고 그 안에 Kernel mode, User mode가 그대로 존재한다는 것이다. 여기서 VM의 Virtual H/W 구간은 Host의 커널영역에서 동작하게 된다. 그리고 Virtual Kernel mode와 User mode는 Host의 User mode에서 동작한다. 그리고 Virtual H/W영역에 Virtual NIC가 구현되어 있다. 

그런데, 어찌되었든 간에 실제로 인터넷과 연결된 것은 Host의 물리 NIC밖에 없는데 정확히 논리 NIC로부터 정확히 어떻게 물리 NIC로 연결된다는 걸까. Guest의 Virtual NIC들은 Host에 설치된 Virtual NIC Driver와 소통하여 가상머신 내에서 인터넷이 가능하도록 만든다. 정확히 말하자면 Guest의 Software NIC들은 Host의 Virtual NIC Driver를 마치 L2 Switch처럼 사용한다. 그리고 일반적으로 가상NIC드라이버들에는 번호가 매겨져있는데, 0번 드라이버가 보통 NAT,즉 공유기 역할을 한다. 그리고 그 가상 NAT가 물리 NIC 드라이버와 소통하여 최종적으로 물리 NIC를 타고 인터넷과 연결된다. 

위의 사용 시나리오가 중요한 것은 아니고, 가상 머신은 H/W를 그대로 에뮬레이트한다는 것만 이해하면 된다.

# 컴퓨터의 정체성
그런데, 이 시점에서 컴퓨터의 사용목적에 대해 진지하게 고민해볼 필요가 있다. 만약 어떤 사용자가 게임을 하기위해 윈도우가 설치된 컴퓨터를 구매했다. 그렇다면 이 사용자는 게임을 위해 윈도우를 구매한 것이고, 컴퓨터는 게임기가 된 것이다. 어떤 사람이 사무를 위해 컴퓨터를 구매했다면 컴퓨터는 사무기기가 된다. 즉, 목적이 핵심이지 운영체제 종류, NIC 따위는 전혀 중요한 것이 아니다.

컴퓨터의 목적만 가상화 시킬 순 없을까? 그렇다면 가상머신에서 필요없는 부분을 제거하면 훨씬 효율적으로 동작시킬 수 있을 것이고, 필요 없는 부분이란 가상 H/W영역과 가상 머신의 Kernel영역이라는 소리가 된다. 이 생각에서 출발한 것이 도커다.

그렇다면 application이 돌아가기 위해 필요한 것은 Binary file(기계어 실행파일. 완전 텍스트이나 구분을 위해 보통 bin확장자)들과 실행을 도와줄 Library들이고, 그 컨테이너에서 필요한 System call등 원래 VM에서라면 가상 Kernel과 가상 H/W로 해결하던 것들을 Kernel 공유와 Container runtime이라는 Guest OS 대체제로 메꾼다. 이 런타임은 컨테이너 엔진의 컴포턴트로, Docker engine을 예로 들면 runC와 같은 것이다. 사실 Docker Engine이라는 말은 좀 어폐가 있을 수 있는데, Container engine중 한 종류가 Docker이기 때문이다. 반대로 용어 정의에 동의하지 않는 사람도 있을 텐데, 그 이유는 Docker라는 명사는 Client-Server 모델 application이고 Docker Engine은 컨테이너를 구축하고 실행하는 핵심 소프트웨어라고 정의하는 사람들도 있기 때문이다. 아무튼 여러 글에서 Docker는 엔진 자체 혹은 application 두 가지 의미로 쓰이므로 그냥 문맥상 알아들으면 된다. Container runtime은 containerization을 수행하는 존재인데, Host의 Kernel과 긴밀하게 협업하여 Container에 필요한 모든 사항(cgroup 설정, Kernel로부터의 가상메모리 할당, 시스템 콜 등...)을 수행한다. 참고로 runC는 Docker가 OCI(Open Container Initiative) 표준에 맞춰 구현한 것이므로, OCI 표준에 합당한 다른 런타임에도 도커 컨테이너는 동작할 수 있다.  

# 컨테이너란 정확히 무엇인가
Container는 격리된 환경이라고 했고, Docker는 이를 구동시켜주는데 Host입장에서는 그냥 프로세스다? 이 구조를 좀더 면밀히 살펴보자. 

VM의 작동원리에서 살펴본 것 처럼 논리적으로 하드웨어를 따라하는 것을 Emulate한다고 하는데, 도커 컨테이너는 H/W Emulation없이 **Linux Kernel**을 공유해서 **프로세스**를 실행한다.

컨테이너가 프로세스이고 리눅스 커널을 공유한다는 것은 의외로 쉽게 근거를 찾을 수 있다. 예를 들어, 종류가 무엇이든 대화형 명령이 가능한 서로 다른 종류의 운영체제 컨테이너를 실행시킨다. 그리고 그 다른 컨테이너들에서 커널 및 커널의 배포판 정보를 출력해본다(uname -a). Linux나 LinuxKit의 **동일한** 정보가 출력될 것이다. 그 다음은 cat /etc/*-release 를 통해 운영체제의 종류 및 배포판을 확인해 보자. 이때는 각자의 컨테이너에 합당한 정보가 출력된다(Ubuntu, CentOS 등..). 그러니까, 환경이 분명히 격리된 것이다. 

가아끔 사람들이 MacOS가 리눅스 기반이라서 MacOS커널을 사용한다고 이해하고 있는 사람도 있는데 그런것은 아니다. Windows던 Mac이건 도커를 실행 후 컨테이너에서 상술한 정보를 출력해보면 LinuxKit이라는 경량 리눅스 서브시스템 정보가 표시된다. 그리고 그 LinuxKit은 윈도우건 맥이건 Hypervisor위에서 가동된다. 윈도우는 Hyper-V를 사용중이고, Mac에서는 Hypervisor framework를 기반으로 하는 HyperKit을 사용한다. 개인적으로 윈도우에서는 도커 구동시 WSL2가 잡아먹는 메모리가 엄청나 상당히 불편했던 기억이 있다. 어쨌든 LinuxKit은 Docker, IBM, Linux Foundation, MS, ARM, HP, Intel이 합작하여 만들어낸 작품이며, "미래에는 애플리케이션 실행의 상식이 LinuxKit위에서 컨테이너라는 틀로 자리잡히게 될 가능성이 있을 정도다"(타카라 마호 - japan IBM cloud & cognitive).

넘어와서, 컨테이너가 프로세스라면 PID도 가지고 있을 것이다. bash를 열어서 일단 bash의 pid를 확인(echo $$)해보자. 이 때 무슨 숫자가 표시되던 잘 기억해두고, 이번엔 컨테이너에 대화형 모드로 진입해 같은 명령을 실행해보자. 아마 결과는 1 일것이다. 이는 상당히 황당한 결과인데, Linux는 1번이 항상 init process로 process tree의 root이기 때문이다. 그런데 bash프로세스가 1번으로 표시되고 있는 것이다. 

이를 생각할수록 더 이상한데, 커널을 공유하는 점을 고려했을 때 이미 1번 프로세스를 가지고 있는 host위에 또다른 1번 프로세스가 실행중이라는 말이 되기 때문이다. 이는 네임스페이스라는 기술로 가능한데, 더 정확히는 PID 네임스페이스가 분리되어있기 때문에 자신을 1번 프로세스라고 인식하는 것이 가능해진다(그러니까 init process의 의미가 전혀 아니라는 것이다).

컨테이너는 자신의 루트디렉토리를 /가 아닌 하위의 특정 디렉토리인 것 처럼 실행하는데, 이는 도커 이미지(파일 집합. 맞다. 프로세스가 실행될 파일 집합이다)를 마치 루트 파일 시스템처럼 강제 인식시키기 때문이다. 

이미지가 파일집합이라고 했으니 이 이미지의 내용을 특정 디렉토리로 옮겨 그곳으로 chroot하여 root디렉토리를 인식시키며 동시에 unshare로 namespace를 분리해 그곳에서 shell이 자신을 어떻게 인식하는지 보면 윗 내용이 맞는지 알수 있다.
```console
foo@bar:~$ unshare -p -f --mount-proc chroot ./busybox-image /bin/sh
```
여기까지 진행했을 때, 과연 호스트가 바라보는 shell의 PID는 무엇일까? 답은 '변함없음'이다. 이는 시사하는 바가 매우 큰데, PID는 프로세스 자신에게는 1번으로, 호스트의 입장에서는 일반 프로세스로 보였다는 것입니다. 이를 확인할 방법은 파일시스템을 뒤적여보는 것이다. var/run/docker/runtime-runc/moby의 디렉토리 구조를 뽑아보면 **컨테이너 아이디와 앞부분이 같은** 괴상한 이름의 디렉토리가 생성되어있는 것을 확인할 수 있다. 그리고 그 디렉토리에는 state.json이라는 컨테이너 관련 정보들이 담겨있는데, jq 명령어로 '.init_process_pid'를 출력cat state.json  | jq '.init_process_pid')해보면 호스트가 인식하고 있는 PID를 출력한다. 그 외에 네임스페이스 관련 정보를 보면(cat state.json | jq '.namespace_paths') /proc 하위 경로들(/proc은 process의 약자로 리눅스에서 PID로 디렉토리를 생성해 process정보를 저장하는 곳이다)에 위에서 뽑아본 init_process_pid하위에 네임스페이스들을 새롭게 정의하고 있는 것을 확인할 수 있다. 즉, 위에서 프로세스 1로 만들기할때와 같은 원리로 네임스페이스를 분리하고 있는 것이다.

마지막 확인을 위하여, init_process_pid를 참고해 kill -9 [PID]를 날려보면 도커 컨테이너가 종료되는 모습을 확인할 수 있다. 도커가 확실히 인식시켜둔 컨테이너는 VM에서 구동하지 않는다 라는 명제도 사실은 정확하지 않은 표현인데, '도커'에 한정해 맞는 말이다. Kata나 Firecracker등은 발전된 마이크로 VM에 힘입어 VM위에 컨테이너를 실행하는 프로젝트들인데, 그 속도나 효율성이 현저히 발전하고 있으며 격리수준도 당연히 도커보다 높기 때문에 오히려 컨테이너가 VM인게 상식인 시대가 찾아오는 것도 가능하다.


# 참고한 글
도커? 그 전에 프로세스:https://www.youtube.com/watch?v=zh0OMXg2Kog

컨테이너 런타임 설명: https://www.techtarget.com/searchitoperations/tip/A-breakdown-of-container-runtimes-for-Kubernetes-and-Docker  

컨테이너는 프로세스?: https://www.44bits.io/ko/post/is-docker-container-a-virtual-machine-or-a-process

15단계로 배우는 도커와 쿠버네티스 - 타카라 마호

