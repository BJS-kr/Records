# 선결론: 소켓은 파일이다
아래의 글은 이 결론에 도달하기 위한 과정이다

# 컴퓨터의 구조
컴퓨터는 layered architecture로 구성되어있으므로 소켓을 설명하기 위해 기저를 설명하지 않을 수 없다. 다만 지루한 설명은 관두고 최대한 간단하게 구조를 짚고 넘어가겠다. 크게 보면 컴퓨터는 H/W영역과 S/W영역으로 구분된다. H/W는 당연히 CPU가 핵심이고 '머신과 호환'같은 말에서 머신은 CPU를 뜻한다. S/W도 다시 두 영역으로 구분할 수 있다. Kernel mode와 User mode로 선이 그어져있는 그림을 어딘가에서 본 적이 있을 것이다. User mode도 개념적으로는 두 부분으로 구분할 수 있다. 일반적인 구분은 아니고, Kernel의 하수인 같은 역할을 하는 영역(daemon, device file 등)을 Service layer이라고 명명하고, 정말 사용자가 직접적으로 컨트롤하는 프로세스의 영역을 Application layer라고 명명하고 설명을 시작하겠다.

참고로 Service layer부터 Kernel layer까지를 합쳐서 OS layer라고도 부르고, Service layer로부터 H/W layer까지를 통틀어서 Platform이라고도 부른다. 덧붙이자면 Linux 계열의 운영체제들은 Kernel이 거의 비슷하게 생겼다. User mode쪽의 구현이 달라지는 대로 Ubuntu가 되거나 Redhat이 되는 식이다.

H/W계층은 다른 말로하면 Physical layer이다. 컴퓨터에서 Physical과 Real은 거의 동의어다. 그렇다면 S/W도 추론할 수 있다. S/W는 Logical layer이고 이는 Virtual과 거의 동의어다. Logical영역의 핵심은 '신뢰'다. Physical과는 다르게 그렇게 되어있다고 믿는 것이다.

Application layer에는 사실 예외적인 사항이 존재하는데, debugger의 존재가 바로 그것이다. debugger는 일종의 슈퍼권한을 커널로부터 부여받은 존재로, 메모리 오류를 탐색하는 것이 주 목적이지만 이를 이용해 메모리 해킹에 이용되는 대표적인 툴이기도 하다. debugger를 제외한 프로세스는 서로의 메모리 영역을 침범할 수 없다. 이는 Kernel이 보장한다.
프로세스 내에서도 crash를 방지하기 위해 thread간에 규칙이 필요하다. lock을 걸고, lock을 확인하고, 대기하는 등... 이러한 작업의 일련을 synchronization이라고 통틀어 부른다. sync가 제대로 동작하지 않아 경합상태가 되는 것을 보통 Race condition이라고 표현한다. 물론 싱글스레드는 이러한 작업이 필요없다. 그래서 싱글스레드로 동작하는 어플리케이션은 개발편의성도 높고 동기화가 필요하지 않아 그 스레드 자신은 비할데 없이 효율적이다.  

어떤 컴퓨터에 디바이스(하드웨어)를 설치하게 되면 그 구동을 위해 무조건 소프트웨어가 필요한데, 당연히 커널 담당이다. 커널영역에서 하나라도 장애가 발생하면 블루스크린이 발생한다. 이것도 꽤나 당연한데, 컴퓨터는 계층구조이므로 하위 계층에 장애가 나면 상위 계층은 존재할 수 없다.  디바이스를 구동시키는 소프트웨어를 드라이버라고 한다. 그럼 드라이버있다고 장치를 사용할 수 있을까? 아니다. 커널에는 각자 하드웨어가 가지는 고유한 드라이버들과 소통하는 또다른 구성요소들이 존재한다. 그래서 하드웨어는 자신을 지원하는 운영체제에 설치될 수 있고, 지원되는 여러 운영체제에 하나의 드라이버만 가지고 설치될 수 있는 것이다.구성요소라고하니까 너무 추상적이다. 디스크 하드웨어를 예로 들어보자. 디스크에는 드라이버가 있다. 그리고 디스크와 소통하는 구성요소는? 바로 파일 시스템이다. 예를 들어 NTFS등… 그렇다면 그 파일시스템과 연결된 서비스 영역도 있을 것이다.

User mode와 Kernel mode는 비유하자면 인간계와 신계만큼 권한이 다른데, 커널은 원하면 당연히 유저영역을 컨트롤할 수 있다. 반대는 절대 불가능하다. 그런데 뭔가 이상하다. 그럼 User에서 요청을 어떻게 Kernel로 보내는가? application과 커널영역은 끝없이 소통해야하므로 특정한 통신 경로를 사용해야 하는데, 그 경로의 형태가 바로 파일이다. 프로세스는 주체, 파일은 대상. 그럼 주체가 대상을 상대로 하는 일을 살펴보자.

첫 번째는 create/open일 것이다. 두 번째는 read/write일 것이다. 세 번째는 같은 논리로 delete/close일 것이다. 이런걸 싸잡아서 I/O라고 부를 수 있다. 이 추상 인터페이스에 대한 I/O에는 규칙과 형식이 있는데, 이를 두고 Protocol이라고 부른다. 

여기서 혼란이 발생하기 쉬운데, 왜 파일이냐는 것이다. 이는 타협의 여지가 없는 구현 스펙일 뿐이다. 파일의 의미를, 예를 들어, 평소에 더블 클릭해서 열던 익숙한 존재에서 Kernel과의 인터페이스로 받아들이려니 생기는 혼동이라고 생각한다. 물론 파일이라는 증거를 댈 순 있다. fopen함수에 경로를 CON이라고 지정하고 Write를 시작하면 입력된 값이 모두 출력된다. 왜? 커널은 CON이라는 파일을 출력 인터페이스 경로로 쓰고 있어서 그렇다. PRN으로 경로를 지정하면? 쓰는 내용이 전부 프린터로 출력된다. 왜? 커널이 그걸 프린터 인터페이스로 쓰고 있으니까. 참고로 PRN은 옛날에만 됐다.

아래의 코드를 실행해보자. foo와는 다르게 con은 입력 내용이 즉시 출력될 것이다.
```cpp
#include <cstdio>

int main() {
  FILE* foo = fopen("./foo", "w");
  fprintf(foo, "foo file test");
  fclose(foo);

  FILE* con = fopen("con", "w");
  fprintf(con, "con file test");
  fclose(con);
}
```
 
그리고 그 추상화된 소통 인터페이스에 대한 I/O, User mode의 Kernel 호출을 함수화 한 형태가 System call이다.

# Socket은 File이다.
NIC를 예로 들어보자. L3 라우터, L2스위치를 거쳐 NIC가 연결되어있을 것이다.  NIC에도 드라이버가 당연히 존재한다. 그럼 그에 상응하는 OS구성요소는? TCP/IP Protocol을 Network I/O할 수 있는 구성 요소가 커널에 구현되어있다(운영체제 별로 명칭 상이). 더 상단으로 올라가서 application layer에서 크롬을 예로 들어보자. 크롬이 Network I/O를 위해 커널과 소통하려면 앞서 설명한대로 추상 인터페이스, 즉, 파일이 필요하다. 그리고 그 파일을 바로 Socket이라고 부른다.

물론 증거가 있다. 리눅스에서 lsof(list open file)을 수행하면 어떤 프로세스가 어떤 소켓을 열었는지까지 모두 확인할 수 있는데, 이건 전혀 놀라운일이 아닌 것이다. 
즉 소켓이 위치한 영역은 인터페이스 파일이 존재하는 영역, 즉 Service layer이다. 우리가 TCP Socket 연결을 통해 네트워크를 타고 소통한다는 것은 결론적으로 Socket 즉, File에 대한 I/O를 실행하고 있는 것이다. local에서 loop back했건 어딘지 모를 호스트의 프로세스가 보냈건 말이다.

마지막으로 조금만 더 용어를 정확히 하자면 추상 인터페이스를 위한 파일들을 다른 파일, 예를 들어 mp3파일 같은 것들과 구분하기 위해 device file이라고 부르기도 한다.

# Host 판단 기준
컴퓨터가 인터넷에 연결되면 호스트이다. 그리고 호스트들은 네트워크 자체가 아니고 네트워크 이용 주체이다. 당연히 호스트들은 네크워크의 끝단에 위치한 존재들이므로 엔드포인트 들이다. 엔드포인트라는 말은 호스트안에 포함되는 말이다. 이런 호스트들이 역할에 따라서 클라이언트로 불리기도하고 서버로 불리기도한다. 라우터는 호스트가 아닐까? 라우터도 호스트다. 위에 설명한 컴퓨터 구조를 가진 개체들은 다 호스트다.

# Driver와 구성 요소 사이
다시 드라이버와 구성요소로 돌아와서, 파일시스템과 디스크 드라이버 사이(커널 영역 내부)에는 말하자면 '필터'가 존재할 수 있는데, 예를 들어 안티바이러스 같은 프로그램을 구동시키면 서비스 영역에 프로세스가 실행되며 파일시스템과 드라이버 사이에 실시간 감시 필터가 끼어든다. 검사를 거치게 되면 필연적으로 디스크 입출력이 느려진다. 네트워크 개발할 때 많이 쓰는 WinPCap이 NIC 드라이버와 구성요소 사이의 필터자리에 위치해 WireShark에게 왓다갓다하는 데이터를 감시할 수 있게 해준다.

# 내용 출처
이 내용은 삼성 SDS 멀티캠퍼스 보안 분야 전임 교수인 최호성 개발자의 의견을 전적으로 참고한 것임을 알린다. 저자 대신 내용 자체의 출처를 댈 수 없는 것은 최호성 개발자에 대한 후원을 통한 영상으로 학습한 내용이기 때문이다.

프로필이 따로 없어 교보문고 저자 소개 페이지로 대신한다.  
https://www.kyobobook.co.kr/author/info/AuthorInfoNew.laf?mallGb=KAU&authorid=1001573103
