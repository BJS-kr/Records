# Test Pyramid
 테스트 피라미드는 계층화된 테스트 작성 이론으로, 흔히들 말하는 unit test, service test, UI test의 3계층으로 설명하는 글이 가장 전형적인 것 같다. 그러나 이런 분류는 상황에 맞춰 적용하면 된다고 언급하고 있으므로(test pyramid, martinfowler.com), 딱히 용어에 구속될 필요는 없다.

 가장 중요한 컨셉은 두 가지다.
 1. 계층적 테스트를 작성할 것
 2. high-level일 수록 적은 테스트를 작성할 것

# 테스트 자동화의 중요성
 품질을 희생하지 않고 개발의 결과를 배포하고 싶다면 테스트 자동화는 필수다. 현대 소프트웨어 개발에서 가장 중요한 용어들 중 하나로 자리잡은 Continuous Delivery는 제품의 작동성을 보장하며 프로덕션에 언제든 배포할 수 있도록 한다는 의미이다. 이 과정에서 보통 우리는 pipeline을 만든다.

 building - testing - deploying 사이클을 수동으로 수행하는 것은 선택적 사항이 아니라 불가능한 사항이다.
 시간이 오래 걸리는 것은 물론이거니와, 이런 반복적이고 피로한 작업은 개발자들의 능률을 극도로 떨어뜨린다.

# 그래서 어떻게 하라구요
테스트 자동화라는 말은 듣기 참 좋다. 그런데 문제가 하나있다. 그냥 테스트만 자동으로 돌리면 테스트 자동화인가? 테스트의 핵심은 제품이 기획된 비즈니스적 가치를 제대로 수행함을 보증하는 역할이다. 이 보증을 어떻게 해야하는가? 테스트가 지나치게 거대하고 무거우면 테스트 수행에만 납득할 수 없는 시간이 걸려버린다. 
그렇다면 해결해야하는 문제가 분명해진다.

**최소한의 테스트로 비즈니스 로직 수행 가능성을 보장하라**

# 피라미드 1층 탐험
미지의 테스트 피라미드 세계를 모험하며 과연 이 이론적 유적이 우리의 문제를 어떻게 해결 해 줄수 있는지 알아보자. 일단 피라미드가 계층적 구조라는 것은 이미 언급한바 있다. 우린 막 피라미드의 입구에 들어섰다. 가장 넓고, 많은 벽돌로 이루어진 1층의 석조 재료는 다름 아닌 Unit test들이다. 또한 벽돌들이 상당히 작은 크기로 이루어져 있음을 당신은 알게된다. 무게를 거의 느끼지 못할 정도이고, 마음 껏 들고 던질수 있을 만큼 말이다. 당신을 재미를 위해 벽을 이루고 있는 작은 조각을 빼내어(실제로는 테스트를 삭제하면 안된다. 피라미드를 훼손하면 벌을 받게 되는 것과 같은 이치이다) 던졌지만 워낙 작은 조각이 벽에서 빠져나온지라 솔직히 차이를 알아채기도 힘들 정도이다. 

당신은 1층에서 배운 것을 써먹기 위해 Unit test로 피라미드 건설을 시작해야한다고 동료들에게 말했고 모두가 좋은 의견이라며 찬성해주었다. 그런데 누군가 손을 들고 말했다. '유닛이 뭔데요?'. 한 마디에 모두가 의견을 내느라 회의실은 순식간에 시장바닥처럼 시끄러워진다. 놀라운건, 그 많은 의견이 하나같이 모두 다르다는 것이다.

이 난장판에서 다행인 것은 사실 Unit의 정확한 정의자체는 그다지 중요하지 않다는 점이다. Unit이 가장 적은 범위라는 것만 기억하면 된다. 예를 들어, 함수형 프로그래밍 중이라면 개개의 함수일 수 있고 객체지향형 프로그래밍 중이라면 객체에 들어있는 메서드 하나 하나일 수 있다. 

함수형 프로그래밍에 매력을 느끼는 입장으로 '함수'라는 것에 대해서 짚고 넘어가야겠다. 함수형 프로그래밍에서, 함수는 이미 내부에 다른 함수들이 합성된 형태일 가능성이 충분하다. 그렇다면 어디까지가 Unit인 함수인가? 여기에 대해서 참 애매한 대답을 내놓을 수 밖에 없겠다. non-trivial한 첫 수준이다. 함수형 프로그래밍에선 아주 단순한 계산도 함수로 표현하기를 참 좋아한다. 함수의 명칭 자체도 추상화의 일종이기 때문이다. 예를 들어, x,y를 인자로 받고 x+y를 반환하는 함수도 존재할 수 있다는 말이다(알고 있다. 이는 문맥에 맞지 않는 예시다. 그러나 합성가능성에 대하여 논하고자 하는 것이 아니니 너그럽게 이해해주길 바란다). 그 과정이 함수로 표현될만 하다면 함수형은 그 어떤 것도 함수로 표현할 준비가 되어 있다. 그러나 사소한 함수들도 모여서 합성되다보면 사소하지 않기(non-trivial) 마련이다. 바로 그 시점을 Unit test가 필요한 함수라고 생각하면 된다.

건물은 벽돌로 이루어져있지만 벽돌이 건물은 아니다. 유닛 테스트는 벽돌 하나하나가 단단하고 올바르게 구워졌는지를 검사하는 과정이다. 유닛 테스트를 작성할때의 주의점은, '모든 벽돌을 검사하려 들지 말 것'이다. TDD를 쓴 kent beck본인 마저도 오류가 나지 않을 것이 확실한 코드에는 테스트를 작성하지 않는 다는 것을 분명히 하고 있다. 

즉, '공리'의 수준을 어느 정도로 할 것인가가 문제이다. 예를 들어, 우리는 CPU가 기계어를 정확히 인지하는지를 테스트하려 들지 않는다. 너무 저수준으로 생각되는가? 고수준 언어를 예로 들어보자. Node.js의 fs모듈을 우리가 테스트하려고 하는가? 물론 아니다. 왜인가? 작동할 가능성이 충분하기 때문이다. 프로그래밍은 수학이 아니라 과학이다. 정상 작동할 확률이 100%가 아님에도 불구하고 정상 작동할 가능성이 충분하기 때문에 발사될 우주선에 몸을 싣는 우주인들 처럼, 우리는 정상 작동할 가능성이 충분한 것은 테스트하지 않는다. 조금 더 고수준이 되더라도 이런 확신은 충분히 가질 수 있다. 다만 어느 수준까지를 충분히 '공리'라고 평가할지는 개발자 혹은 개발팀에 달린 문제다.

### 고독한(solitary) 유닛, 사교적인(sociable) 유닛
아마 유닛 테스트에서 가장 논쟁이 많은 주제중 하나일 것이다. 유닛 테스트는 완전히 고립(모든 필요 객체를 대체)되어야 하는가? 혹은 무거운 녀석들(e.g. DB, Network calls)정도만 대체되면 충분한가? 

사실 이런 결정사항들은 딱히 중요하지 않음을 명심하면 논쟁에 시간 낭비할 일이 없다. 각 방법들은 장단이 있지만 드라마틱하지는 않다. 단지 동료들이 선호하는 방법을 도출해 적용하면 될 뿐이다. 중요한 것은 자동화다.
solitary 테스트와 sociable 테스트를 혼용한다고 해도 상관없다.

### Mocking & Stubbing
테스트에 필요한 객체들을 대체하는 대표적인 방법으로 Mock과 Stub이 가장 많이 꼽힐 것이다. DB, FS, Network call등이 모두 대체 되어있을 것이므로 Unit test의 실행속도는 매우 빠를 것이다.  Mock과 Stub은 다르다. Mock은 '과정'을 보여주고 Stub은 '결과'를 보여준다.

이 부분은 Mocks aren't Stubs를 참고하길 바란다.
하나 주의할 점은, Mock과 Stub은 종종 논란의 대상이 되곤한다는 것이다.
Stub은 특히 '고전 학파'에서 선호하는 방식이며, Mock를 Monkey Patching으로 정의하고 이를 Code smell로 평가하는 경우(clean architecture with python)도 존재한다.

Mock과 Stub을 직접 작성해도 좋고 테스트 라이브러리들이 제공하는 기능을 써도 상관없다. 별 것 아닌것에 얽매일 필요는 없다.

### 무엇을 테스트해야 하는가?
테스트에 제한은 없다. controller건 repository건 간에 말이다. 간단한 규칙을 설정하고 출발하는 것도 좋다.
'one test per production class'만 따른다고 생각하며 작성해도 좋다.

unit test class는 최소한 테스트 대상 클래스의 public interface는 테스트해야 한다. 말이 좀 이상하다. 그렇다면 public이 아닌 것을 테스트하는 경우도 존재한다는 말인가? 조금 생각해볼 필요가 있다. private을 테스트하는 것은 분명 잘못된일이다(이해가 가지 않는다면 잠시 구글링을 해보자). 남은 것은 protected와 package-private(같은 package내에서만 접근 가능함을 명시하는 access modifier)인데 테스트 클래스에서 접근은 가능할지도 모르나(test class를 자식 클래스로 만든다던가... 그런데 대체 왜?), private을 테스트하지 말아야하는 이유와 같은 이유로 딱히 테스트를 할 이유를 찾기는 어렵다.

여기서 핵심에 접근하게 된다. 분명 Unit test는 happy path와 edge case를 포함하여 테스트 되어야 하나
'세부구현'에 지나치게 다가가면 안된다. 왜 인가?

세부 구현은 언제나 바뀌기 때문이다. 코드는 멈춰있지 않는다(멈춰있으면 문제다). 끊임없이 수정되지만 인터페이스는 잘 바뀌지 않는다(비즈니스 로직은 세부구현이 아니라 인터페이스의 집합으로 표현된다고 해도 과언이 아니다). 테스트가 세부 구현을 바라보게 되면 테스트가 세부 구현에 종속되어 변경되어야하는 괴상한 상황이 생긴다. 주도권이 역전되는 것으로 매우 바람직하지 않다.

이 관점에서 private을 바라보는 생각도 확실해진다. private은, 세부 구현이다(!). 

**You don't test trivial code. Kent Beck said it's ok**

### 그래서 어떻게요!
세 가지만 기억하자. 

1. 테스트 데이터를 준비한다.
2. 테스트할 메서드를 호출한다.
3. 기대와 일치하는지 Assert한다. 

이는 가장 단순화 된 단계들이지만 응용한다고 해도 크게 보아 이 구조에서 벗어날 일은 사실상 없다.
이는 종종 "Arrange, Act, Assert" 혹은, BDD적인 표현으로 "given, when, then"으로 표현된다.

# 이제 피라미드 2층으로 올라갑시다
작디 작은 벽돌들로 이루어진 1층을 지나 2층으로 올라온 당신은 이제야 평소에 당신이 벽돌이라고 부르던 것만한 크기의 구성물들을 보게 된다. 그런데 벽돌들을 자세히 들여다보던 당신은 유적물이라기엔 어울리지 않는 표시들을 발견하게 된다. 몇몇 벽돌에는 이 벽돌을 생산한 공장의 트레이드마크가 떡하니 박혀 있는 것이다. 피라미드라기엔 어처구니 없는 표식들을 읽어보니 "MySQL", "PostgreSQL", "GraphAPI"등의 대형 공장들의 마크가 분명하다. 그제서야 당신은 트레이드마크가 박힌 벽돌들은 주위에 트레이드마크가 없는 벽돌들이 감싸고 있으며, 그렇게 감싸진 형태가 또다시 더욱 커다란 벽돌이 되어 2층을 이루고 있음을 발견한다. 

피라미드의 1층엔 가짜가 당연하게 쓰이던 것(sociable unit test라고 할지라도)을 기억하는가?
지금부터는 진짜들이 필요하다. 당신이 사용할 데이터베이스가 질의에 따라 데이터를 저장하거나 잘 읽어오는지, 개발 기간동안 소셜 기능을 제공하는 API들의 응답 값이 바뀌지는 않았는지 검사해볼 시간이라는 것이다. 당신이 개발하지 않은 외부의 것들과의 통합(integration)을 전반적으로 테스트해보아야한다.

Unit test도 개인의 해석이 끼어들 여지가 많았던 것을 기억하는가? integration test는 더 심하다. 누군가는 
당신의 프로그램 전체에 대하여 모든 외부 스택들이 잘 작동하는지를 테스트하는 것이라고 해석할 수도 있다.
Integration test를 좀 더 잘 해석해볼 순 없을까? 예를 들어 두개의 외부 스택을 동시에 테스트하는 것은 별로 바람직 하지 않은 것 같다. 그렇다면 각 테스트 별로 테스트할 외부 스택을 타겟으로, 나머지 테스트 더블들은 Unit test를 할 때와 같이 유지하는 것은 어떨까? 훨씬 구체적이고 명확한 정보를 전해줄 수 있는 테스트가 될 것이다. 예를 들어 어떤 함수가 외부 REST API에서 값을 받아온 후, DB에 저장할 경우에 타겟이 DB라면 DB를  실제로 연결하고 REST API는 Stub상태여도 아무 상관없다는 것이다. 이를 Narrower Integration Test로 명명하기로 하자.

이런 방식은 컨테이너 기술과 결합해 더욱 편의성을 제공하는 면이 있다. 볼륨 없는 컨테이너를 실행시킨 후 테스트와 통합시키면 당신의 Integration test는 실제 스택에 대하여 동작을 검사할 수 있을 뿐더러 테스트 종료 후 컨테이너가 종료되면 데이터의 흔적도 남지 않게 된다. 물론 컨테이너를 구동하고 종료하는 과정도 모두 자동화하여 테스트와 결합할 수 있다.

Narrow Integration test에서 꽤 중요한 점은, 당신이 통합해보고자 하는 모든 것을 local환경에서 구동시키는 것이다.
만약 외부 API를 로컬 환경에서 구동하는 것이 불가능하다면? 예를 들어서 GraphAPI같은 것들 말이다. The Practical Test Pyramid의 저자인 Ham Vocke는 이런 경우에는 최대한 Test Instance를 당신이 테스트해보고자하는 외부 API와 비슷하게 구현해 테스트할 것을 권하고 있다. 

그 이유는 다음과 같다.
테스트 요청을 프로덕션에 배포된 API에 날리는 것은 매우 바람직 하지 않은데, API를 제공하고 유지보수하는 사람들이 지켜봐야하는 로그를 어지럽힐 뿐 아니라, DoS로 느껴질 법한 행위이기 때문이다. 실제 네트워크를 타고 테스트하는 것은 Broad Integration Test의 범위에 속한다고 할 수 있다. 보통 Broad보다 Narrow 방식이 권장되는 이유는 앞서 말한 사람들의 노고를 해치는 것 뿐 아니라, 훨씬 느리고 작성하기도 어려울 것이 뻔하기 때문이다.

통합 테스트는 유닛 테스트는 제공해 줄 수 없는, 외부와의 협력에 대한 확신을 제공해준다. 

## 뭔가 빠진 것 같은데요?
마음에 안 든다. 불편하다. 외부 서비스의 개발자들의 노고는 이해한다고 하더라도, 내가 개발하는 서비스가 제대로 작동하는지에 대한 확신이 없는데(test instance로 외부 서비스를 표방하니까) 어떻게 개발을 하라는 것인가? 

다행히도 많은 개발자들이 불편함을 호소했고, 결과적으로 Contract Test라는 개념이 등장한다.

# Contract Test
웹 개발자들에게 익숙할 수 있도록 REST에 빗대어 설명하겠다. 현대 소프트웨어 개발에서 모든 팀이 서로의 구현을 살피며 개발한다는 것은 말도 안된다. 그러나 최종적으로 모든 팀의 결과물은 한 몸처럼 동작해야한다. 어떻게 이를 이룰 수 있을까? 각 팀들의 결과물은 따지자면 외부 API나 다를 바 없다. 테스트를 한답시고 다른 팀이 만들어둔 서비스를 끊임없이 호출해 로그를 어지럽힌다면 좋은 소리 못 들을 것이 뻔하다.

자, 우리는 딜레마에 갇혔다. '실제로' 통합되는지 테스트는 해야하는데 '실제 구현'에 대고 테스트를 하면 안된다. 

이때 interface가 끼어든다.

interface를 java나 typescript 등의 interface라고 해석하는 것은 좁은 해석이다(물론 서로에게 어떻게 다가서야하는지를 알려준다는 점에서는 같다). HTTPS를 통해서만 접근하는 REST & JSON 인터페이스일수도 있고, gRPC등의 RPC모양새 일 수도 있다. asynchronous event-driven architecture라면 queue의 event 입출력에 주목할 수 밖에 없을 것이다.

interface를 조금 다르게 정의해보자. 일단 interface가 가치 있으려면 provider와 consumer가 필요한데, 잠시 생각해보면 당연한 일이다. provider는 data를 제공하고, consumer는 data를 받아서 작업하는 입장이다. event-driven architecture라면 provider는 publisher가 되고 consumer는 subscriber가 된다.

이러한 interface는 역사적으로 다양한 형태로 제작되었는데, 예를 들면 다음과 같다.

1. 길고 자세한 인터페이스 명세를 작성한다(the contract, 괜히 contract라는 말이 쓰이는 것이 아니다)
2. contract대로 서비스를 개발한다
3. contract를 consumer service를 개발해야하는 팀에게 던진다.
4. consume하는 부분의 구현을 기다린다.
5. 길고 긴 테스트 메뉴얼을 작성해 수동으로 일일히 테스트한다.
6. provider와 consumer팀이 interface의 명세대로만 구현하길 간절히 기도한다.

좀 더 현대적인 형태에서는 5번과 6번을 대체한다. interface를 강제로 벗어날 수 없게 하고 회귀 테스트를 통해 이로(deviation)을 방지하거나 빠르게 알아차릴 수 있게 한다.

### CDC(Consumer-Driven Contract) Test
CDC는 기존의 C(ontract)에서 테스트를 바라보는 시점을 바꾼 것이다.
Consumer team이 interface로부터 필요한 데이터들에 관한 test를 작성한다. 그 다음 그 test들을 provider 팀에게 전달한다. 이제 provider팀이 consumer팀이 작성해준 테스트를 목표로 구현을 시작한다!

이는 다음과 같이 표현될 수 있다.
- Consumer: write & publish 
- Provider: fetch & execute

이 방식은 Provider팀이 개발의 우선순위를 정할 수 있게 해준다는데에서 큰 의미를 가진다. Consumer팀도 마찬가지로 자신들이 작성한 테스트가 실행된다는 점에서 보다 확신을 얻을 수 있다. 물론 test도 기획 혹은 필요가 바뀜에 따라
계속 변경되기 마련이니 지속적인 통합 pipeline이 필요함을 염두해야한다.
이렇게 되면 provider팀은 자신들의 변경때문에 consumer팀이 고생하지 않을까 하는 걱정은 하지 않아도 된다.

이 과정은 개략적으로 다음과 같을 것이다.
- consumer team은 자신들의 기대에 부합하는 자동화된 테스트를 작성한다.
- provider team에게 테스트를 제공한다.
- provider team은 CDC test를 지속적으로 실행하며 green을 유지한다.
- CDC가 실패하면 즉시 consumer와 provider는 communication을 통해 상황을 파악한다.

CDC가 주는 또 하나의 강력한 이점은 팀간의 소통이 매우 원활해진다는 것이다. 무엇을 원하는지, 무엇을 구현하는지를 명확하게 파악하게 되고, CDC실패를 해결하기 위해 소통이 강제 되다시피한다.

CDC를 도와주는 툴도 물론 존재한다.  
JS라면 https://github.com/pact-foundation/pact-js를 참고하면 되고, Pact라는 구현은 많은 mainstream언어에서 사용 가능하도록 되어있으니 자신이 사용하는 언어에 맞는 Pact를 찾아 쓰면 된다.

CDC는 테스트를 통해 빠르게 성장하는 서비스를 안정적으로 구축할 수 있게하는 방법이다.

















