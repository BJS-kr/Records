**ham vocke가 저술한 'Practical Test Pyramid'를 최대한 재밌고 읽기 쉽게, 또 이해하기도 쉽게 풀어쓰려고 노력한 글입니다. 원문은 https://martinfowler.com/articles/practical-test-pyramid.html를 참고해주세요** 
# Test Pyramid
 테스트 피라미드는 계층화된 테스트 작성 이론으로, 흔히들 말하는 unit test, service test, UI test의 3계층으로 설명하는 글이 가장 전형적인 것 같다. 그러나 이런 분류는 상황에 맞춰 적용하면 된다고 언급하고 있으므로(test pyramid, martinfowler.com), 딱히 용어에 구속될 필요는 없다.

 가장 중요한 컨셉은 두 가지다.
 1. 계층적 테스트를 작성할 것
 2. high-level일 수록 적은 테스트를 작성할 것

# 테스트 자동화의 중요성
 품질을 희생하지 않고 개발의 결과를 배포하고 싶다면 테스트 자동화는 필수다. 현대 소프트웨어 개발에서 가장 중요한 용어들 중 하나로 자리잡은 Continuous Delivery는 제품의 작동성을 보장하며 프로덕션에 언제든 배포할 수 있도록 한다는 의미이다. 이 과정에서 보통 우리는 pipeline을 만든다.

 building - testing - deploying 사이클을 수동으로 수행하는 것은 선택적 사항이 아니라 불가능한 사항이다.
 시간이 오래 걸리는 것은 물론이거니와, 이런 반복적이고 피로한 작업은 개발자들의 능률을 극도로 떨어뜨린다.

# 그래서 어떻게 하라구요
테스트 자동화라는 말은 듣기 참 좋다. 그런데 문제가 하나있다. 그냥 테스트만 자동으로 돌리면 테스트 자동화인가? 테스트의 핵심은 제품이 기획된 비즈니스적 가치를 제대로 수행함을 보증하는 역할이다. 이 보증을 어떻게 해야하는가? 테스트가 지나치게 거대하고 무거우면 테스트 수행에만 납득할 수 없는 시간이 걸려버린다. 
그렇다면 해결해야하는 문제가 분명해진다.

**최소한의 테스트로 비즈니스 로직 수행 가능성을 보장하라**

# 피라미드 1층 탐험
미지의 테스트 피라미드 세계를 모험하며 과연 이 이론적 유적이 우리의 문제를 어떻게 해결 해 줄수 있는지 알아보자. 일단 피라미드가 계층적 구조라는 것은 이미 언급한바 있다. 우린 막 피라미드의 입구에 들어섰다. 가장 넓고, 많은 벽돌로 이루어진 1층의 석조 재료는 다름 아닌 Unit test들이다. 또한 벽돌들이 상당히 작은 크기로 이루어져 있음을 당신은 알게된다. 무게를 거의 느끼지 못할 정도이고, 마음 껏 들고 던질수 있을 만큼 말이다. 당신은 재미를 위해 벽을 이루고 있는 작은 조각을 빼내어(실제로는 테스트를 삭제하면 안된다. 피라미드를 훼손하면 벌을 받게 되는 것과 같은 이치이다) 던졌지만 워낙 작은 조각이 벽에서 빠져나온지라 솔직히 차이를 알아채기도 힘들 정도이다. 

당신은 1층에서 배운 것을 써먹기 위해 Unit test로 피라미드 건설을 시작해야한다고 동료들에게 말했고 모두가 좋은 의견이라며 찬성해주었다. 그런데 누군가 손을 들고 말했다. '유닛이 뭔데요?'. 한 마디에 모두가 의견을 내느라 회의실은 순식간에 시장바닥처럼 시끄러워진다. 놀라운건, 그 많은 의견이 하나같이 모두 다르다는 것이다.

이 난장판에서 다행인 것은 사실 Unit의 정확한 정의자체는 그다지 중요하지 않다는 점이다. Unit이 가장 적은 범위라는 것만 기억하면 된다. 예를 들어, 함수형 프로그래밍 중이라면 개개의 함수일 수 있고 객체지향형 프로그래밍 중이라면 객체에 들어있는 메서드 하나 하나일 수 있다. 

함수형 프로그래밍에 매력을 느끼는 입장으로 '함수'라는 것에 대해서 짚고 넘어가야겠다. 함수형 프로그래밍에서, 함수는 이미 내부에 다른 함수들이 합성된 형태일 가능성이 충분하다. 그렇다면 어디까지가 Unit인 함수인가? 여기에 대해서 참 애매한 대답을 내놓을 수 밖에 없겠다. non-trivial한 첫 수준이다. 함수형 프로그래밍에선 아주 단순한 계산도 함수로 표현하기를 참 좋아한다. 함수의 명칭 자체도 추상화의 일종이기 때문이다. 예를 들어, x,y를 인자로 받고 x+y를 반환하는 함수도 존재할 수 있다는 말이다(알고 있다. 이는 문맥에 맞지 않는 예시다. 그러나 합성가능성에 대하여 논하고자 하는 것이 아니니 너그럽게 이해해주길 바란다). 그 과정이 함수로 표현될만 하다면 함수형은 그 어떤 것도 함수로 표현할 준비가 되어 있다. 그러나 사소한 함수들도 모여서 합성되다보면 사소하지 않기(non-trivial) 마련이다. 바로 그 시점을 Unit test가 필요한 함수라고 생각하면 된다.

건물은 벽돌로 이루어져있지만 벽돌이 건물은 아니다. 유닛 테스트는 벽돌 하나하나가 단단하고 올바르게 구워졌는지를 검사하는 과정이다. 유닛 테스트를 작성할때의 주의점은, '모든 벽돌을 검사하려 들지 말 것'이다. TDD를 쓴 kent beck본인 마저도 오류가 나지 않을 것이 확실한 코드에는 테스트를 작성하지 않는 다는 것을 분명히 하고 있다. 

즉, '공리'의 수준을 어느 정도로 할 것인가가 문제이다. 예를 들어, 우리는 CPU가 기계어를 정확히 인지하는지를 테스트하려 들지 않는다. 너무 저수준으로 생각되는가? 고수준 언어를 예로 들어보자. Node.js의 fs모듈을 우리가 테스트하려고 하는가? 물론 아니다. 왜인가? 작동할 가능성이 충분하기 때문이다. 프로그래밍은 수학이 아니라 과학이다. 정상 작동할 확률이 100%가 아님에도 불구하고 정상 작동할 가능성이 충분하기 때문에 발사될 우주선에 몸을 싣는 우주인들 처럼, 우리는 정상 작동할 가능성이 충분한 것은 테스트하지 않는다. 조금 더 고수준이 되더라도 이런 확신은 충분히 가질 수 있다. 다만 어느 수준까지를 충분히 '공리'라고 평가할지는 개발자 혹은 개발팀에 달린 문제다.

### 고독한(solitary) 유닛, 사교적인(sociable) 유닛
아마 유닛 테스트에서 가장 논쟁이 많은 주제중 하나일 것이다. 유닛 테스트는 완전히 고립(모든 필요 객체를 대체)되어야 하는가? 혹은 무거운 녀석들(e.g. DB, Network calls)정도만 대체되면 충분한가? 

사실 이런 결정사항들은 딱히 중요하지 않음을 명심하면 논쟁에 시간 낭비할 일이 없다. 각 방법들은 장단이 있지만 드라마틱하지는 않다. 단지 동료들이 선호하는 방법을 도출해 적용하면 될 뿐이다. 중요한 것은 자동화다.
solitary 테스트와 sociable 테스트를 혼용한다고 해도 상관없다.

### Mocking & Stubbing
테스트에 필요한 객체들을 대체하는 대표적인 방법으로 Mock과 Stub이 가장 많이 꼽힐 것이다. DB, FS, Network call등이 모두 대체 되어있을 것이므로 Unit test의 실행속도는 매우 빠를 것이다.  Mock과 Stub은 다르다. Mock은 '과정'을 보여주고 Stub은 '결과'를 보여준다.

이 부분은 Mocks aren't Stubs를 참고하길 바란다.
하나 주의할 점은, Mock과 Stub은 종종 논란의 대상이 되곤한다는 것이다.
Stub은 특히 '고전 학파'에서 선호하는 방식이며, Mock를 Monkey Patching으로 정의하고 이를 Code smell로 평가하는 경우(clean architecture with python)도 존재한다.

Mock과 Stub을 직접 작성해도 좋고 테스트 라이브러리들이 제공하는 기능을 써도 상관없다. 별 것 아닌것에 얽매일 필요는 없다.

### 무엇을 테스트해야 하는가?
테스트에 제한은 없다. controller건 repository건 간에 말이다. 간단한 규칙을 설정하고 출발하는 것도 좋다.
'one test per production class'만 따른다고 생각하며 작성해도 좋다.

unit test class는 최소한 테스트 대상 클래스의 public interface는 테스트해야 한다. 말이 좀 이상하다. 그렇다면 public이 아닌 것을 테스트하는 경우도 존재한다는 말인가? 조금 생각해볼 필요가 있다. private을 테스트하는 것은 분명 잘못된일이다(이해가 가지 않는다면 잠시 구글링을 해보자). 남은 것은 protected와 package-private(같은 package내에서만 접근 가능함을 명시하는 access modifier)인데 테스트 클래스에서 접근은 가능할지도 모르나(test class를 자식 클래스로 만든다던가... 그런데 대체 왜?), private을 테스트하지 말아야하는 이유와 같은 이유로 딱히 테스트를 할 이유를 찾기는 어렵다.

여기서 핵심에 접근하게 된다. 분명 Unit test는 happy path와 edge case를 포함하여 테스트 되어야 하나
'세부구현'에 지나치게 다가가면 안된다. 왜 인가?

세부 구현은 언제나 바뀌기 때문이다. 코드는 멈춰있지 않는다(멈춰있으면 문제다). 끊임없이 수정되지만 인터페이스는 잘 바뀌지 않는다(비즈니스 로직은 세부구현이 아니라 인터페이스의 집합으로 표현된다고 해도 과언이 아니다). 테스트가 세부 구현을 바라보게 되면 테스트가 세부 구현에 종속되어 변경되어야하는 괴상한 상황이 생긴다. 주도권이 역전되는 것으로 매우 바람직하지 않다.

이 관점에서 private을 바라보는 생각도 확실해진다. private은, 세부 구현이다(!). 

**You don't test trivial code. Kent Beck said it's ok**

### 그래서 어떻게요!
세 가지만 기억하자. 

1. 테스트 데이터를 준비한다.
2. 테스트할 메서드를 호출한다.
3. 기대와 일치하는지 Assert한다. 

이는 가장 단순화 된 단계들이지만 응용한다고 해도 크게 보아 이 구조에서 벗어날 일은 사실상 없다.
이는 종종 "Arrange, Act, Assert" 혹은, BDD적인 표현으로 "given, when, then"으로 표현된다.

# 이제 피라미드 2층으로 올라갑시다
작디 작은 벽돌들로 이루어진 1층을 지나 2층으로 올라온 당신은 이제야 평소에 당신이 벽돌이라고 부르던 것만한 크기의 구성물들을 보게 된다. 그런데 벽돌들을 자세히 들여다보던 당신은 유적물이라기엔 어울리지 않는 표시들을 발견하게 된다. 몇몇 벽돌에는 이 벽돌을 생산한 공장의 트레이드마크가 떡하니 박혀 있는 것이다. 피라미드라기엔 어처구니 없는 표식들을 읽어보니 "MySQL", "PostgreSQL", "GraphAPI"등의 대형 공장들의 마크가 분명하다. 그제서야 당신은 트레이드마크가 박힌 벽돌들은 주위에 트레이드마크가 없는 벽돌들이 감싸고 있으며, 그렇게 감싸진 형태가 또다시 더욱 커다란 벽돌이 되어 2층을 이루고 있음을 발견한다. 

피라미드의 1층엔 가짜가 당연하게 쓰이던 것(sociable unit test라고 할지라도)을 기억하는가?
지금부터는 진짜들이 필요하다. 당신이 사용할 데이터베이스가 질의에 따라 데이터를 저장하거나 잘 읽어오는지, 개발 기간동안 소셜 기능을 제공하는 API들의 응답 값이 바뀌지는 않았는지 검사해볼 시간이라는 것이다. 당신이 개발하지 않은 외부의 것들과의 통합(integration)을 전반적으로 테스트해보아야한다.

Unit test도 개인의 해석이 끼어들 여지가 많았던 것을 기억하는가? integration test는 더 심하다. 누군가는 
당신의 프로그램 전체에 대하여 모든 외부 스택들이 잘 작동하는지를 테스트하는 것이라고 해석할 수도 있다.
Integration test를 좀 더 잘 해석해볼 순 없을까? 예를 들어 두개의 외부 스택을 동시에 테스트하는 것은 별로 바람직 하지 않은 것 같다. 그렇다면 각 테스트 별로 테스트할 외부 스택을 타겟으로, 나머지 테스트 더블들은 Unit test를 할 때와 같이 유지하는 것은 어떨까? 훨씬 구체적이고 명확한 정보를 전해줄 수 있는 테스트가 될 것이다. 예를 들어 어떤 함수가 외부 REST API에서 값을 받아온 후, DB에 저장할 경우에 타겟이 DB라면 DB를  실제로 연결하고 REST API는 Stub상태여도 아무 상관없다는 것이다. 이를 Narrower Integration Test로 명명하기로 하자.

이런 방식은 컨테이너 기술과 결합해 더욱 편의성을 제공하는 면이 있다. 볼륨 없는 컨테이너를 실행시킨 후 테스트와 통합시키면 당신의 Integration test는 실제 스택에 대하여 동작을 검사할 수 있을 뿐더러 테스트 종료 후 컨테이너가 종료되면 데이터의 흔적도 남지 않게 된다. 물론 컨테이너를 구동하고 종료하는 과정도 모두 자동화하여 테스트와 결합할 수 있다.

Narrow Integration test에서 꽤 중요한 점은, 당신이 통합해보고자 하는 모든 것을 local환경에서 구동시키는 것이다.
만약 외부 API를 로컬 환경에서 구동하는 것이 불가능하다면? 예를 들어서 GraphAPI같은 것들 말이다. The Practical Test Pyramid의 저자인 Ham Vocke는 이런 경우에는 최대한 Test Instance를 당신이 테스트해보고자하는 외부 API와 비슷하게 구현해 테스트할 것을 권하고 있다. 

그 이유는 다음과 같다.
테스트 요청을 프로덕션에 배포된 API에 날리는 것은 매우 바람직 하지 않은데, API를 제공하고 유지보수하는 사람들이 지켜봐야하는 로그를 어지럽힐 뿐 아니라, DoS로 느껴질 법한 행위이기 때문이다. 실제 네트워크를 타고 테스트하는 것은 Broad Integration Test의 범위에 속한다고 할 수 있다. 보통 Broad보다 Narrow 방식이 권장되는 이유는 앞서 말한 사람들의 노고를 해치는 것 뿐 아니라, 훨씬 느리고 작성하기도 어려울 것이 뻔하기 때문이다.

통합 테스트는 유닛 테스트는 제공해 줄 수 없는, 외부와의 협력에 대한 확신을 제공해준다. 

## 뭔가 빠진 것 같은데요?
마음에 안 든다. 불편하다. 외부 서비스의 개발자들의 노고는 이해한다고 하더라도, 내가 개발하는 서비스가 제대로 작동하는지에 대한 확신이 없는데(test instance로 외부 서비스를 표방하니까) 어떻게 개발을 하라는 것인가? 

다행히도 많은 개발자들이 불편함을 호소했고, 결과적으로 Contract Test라는 개념이 등장한다.

# Contract Test
웹 개발자들에게 익숙할 수 있도록 REST에 빗대어 설명하겠다. 현대 소프트웨어 개발에서 모든 팀이 서로의 구현을 살피며 개발한다는 것은 말도 안된다. 그러나 최종적으로 모든 팀의 결과물은 한 몸처럼 동작해야한다. 어떻게 이를 이룰 수 있을까? 각 팀들의 결과물은 따지자면 외부 API나 다를 바 없다. 테스트를 한답시고 다른 팀이 만들어둔 서비스를 끊임없이 호출해 로그를 어지럽힌다면 좋은 소리 못 들을 것이 뻔하다.

자, 우리는 딜레마에 갇혔다. '실제로' 통합되는지 테스트는 해야하는데 '실제 구현'에 대고 테스트를 하면 안된다. 

이때 interface가 끼어든다.

interface를 java나 typescript 등의 interface라고 해석하는 것은 좁은 해석이다(물론 서로에게 어떻게 다가서야하는지를 알려준다는 점에서는 같다). HTTPS를 통해서만 접근하는 REST & JSON 인터페이스일수도 있고, gRPC등의 RPC모양새 일 수도 있다. asynchronous event-driven architecture라면 queue의 event Pub/Sub에 주목할 수 밖에 없을 것이다.

interface를 조금 다르게 정의해보자. 일단 interface가 가치 있으려면 provider와 consumer가 필요한데, 잠시 생각해보면 당연한 일이다. provider는 data를 제공하고, consumer는 data를 받아서 작업하는 입장이다. event-driven architecture라면 provider는 publisher가 되고 consumer는 subscriber가 된다.

이러한 interface는 역사적으로 다양한 형태로 제작되었는데, 예를 들면 다음과 같다.

1. 길고 자세한 인터페이스 명세를 작성한다(the contract, 괜히 contract라는 말이 쓰이는 것이 아니다)
2. contract대로 서비스를 개발한다
3. contract를 consumer service를 개발해야하는 팀에게 던진다.
4. consume하는 부분의 구현을 기다린다.
5. 길고 긴 테스트 메뉴얼을 작성해 수동으로 일일히 테스트한다.
6. provider와 consumer팀이 interface의 명세대로만 구현하길 간절히 기도한다.

좀 더 현대적인 형태에서는 5번과 6번을 대체한다. interface를 강제로 벗어날 수 없게 하고 회귀 테스트를 통해 이로(deviation)를 방지하거나 빠르게 알아차릴 수 있게 한다.

### CDC(Consumer-Driven Contract) Test
CDC는 기존의 C(ontract)에서 테스트를 바라보는 시점을 바꾼 것이다.
Consumer team이 interface로부터 필요한 데이터들에 관한 test를 작성한다. 그 다음 그 test들을 provider 팀에게 전달한다. 이제 provider팀이 consumer팀이 작성해준 테스트를 목표로 구현을 시작한다!

이는 다음과 같이 표현될 수 있다.
- Consumer: write & publish
- Provider: fetch & execute

이 방식은 Provider팀이 개발의 우선순위를 정할 수 있게 해준다는데에서 큰 의미를 가진다. Consumer팀도 마찬가지로 자신들이 작성한 테스트가 실행된다는 점에서 보다 확신을 얻을 수 있다. 물론 test도 기획 혹은 필요가 바뀜에 따라
계속 변경되기 마련이니 지속적인 통합 pipeline이 필요함을 염두해야한다.
이렇게 되면 provider팀은 자신들의 변경때문에 consumer팀이 고생하지 않을까 하는 걱정은 하지 않아도 된다.

이 과정은 개략적으로 다음과 같을 것이다.
- consumer team은 자신들의 기대에 부합하는 자동화된 테스트를 작성한다.
- provider team에게 테스트를 제공한다.
- provider team은 CDC test를 지속적으로 실행하며 green을 유지한다.
- CDC가 실패하면 즉시 consumer와 provider는 communication을 통해 상황을 파악한다.

CDC가 주는 또 하나의 강력한 이점은 팀간의 소통이 매우 원활해진다는 것이다. 무엇을 원하는지, 무엇을 구현하는지를 명확하게 파악하게 되고, CDC실패를 해결하기 위해 소통이 강제 되다시피한다.

CDC를 도와주는 툴도 물론 존재한다.  
JS라면 https://github.com/pact-foundation/pact-js를 참고하면 되고, Pact라는 구현은 많은 mainstream언어에서 사용 가능하도록 되어있으니 자신이 사용하는 언어에 맞는 Pact를 찾아 쓰면 된다.

CDC는 테스트를 통해 빠르게 성장하는 서비스를 안정적으로 구축할 수 있게하는 방법이다.


# 이제 3층으로!
피라미드의 마지막 층(모든 피라미드가 3층으로 이루어져있다고 생각해서는 안된다. 원하는 만큼 테스트 계층을 구성하고 테스트 개념을 적용시키면 된다. 여기서는 가장 전형적인 형태만 설명할 뿐이다)으로 향해보자. 

2층도 넓지는 않았지만 이제부터는 겨우 사람 몇 명 서있을 만큼 좁다.
답답함을 느끼며 고개를 돌려보니 이제는 벽돌이 아니라 '벽'이라고 느낄 만큼 거대한 돌들이 형태를 구성하고 있다. 그럼에도 불구하고 지금까지와는 비교도 되지 않을 만큼 화려한 무늬가 눈을 즐겁게 해주고 있는데, 그 벽면에는 'UI Test'라고 써있는 것을 보게 된다.

## UI Test
대부분의 어플리케이션들은 UI를 지니고 있다. 여기서 짚고 넘어가야 것은 CLI혹은 REST API도 UI의 일종이라는 것이다. UI Test는 User의 행동에 따라 예상된 데이터를 반환하는지 검증한다. UI Test는 종종 E2E Test와 동일한 것으로 여겨지기도 한다. 그러나 이런 평가는 부분 일치하는 개념을 동일 선상에 놓는 것이다(For me this conflates two things that are rather orthogonal concepts -Ham vocke).

맞다. E2E는 UI를 통해 테스트하는 것을 일컫는 경우가 많다. 그러나 반대의 경우로 생각해보면? 분명히 아니다.
User Interface를 테스트하는 것이 E2E방식으로 진행될 필요는 없다. UI test는 작은 프론트엔드 자바스크립트 unit test처럼 간단할 수도 있다(최소한 서버가 stub되어있긴 해야겠지만).

Web UI test는 Selenium(browser automation solution)과 같은 툴들로 진행할 수 있다. UI가 REST API라면 당신이 제공할 API가 적절히 통합 테스트가 진행된 상태여야 할 것이다. Web UI라면 UI의 정의가 상당히 넓다. behaviour, layout, 디자인에 대한 usability 혹은 adherence등은 일부에 불과하다.

다행히도 behaviour에 관해서라면 꽤나 간단하다. 여기를 클릭하고, 저기에 데이터를 넣으면 이렇게 UI가 바뀌고... 등등이다. 현대의 SPA툴들은 각자 이런 behavioural test를 진행할 수 있는 툴들이 존재하고, 바닐라 자바스크립트를 쓴다고하더라도 jasmine, mocha등과 같은 툴들로 가능하다. 서버사이드 렌더링 페이지라고 하더라도 Selenium과 같은 툴을 쓰면 가능하다.

그렇다면 layout과 같은 것은 어떻게 테스트해야할까? 안타깝게도 behaviour에 비해서 훨씬 어려운 문제다. 컴퓨터는 '좋아 보인다'라는 개념을 모른다. 앞으로 등장할 더 발전된 기술로는 이런 모호한 개념을 테스트하는 것도 가능할지도 모르지만 지금은 아니다. 각설하고, 이런 테스트조차 가능하게 하는 트릭을 살펴보자.

먼저 준비해야할 것은, 디자인 단계에서 혹은 개발하면서 찍어둔 비교군(스크린샷)들이다. 예를 들어, 반응형 웹 페이지를 개발했다면 일정한 크기 비율마다 잘 완성된 상태를 가정한 스크린 샷들을 준비하는 것이고 모바일 어플리케이션이라면 여러 핸드폰 크기에 맞춘 디자인 완성본들을 가지고 있는 것이다. 다음 단계는 Selenium(자꾸 셀레니움의 예를 드는데, 다른 툴이어도 전혀 상관없다)과 같은 툴을 활용해 브라우저 실행 비율을 조정하고, 테스트해야할 페이지의 주소를 지정한 후 스크린샷 캡처를 자동화 시키는 것이다. 마지막 단계는 당신이 미리 준비해둔 스크린 샷들과 스크래핑된 스크린 샷들의 일치여부를 검사하는 것이다. 이런 비교는 사람에 비할바 없이 정교하므로, 조금이라도 다른 부분이 있다면 컴퓨터가 즉각적으로 알려줄 수 있다. 당신이 코드를 수정하거나 완성하는 과정에 어딘가 깨진 부분이 없는지 자동으로 알려줄 수 있는 과정을 방금 만든 것이다.

우리 모두가 느끼고 있다. 너무 불편하다. 그러나 이 정도의 이점이라도 가져가야한다. 이러한 과정을 구축하는 과정이 번거로울 순 있으나 한번 파이프라인이 잘 구축되고 나면 인력소모를 크게 줄여줄 수 있다.
그러나 안타깝게도 이러한 usability(사람이 느껴야하니까) 혹은 '좋아 보인다(단지 레이아웃이 설계와 일치하는지와 별개로)' 요소가 테스트에 포함되기 시작하면 자동화의 의미가 많이 퇴색되긴 한다. 이러한 테스트들은 어쩔 수 없이 exploratory test에 의존하게 된다.

# End-to-End Test
3층 벽을 채운 거대한 벽돌들 중에서도 가장 거대한 벽돌을 마주할 시간이다. '끝에서 끝까지'. 모든 것을 테스트 할 때다. 웹 서비스를 예로 들면 웹드라이버를 사용해 모든 UI를 돌면서 정상적으로 동작하는지를 검사하는 것이 대표적인 E2E테스트이다. E2E를 진행하면 정말 많은 실패요인을 경험하게 된다. 예를 들어 의존중인 특정 서비스가 잠시 병목이 생겨 timeout이 되어 전체 E2E가 실패할 수도 있고, 브라우저가 시스템상 이유로 멈출 수도 있다. 예측하기 힘든 모든 오류의 총 집합체라고 봐도 무방하다. 고도화된 E2E일수록 더하다.

더구나 E2E는 관리 책임자가 너무 불명확하다. MSA가 대두되고 있는 현대의 개발에서는 더욱 그렇다. 각자 서비스를 개발하고 있는 수 많은 팀중에 누가 E2E를 작성하고 관리할 책임이 있는가? E2E는 작성하는데에도, 테스트하는 데에도, 유지보수하기도 많은 시간과 노력이 들어간다. 

또 하나의 심각한 문제는 E2E는 로컬 테스트가 사실상 힘들다는 것이다. 연결된 모든 서비스를 로컬환경에서 구동시키는 것도 중노동일 뿐더러(의존하고 있는 서비스 중 1개가 테스트 중에 스펙이 바뀌었다면?) 서비스가 거대하다면 여러 의존성 실행을 시도하는 것만으로도 컴퓨터가 과부하에 뻗을지 모른다. 컴퓨터가 힘들어 하는 것만 문제인가? E2E는 실행하는데에도 꽤 긴 시간이 필요하다. 모든 느린 과정(예를 들어, external api calls)을 감당할 뿐 아니라 단계 자체가 매우 길고, 예상치 못한 에러가 발생하면 그 마저도 다시 실행해야한다. 그리고 앞서 살펴본 문제도 발생한다. 우리의 선한 의도와는 다르게 우리에게 서비스를 제공하는 개발자들은 프로덕션 서버에 로그가 마구 찍히는 걸 보면서 접근을 차단하거나 서버 비용을 청구하고 싶을 것이다.

우리는 하나의 결론을 도출할 수 있다. '여러 개(번)의 E2E는 생산성의 저하로 이어진다. 남들도 싫어한다'
그리고 우리는 E2E를 최대한 적게 작성하기 위해서 unit test와 integration test에서 edge case들을 검사했고 기능이 우리의 기대와 일치함을 검증했다. 그러면 E2E에서는 무엇을 테스트해야하는가? 'core value'이다. 핵심 User experience를 테스트하는 것이 E2E의 목적이다. user journey라고도 표현하는데, 유저가 서비스를 이용하는 시나리오를 가정해 유저 경험을 올바르게 전달하고 있는지를 테스트하는 것이다. 게시판에 5억 글자 게시물을 넣으려고 시도하는 트롤을 가정하는 것이 아니라는 것이다. 다시 말하지만 edge case들은 하위 테스트들에서 이미 검증이 '되었어야' 하고 이 같은 케이스를 높은 단계에서 시도하는 것은 현명하지 못한 일이다.

# Acceptance Test
**BDD에 대한 이해가 부족해 적기가 망설여 집니다. 단순히 직역해서 옮기고 싶지는 않습니다. 추후에 이해도가 높아지면 적도록 하겠습니다**

# Exploratory Test
아무리 테스트 자동화에 심혈을 기울였다고 해도 '자동화'라는 것이 100퍼센트 우리의 문제를 해결해줄 것이라는 착각을 가져서는 안된다. 요구사항은 항상 바뀌기 때문에 테스트가 요구사항을 잘 반영하지 못하기도하고, 테스트로는 캐치할 수 없는 케이스나 버그가 있을지도 모르고(가장 많은 경우) 개발자가 잘 못 된 테스트를 작성하는 경우 때문에 작동성이 제대로 검증되지 못할 수도 있다. 게다가 '사용성'이라는 정량화 되기 힘든 지표들로 넘어가면 테스트 자동화가 사실상 불가능하다.

그렇기 때문에 Exploratory test가 필요하다. 대단한 의미가 있는 것은 아니다. '직접 해본다'가 핵심이다. 왜 중요하냐면, 사람은 기계가 가질 수 없는 '창의성'을 가지고 있기 때문이다. 창의적으로 애플리케이션 내적이던 외적인 경우들을 마음껏 가지고 놀며 테스트할 수 있다는 의미이기 때문이다. 

또 한 이전 단계의 테스트들이 적절하게 작성되었다면 사실 이 단계에서 발견되는 오점은 적게 유지되고, Exploratory test에서만 발견할 수 있는 오점들은 기쁘게 받아 들일 수 있다. 어플리케이션의 성숙도에 가장 크게 기여하는 것이 이때 발견되는 부분들이기 때문이다.

# 테스트 용어에 대한 혼란
테스트 분류는 언제나 어렵다. unit test, integration test등을 조금씩 다르게 이해하는 경향이 있다. 예를 들어 integration test를 항상 narrow하지 않게 동시에 모두 테스트하는 사람도 있고, broad한 개념으로만 생각하는 사람도 있다. 용어도 마찬가지로 혼란을 주는데, integration, service, component는 테스트 용어로 쓰일 때 모두 비슷한 단계를 가리킨다. 더 최악인건 세개가 모두 전혀 다른 뜻이라고 주장하는 사람도 있다는 것이다. 무엇도 맞고 틀리지 않다(개인의견 아닙니다. ham vocke의 의견입니다. 그런데 동의는 합니다). 용어가 애초에 너무 난잡하게 사용되기 때문이다.

이런 애매모호한 용어에 집중할 필요가 없다는 사실을 기억하자. 개발자들끼리도 다를 수 있고, 회사끼리 다를 수도 있다. 동료들과 도출해낸 정의에 입각해 사용하면 그뿐이다. 

# 테스트를 배포 파이프라인에 포함시키기
CI/CD 시스템이 구축되어 있다면 배포 파이프라인에 테스트를 포함시키는 것이 좋다. 보통 배포 파이프라인은 여러 단계로 이루어지는데, 테스트를 어느 단계에 포함시킬지 고민된다면 CD의 foundational value를 떠올려보면 된다. 바로 'Fast Feedback'이다.

좋은 파이프라인은 무언가 잘 못 되었음을 최대한 빠르게 알려준다. 어디에 놓으라는 정답이 있다기보다는 기준을 가지는 것이 좋다. 가장 빠른 피드백을 줄 수 있는 존재는? 논쟁의 여지없이 unit test이다. integration test라도 빠르게 실행되는 테스트가 있고 느리게 실행되는 테스트가 있다. 빠른 테스트가 앞서야한다. E2E건 UI건 모두 마찬가지다. unit test로 검증했어야할 문제가 E2E단계에서 검증되어 1시간 뒤에 피드백에 도착한다면 심각한 문제다.

# 중복된 테스트 피하기(너무 많은 테스트란 없다고 하는 사람들에게: "있다")
이 부분도 신중하게 고려되어야 한다. 테스트 피라미드는 계층적이기 때문에 중복된 테스트가 작성될 가능성이 높다. 테스트가 중복되면 무슨 문제가 생길까? 일단 의미 없이 computational power와 task time이 소모된다. 더 큰 문제는 당신이 혼자 개발하는 것이 아니라는데에서 생기는 문제인데, 동료들이 테스트를 읽느라 시간을 지나치게 소모하게 된다는 것이다. 테스트도 코드이고, 이해해야 한다. 이해했더라도 읽어야하고, 기능이 변경되면 그 많은 중복 코드들을 고치느라 시간이 또 허비된다. 필요한 갯수만큼의 테스트로 작동성을 검증할 수 있어야한다.

두 가치 규칙을 명심하면 좋다.

1. 고수준 테스트가 실패하는데 저수준 테스트가 실패하지 않으면 잘 못된 테스트를 작성한 것이다(저수준에서 검증해야 한다).
2. 테스트를 작성해야 한다면 최대한 저수준에서 작성하라(아래가 넓고 위가 좁은 피라미드를 명심하자)

실패는 저수준에 발생할 수록 좋은데, 구체적으로 특정되기 때문이다. 문제 파악도 수정도 훨씬 적게 걸릴 것이다. 2번은 더 중요한데, 저수준에 제대로 된 테스트들이 작성되어있으면 고수준에서 중복을 피할 수 있고, 자주 반복되는 테스트의 실행시간을 줄여줄 것이고 결과적으로 전체적인 능률을 올려줄 것이다.

내용이 마치 고수준 테스트를 기피하는 것처럼 보이는데, 오해해선 안된다. '최소화'가 목적이다. '고수준은 저수준에서 테스트가 불가능한 내용들을 테스트한다'는 것을 기억하자. 저수준 테스트에만 의존하다가 고수준 테스트가 제공해주는 이점을 놓치는 것도 주의해야한다.

고수준 테스트가 제공하는 확신을 저수준이 동일하게 제공할 수 있다면 대체 되어야한다. 물론 매우 신중하게 진행되어야 한다. 

# Clean Test Code
마지막 단계다. 테스트 코드를 작성하기 전에 유지보수가 용이한 테스트 코드 작성 규칙을 명심하자.
1. 테스트 코드는 프로덕션 코드만큼 중요하다. 동일한 관심도로 관리해주자. '이건 테스트 코드일뿐이잖아'라는 말은 구린 코드의 변명이 되어주지 못한다.
2. 테스트 당 하나의 조건만을 가진다. 테스트를 짧게 유지해야 원인 파악이 쉽다.
3. 'arrange, act, assert' 혹은 'given, when then'을 기억하자. 테스트가 일관된 구성을 유지할 수 있도록 도와준다.
4. 가독성은 중요하다. 너무 'DRY'할 것을 걱정할 필요는 없다. 심지어 가독성을 위해서는 중복된 코드도 허용된다. 'DRY'와 'DAMP'사이에서 균형을 찾자.
5. 리팩터링 시기를 정하는데에 'Rule of three'를 고려하는 것에 의문이 든다면: 'Use before reuse'  
#### The Rule of Three(https://blog.codinghorror.com/rule-of-three/)
reusable component를 개발하는게 single use component를 개발하는 것보다 세배는 힘들다는 말에는 나온 규칙

#### Use Before Reuse(https://wiki.c2.com/?UseBeforeReuse)
reusable artifact를 개발하기 전에 이미 개발된 artifact의 기능성을 충분히 활용하고 있는지 재고하라는 소프트웨어 개발 격언
# 결론
길고도 긴 내용이었다. 그렇지만 그럴 가치가 있다. 이런 테스트 관련 지식들은 시대와 종류에 상관없이 필요하다. 어느 분야건 테스트의 베이스 지식들은 항상 활용된다.

**최대한 재밌게 번역하려고 노력하며 제 짧은 지식도 맞춰 넣느라 몇일 걸렸습니다만, 왠지 평생 쓸 중요지식을 습득한 것 같네요. 우연히라도 이 모자란 글을 읽는 분들이 같은 느낌을 가졌으면 좋겠습니다.**




















