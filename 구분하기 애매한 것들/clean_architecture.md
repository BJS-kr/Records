## 클린 아키텍처는 왜 등장했나

기존의 계층형 구조에서는 자연스럽게 데이터베이스 중심 구현이 이루어진다. 의존성의 방향이 데이터베이스를 향하고 있기 때문이다. 그러므로 도메인 로직의 구현은 후순위로 밀리게 된다. 

문제는, 어떤 어플리케이션의 **상태**를 바꾸는 주체는 **행동**이기 때문에 행동 중심 구현이 되어야 하는데 반대로 상태를 중심으로 설계하고 있다는 점이다. 또한 도메인 로직이 먼저 구현되어야 구현한 도메인 로직이 올바른지를 확인할 수 있는데 영속성 계층부터 설계하게 되면 이 또한 가장 뒤로 밀려나게 된다.

특히 ORM코드가 도메인에 결합될 경우(가장 흔한 경우: 영속성 계층의 ORM entity가 도메인 로직에서 사용됨) 도메인 계층과 영속성 계층의 강한 결합이 생긴다. 계층형에서 의존성 최상단은 영속성 계층이므로 도메인 계층은 영속성 계층에 접근할 수 있고, 영속성 모델을 비즈니스 모델로 그대로 사용하게 되는 것이다.

계층형 구조의 유일한 규칙은 어떤 계층의 코드는 자신의 계층과 바로 하위의 계층의 코드에 접근할 수 있다는 것이다. 이 규칙은 **개발자**가 **나쁜 행동**을 하기 쉽게 만든다. 어떤 어플리케이션을 구현 중에 작성중인 계층의 코드에 상위 계층의 코드가 필요하게 되었다면 어떻게 될까? **상위 계층의 역할을 자신의 계층 또는 하위 계층으로 이식**해버리면 된다. 물론 개발자들은 이런 행동이 잘못되었다는 것을 알고 있지만 구현 편의를 위해, 혹은 기한을 맞추기 위해 이런 시도들은 일어나며, 한번 그렇게 구현한 후에는 이런 시도들은 더욱 많이 일어나기 마련이다. 또 한, 단순한 쿼리 같은 것들은 웹 계층(컨트롤러)에서 영속성 모델을 즉시 사용해 반환하고 싶어지고 이런 시도가 단 한번만 일어날리는 없다. 

결과적으로 도메인 로직이 계층과 상관없이 코드 전체에 퍼져버린다. 이 경우 컨트롤러를 테스트하기 위해 영속성 계층을 mock해야하는 일이 벌어진다. 게다가 종속성이 뒤죽박죽이므로 결과적으로 모든 계층을 mock하게 되고 각 엔드포인트마다 어떤 종속성을 가지는지 파악하느라 테스트 코드 작성에 지나치게 많은 시간을 소모하게 된다. 

기능을 추가하거나 변경하는 일이 빈번해서, 요청 받은 수정을 코드의 어느 부분에서 실행하는 것이 적절할지 탐색하는 것은 매일 같이 경험하는 일이다. 그런데 코드가 이렇게 뒤죽박죽이라면? 앞서 살펴본 문제들은 변경을 극히 어렵게 만든다. 모든 계층이 어떻게 결합되어있는지 확신할 수 없고, 그마저도 모두 다르기 때문이다.

팀 단위작업에서도 도움이 되지 않는데, 동시 작업을 어렵게 만들기 때문이다. 모든 계층이 하위 계층에 의존적이므로 하위 계층부터 작업할 수 밖에 없다. 여러 개발자들이 하나의 기능을 위해 동시에 여러 계층을 작업할 수 없다는 것이다. 물론 인터페이스를 미리 설계한 후 그 인터페이스에 맞춰 각 계층을 설계할 수 있지만 그것만으로 이미 데이터베이스 주도 설계가 아니며 계층형 아키텍처 구현에서 데이터베이스 주도 설계가 아닌 경우는 잘 일어나지 않는다. 

어떤 계층의 비대화도 자주 일어난다. 그것을 금지하는 규칙이 없기 때문이다. 예를 들어, 어떤 서비스가 10개의 유스케이스를 포함하고 있다고 가정하자. 개발자들은 각자 다른 유스케이스를 수정하더라도 매우 피로하게 느껴질 것이다. 작업한 버전마다 conflict가 필연적으로 일어나기 때문이다. 예를 들어 네 명이 수정한 버전을 병합할 때마다 모여 conflict를 해결하는 것이다.

물론 아주 엄격하게 코드를 통제하게 되면 이런 일은 일어나지 않는다. 그러나 이러한 통제는 느슨해지기 마련이며 통제조차도 비용이다.

지금까지 살펴본 문제들은 모든 계층에 걸쳐서 일어나며 이를 방지하기 위해 강제되는 구조가 필요하다.

## 개선에 필요한 개념

1. SRP
    
    SRP는 종종 하나의 일만하는 객체 등으로 해석되기도 하지만 본래의 의도는 변경할 이유가 하나 뿐인 객체를 말한다. 예를 들어, A객체는 B,C,D,E등 모든 객체에 의존하고 있고 E는 어떤 객체에도 의존하지 않고 있다고 가정하자. 
    
    E객체를 변경해야하는 이유는 명확하다. 바로 E객체의 기능에 변경이 필요할 때이다. 다른 이유가 존재할 수 없으므로 E객체는 SRP를 만족하고 있다.
    
    그러나 A객체는 B,C,D,E가 바뀔 때 마다 항상 변경되어야한다. 변경될 이유가 여러가지 이므로 SRP를 위반하고 있다. 
    
2. DIP
    
    SRP에서 살펴본 것 처럼 의존하는 것이 많을 수록 의존중인 구현은 변경되어야 할 이유가 많다. 그렇다면 계층형 아키텍처의 문제점도 곧바로 드러난다. 아키텍처의 규칙상 상위 모듈일 수록 의존하는 모듈이 많아진다. 변경되어야하는 이유가 많고 구현이 늘어날 수록 변경은 필연적으로 더 어려워진다.
    
    계층형 구조의 최하위 모듈은 영속성 계층이므로, 영속성 계층이 변경될 때마다 도메인 로직도 변경될 것이 분명하다. DIP는 이 구조를 근본적으로 변경한다. DIP에서 주장하는 바는, 고수준 모듈이 저수준 모듈에 의존(계층)하지 않고 둘 다 추상모듈에 의존하는 것을 말한다.
    
    역전이라는 말은 계층형 구조에서 상위 구체 모듈이 하위 구체 모듈과의 관계가 끊어지며 모든 구체 모듈이 추상모듈의 상위 모듈로 변경됨을 이른다.
    
    ![https://miro.medium.com/max/1400/1*vUtSx8-gdvIreENjRcvt7w.png](https://miro.medium.com/max/1400/1*vUtSx8-gdvIreENjRcvt7w.png)
    
    이를 이용해 클린 아키텍처가 구현된다.
    

## 클린 아키텍처의 구조

![https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg](https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg)

Use Cases가 뭉뚱그려져 있지만 SRP를 위반하지 않기 위해 더 세분화된 모듈 혹은 객체로 나뉘어져있다고 보는 편이 옳다. 의존성은 항상 내부를 향한다. 그러므로 내부 모듈은 외부 모듈을 **절대 알 수 없다**. 그러므로 도메인 로직에 영속성 계층 등 구체 구현이 끼어들 자리가 아예 없다. 

이러한 구조에는 단점이 있는데 데이터가 각 계층의 경계를 넘을 때 마다 매핑되어야 할 수도 있다는 것이다. 이는 코드의 증가를 뜻한다. 도메인 모델은 영속성 계층 모델을 알 수 없기 때문에 모델은 각 계층에서 따로 구현되어야하며, 계층의 경계를 넘을 때는 알맞은 모델로 매핑되어야 한다.

피로감이 느껴질 수 있지만, 사실 이로 인해 계층의 분리를 확실하게 보장하여 독립적인 변경이 항상 가능하도록 만든다.

## 구체적인 구현 전략: Hexagonal Architecture

![https://reflectoring.io/images/posts/spring-hexagonal/hexagonal-architecture_hu6764515d7030d45af6f7f498c79e292b_50897_956x0_resize_box_3.png](https://reflectoring.io/images/posts/spring-hexagonal/hexagonal-architecture_hu6764515d7030d45af6f7f498c79e292b_50897_956x0_resize_box_3.png)

로버트 마틴의 클린 아키텍처라는 추상적인 설명을 구체화 시킨 아키텍처 중 육각형 아키텍처를 살펴보자. 육각형이라는 말 자체는 별 의미가 없으며 단지 여러 어댑터와 연결되는 면을 나타내기 차용된 단어일 뿐이다. 위 그림에서 육각형에 위치한 부분(Use Case + Entity)가 application core이다. 앞으로 진행되는 설명에서 도메인 계층이라고 하는 것은 바로 application core와 같다고 생각하면 된다.

도메인 엔티티 혹은 도메인 모델은 위 그림에서 Entity의 위치이다. ORM사용자는 DB를 위한 Enity를 작성해본 경험이 있을 텐데 영속성 계층의 Entity와 도메인 계층의 Entity는 명칭이 같을 뿐 별개의 존재다. 이 둘을 혼용하여 사용할 때 생기는 문제점을 이미 상단에서 살펴보았다.

도메인 엔티티는 어플리케이션의 핵심을 표현하는 객체이다. 만약 결제 서비스라면 주문을 표현하는 객체가 될 것이다. 그 객체는 단지 상태를 담는 것 뿐만 아니라 비즈니스 규칙을 검증하는 등 최대한 많은 도메인 로직을 포함할 수도 있다. 주문 객체라면 상태를 변경하는 메서드 혹은 결제 금액과 환불 요청 금액을 비교해 환불 가능 여부를 반환하는 메서드가 존재할 수 있다. 이렇듯 풍부한 내부 프로퍼티를 지니는 객체를 풍부한(rich) 도메인 모델이라고 부르고 반대로 최소한의 구현을 가지는 엔티티를 빈약한(anemic) 도메인 모델이라고 한다. 둘 중에 무엇이 옳다고는 표현하기 힘들다. 빈약한 도메인 모델이라도 도메인 모델에 관련된 메서드들은 애플리케이션 코어에 위치해야 하기 때문이다. 

다음으로 육각형 아키텍처의 큰 특징인 포트와 어댑터를 살펴보자.

위에서 살펴본 DIP를 생각해 보았을 때, port는 구체 모듈들이 의존해야하는 추상모듈이다. 일반적으로 interface로 표현되며 도메인은 포트를 통해 어댑터와 소통할 수 있다. 

어댑터와 포트 전략의 핵심은 어댑터가 포트 인터페이스를 통해 구현되므로 어댑터를 자유롭게 갈아끼울 수 있다는 것이다. 가장 가까운 예로 input port interface(use case)를 임포트하여 구현되는 웹 어댑터(controller)가 있다. 

그림을 자세히 보면, 좌측에 위치한 어댑터 두개가 도메인으로 연결되는 화살표는 촉이 까맣게 채워져있고 우측의 어댑터의 촉은 하얀 것을 볼 수 있는데, incoming adapter인지 outgoing adapter인지를 표현한 것이다. port의 이름도 input port와 output port로 나뉘어져 있는 것을 볼 수 있다. 단어 그대로 해석할 수 있는데, incoming web adapter는 외부에서 서버로 들어오는 요청을 받는 것을 표현한 것이다. output port는 도메인이 호출하는 포트로 대표적으로 영속성(DB) 계층이 있다.

위의 구조로 달성할 수 있는 핵심은 모든 계층의 모든 모듈의 변경할 이유를 자신에 대한 변경 외에는 없게 만드는 것이다.

## 입력 유효성 검증

입력 유효성 검증은 use case의 책임이라고 보기는 어렵다. use case의 책임은 도메인 로직이지 로직 이전에 값이 올바른지 검사하는 것은 use case코드를 오염시키는 것이다. 그러나 여전히 입력 유효성은 올바른 동작을 위해 중요하며 애플리케이션 계층의 책임이다. 이 경우 사용할 수 있는 것이 입력 모델이다. 입력 모델은 입력 값을 받아 내부에 매핑하는 역할을 한다. 이 경우 usecase의 파라미터 타입은 입력 모델이 된다. 입력 모델은 값을 검증하고 올바르지 않을 경우 진행을 중지시키므로 usecase는 안심하고 입력 모델을 사용할 수 있다.

### 각각의 포트(인터페이스)를 모두 각각의 클래스로 구현해야하나요?

아니다. 인터페이스는 합쳐서 구현할 수 있다. 어댑터의 타입은 포트의 서브타입이므로 각 포트에 구현체를 주입하면 된다.

## 테스트 전략

먼저 중요한 대전제가 있다. 보통 유닛테스트는 엣지 케이스까지 검증하고 통합 테스트는 통합을 테스트하기 위해 일부 로직만 검증한다고 알려져있지만, 정확히는 이러한 기준들보다는 **필요한 만큼 하는 것** 만이 정답이다.

통합테스트라고 해서 테스트 갯수가 두개를 넘어가면 큰일나는 것이 아니라는 것이다. 

아래의 테스트 전략은 단순히 가이드이자 권장사항이며 모든 의존성을 생성자로 받는 구현특성상 어댑터라고 해도 충분히 유닛테스트할 수 있다.

[테스트 피라미드](https://martinfowler.com/articles/practical-test-pyramid.html)의 전형적인 형태를 떠올려보았을 때, 유닛 테스트와 통합 테스트, 그리고 e2e테스트는 각각 어떻게 육각형 아키텍처에 적용될 수 있을까? 

도메인 엔티티는 완전히 독립적이므로 그 자체로 유닛 테스트 할 수 있다. 

유스케이스도 마찬가지로 유닛 테스트할 수 있다. 애초에 usecase는 자신보다 바깥에 위치한 모듈에 관심자체가 없다. 즉, 실제 어댑터를 호출하는 것과 mock 어댑터를 호출하는 것이 차이가 없다. 차이가 생긴다면 도메인 로직이 잘 못된 것이다. 그러므로 외부 모듈을 mock해 unit test하는 것이 가성비가 좋다.

어댑터는 통합테스트가 우선적이다. 어댑터가 올바르게 도메인과 소통할 수 있는지 검증하는 것이다.

마지막으로, 사용자의 입장에서 가능한 중요 시나리오들을 e2e로 커버한다. 정리하면 다음과 같다.

도메인(Entity, Use Case): 유닛 테스트

어댑터: 통합 테스트

중요 시나리오:  e2e테스트

## 매핑

매핑은 계층간 문지기라고 생각하면 좋다.

매핑에도 대전제가 있는데, 전략에 정답은 없다는 것이다. 매핑 전략은 상황에 따라 다르므로 그때 그때 최선의 방법을 선택해야한다. 

먼저 매핑전략을 선택할 때 가장 흔한 주장들 부터 살펴보겠다.

1. **매핑합시다!** : 계층간 매핑하지 않으면 두 계층이 같은 모델을 사용한다는 말인데, 이렇게 되면 계층간 결합이 강해집니다.
2. **매핑하지 맙시다!** : 보일러플레이트를 너무 많이 만들게 되고, 대부분의 유스케이스는 crud에 불과하고 계층에 걸쳐 같은 모델(이라기보다는 같은 구성)을 사용하기때문에 계층간 매핑은 너무 과합니다.

그렇다면 전략을 나누어 살펴보자

1. 매핑하지 않기: 무조건 매핑을 해야만 clean architecture가 완성되는 것은 아니다. 예를 들어, 모든 계층이 완벽하게 같은 모델을 사용한다면 매핑하지 않기 전략은 완벽한 전략이다. 혹자는 프로그램 변경 가능성을 들어 반박할 수 있다. 합당한 주장이지만 기억해야 할 것은 매핑 전략은 언제든지 수정가능하다는 것이다. 매핑하지 않기는 구현은 편하지만 계층간에 관심이 생겨 SRP를 위반할 위험을 내재하고 있다.
2. 양방향 매핑: 양방향 매핑에서는 어댑터가 포트에 필요한 모델로 데이터를 매핑할 책임을 가진다. 마찬가지로 포트가 반환한 모델을 다시 어댑터에 맞는 모델로 변환할 책임도 가진다. 이렇듯 주고 받는 과정에서 모두 매핑이 일어나기 때문에 양방향 매핑이라는 말을 쓴다. 이 전략에서는 각 계층들이 관심사로 오염되지 않아SRP를 위반할 위험이 없다. 
    
    양방향 매핑도 정답은 아니다. 코드 오염의 위험성은 줄여주지만 보일러플레이트 코드가 많이 생기게 되고 디버깅할 범위도 늘어난다. 단순한 CRUD에서까지 양방향 매핑을 할 필요는 없다. 어떤 것도 철칙으로 여겨선 안된다.
    
3. 완전 매핑: 양방향 매핑과의 차이는 입력에 있어 어댑터가 도메인 모델을 사용하는 것이 아니라 별도의 입력 모델을 사용하는 것이다. 물론 그 입력모델을 인스턴스화 시키는 것은 어댑터의 책임이다. 도메인은 도메인 모델 대신 입력 모델을 입력값으로 취한다. 
    
    양방향 매핑과 유사하게 느껴지지만 차이는 입력모델 덕에 어댑터는 값을 전혀 해석할 필요가 없다는 점이 차이이다. 그저 어댑터에서 사용하는 모델을 입력모델에 넘기기만 하면 된다. 이 덕에 책임 경계가 더욱 명확해지고 유효성 검증 책임을 분리해낼 수 있다.
    
    당연하게도 이러한 구현은 더욱 더 많은 코드가 필요하다. 전역으로 완전 매핑전략을 사용하는 것은 추천되지 않고, 보통 웹 어댑터에서 도메인으로 데이터를 넘길 때 유효성 검증 및 깨끗한 코드를 만들기 좋아 자주 사용된다.
    
4. 단방향: 쓰는 사람이 이해가 잘 안되서 보류

다시 강조하지만, 어떠한 매핑 전략도 철칙이 되어선 안된다. 섞어도 되고, 변경해도 된다. 유연하게 적용하는 것만이 정답이다.

다만, 통용되는 가이드 정도는 있다.

- 웹 어댑터와 유스케이스 간은 완전 매핑 전략을 우선으로 고려한다.
- 유스케이스와 영속성 계층 간은 양방향 매핑전략을 우선으로 고려한다.
- 쿼리 유스케이스(단순 쿼리를 유스케이스라고 부를 수 있다면)에서는 매핑하지 않기 전략을 우선으로 고려한다.

## 인스턴스를 생성할 책임

인스턴스를 누가 생성하던 그게 왜 중요할까? 계층의 관심사가 명확하게 분리되기 때문이다. 예를 들어, 유스 케이스는 영속성 계층에 대한 포트를 가지고 있지만 그것이 영속성 계층 클래스를 인스턴스로 만들겠다는 것은 아니다. 정확히는 영속성 계층 클래스의 존재 자체도 몰라야한다. 그렇기 때문에 생성책임이 중요해진다.

이러한 체계는 테스트 할 때도 빛을 발하는데, 어떤 객체가 필요로 하는 객체가 모두 생성자의 인자로 전달되기 때문에 격리된 테스트를 생성하기에 용이하다.

생성 책임을 가지는, 가장 의존적인 생성 책임자를 하나 추가하는 것이 일반적인 선택이다(그 책임자는 프레임워크(nest, spring)인 경우가 많다). 물론 직접 구현해도 문제 없다. 단지 그 책임자는 모든 모듈에 관심이 있을 뿐이다. 

 

## 개발에서의 깨진 유리창 이론

- 품질이 떨어진 코드에서 작업할 때 더 낮은 품질의 코드를 추가하기는 쉽다.
- 코딩 규칙을 이미 어긴 코드에서 작업할 때 나도 어기기 쉽다.

가능한 지름길을 쓰지 않고 장기적인 품질 유지 노력을 끝 없이 이어나가는 것이 왜 중요한지 위의 두 문장에서 나타나있다. 한 번 어기기는 어려워도 다시 어기기는 쉽고, 이러한 품질 저하는 규모가 커질수록 더 가속화된다.

그럼에도 불구하고 지름길은 사용된다. 단지 개발자들이 부주의해서가 아니라, 그것이 경제적이라고 여겨질 때 그렇다. 다만 지름길을 사용하고자 한다면, 언제, 코드의 어디에서, 왜 그렇게 사용했는지를 명확히 기록할 필요가 있다. 그 의미를 이해하지 못하고 코드를 망치는 일이 벌어지지 않도록 말이다. 

흔히 사용되는 지름길에는 다음과 같은 종류들이 있다.

- 유스케이스간 모델 공유하기
- 도메인 엔티티를 입출력 모델로 사용하기
- 인커밍 포트 건너뛰기
- 애플리케이션 서비스 건너뛰기(바로 영속성 계층에 접근해서 데이터 받기)

이러한 사항들은 기록이 남겨져 있어야 자신 혹은 유지보수자가 이 결정의 합리성에 대해 재고하고 결정권한을 가질 수 있다.