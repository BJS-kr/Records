1. 부수효과가 없는 함수를 사용한다
2. 액션 계산 데이터를 구분한다.
3. 액션에서 계산을 분리해낸다. 액션은 최대한 격리한다. 테스트가 쉬워진다. 예를 들어 이메일 목록 전체를 만들고 실행한다.
4. 미리 최적화 할 필요없다. 예를 들어 이메일을 수백만개 만들어야한다면 끊어서 실행하면 된다.
5. 전역변수에 의존하지 않는다. 전역변수는 변경가능하기 때문에 그 자체로 액션이다. 또한 함수 자체가 격리될 수 없게 만든다.
암묵적 입출력은 코드를 액션으로 만든다. 입력은 인자뿐이어야한다. 암묵적 출력도 없어야한다. 무조건 리턴값으로 표현해야한다.
7. 특정 컨텍스트에 의존시키지 않는다(ex: DOM).
8. 입력받은 인자가 배열일때 그 배열에 push하고 리턴하는 것은 액션이다. 참조형 데이터이기 때문에 푸쉬하면 함수 바깥에 있던 원래 배열이 변경된다.
9. 함수를 작은 함수들로 나눈다. 재사용하기 쉬워진다. 유지보수하기 좋아진다. 테스트하기 좋아진다.
10. 일반적인 이름으로 인자를 바꾼다. 유틸리티성을 띄게 만든다. 이런 함수는 재사용할 수 있다. 예를 들어, 추가적인 동작없이 유틸리티성 함수의 결과를 리턴하는 비즈니스적인 함수를 즉시 만들 수 있다.

**2주차**
11. 변경가능한 데이터를 읽는 것은 액션이다. 계산으로 만들기 위해 데이터를 불변형으로 만든다. js는 수동으로 이를 구현해야한다. 중첩 객체도 변경되지 않아야 불변이라고 할 수 있다. 이 경우, 중첩된 객체를 얕은 복사로 충분하다. 변경이 필요할 때에는 그 중첩된 객체를 복사할 것이므로 안전하다. 이를 구조적 공유라고 한다. 이는 다른 함수형 언어에서도 사용하는 방식이다.모든 것을 불변형으로 만드는 것이 성능에 영향을 미칠 가능성은 높지 않다.

12. 쓰기와 읽기를 동시하는 경우 각각의 함수를 구현하거나 읽기 쓰기 값 반환값을 하나의 객체에 담아 반환한다.

13. 방어적 복사는 신뢰할 수 없는 코드와 함수형 코드가 대화하기 위해 쓰는 방법이다. 위험지대의 데이터가 언제 어떻게 변경될 지 알 수 없으므로 사용하기 위해선 깊은 복사한다. 깊은 복사된 데이터가 안전지대에서 움직일 때는 앞서 살펴본 얕은 복사 및 구조 공유를 사용해도 된다. 안전지대에서 다시 위험지대로 넘어갈 때는 다시 깊은 복사한다.

14. 함수를 작성할 때, 함수가 위치하는 계층을 고려하며 설계하면 구조적인 코드를 작성할 수 있다. 이런 계층형 설계는 이해하기 쉽고 재사용가능하기 좋은 코드를 작성하기 위함이다. 저수준의 함수일 수록 일반적이므로 재사용 및 조합하기 좋고 고수준일수록 조합되어있으므로 특정기능에 적합해진다. 예를 들어, 최상위 수준에 장바구니 세금 계산 함수가 위치하면 최하위 수준에는 언어 자체의 기능(for, index)등이 존재한다.

