1. 부수효과가 없는 함수를 사용한다
2. 액션 계산 데이터를 구분한다.
3. 액션에서 계산을 분리해낸다. 액션은 최대한 격리한다. 테스트가 쉬워진다. 예를 들어 이메일 목록 전체를 만들고 실행한다.
4. 미리 최적화 할 필요없다. 예를 들어 이메일을 수백만개 만들어야한다면 끊어서 실행하면 된다.
5. 전역변수에 의존하지 않는다. 전역변수는 변경가능하기 때문에 그 자체로 액션이다. 또한 함수 자체가 격리될 수 없게 만든다.
암묵적 입출력은 코드를 액션으로 만든다. 입력은 인자뿐이어야한다. 암묵적 출력도 없어야한다. 무조건 리턴값으로 표현해야한다.
7. 특정 컨텍스트에 의존시키지 않는다(ex: DOM).
8. 입력받은 인자가 배열일때 그 배열에 push하고 리턴하는 것은 액션이다. 참조형 데이터이기 때문에 푸쉬하면 함수 바깥에 있던 원래 배열이 변경된다.
9. 함수를 작은 함수들로 나눈다. 재사용하기 쉬워진다. 유지보수하기 좋아진다. 테스트하기 좋아진다.
10. 일반적인 이름으로 인자를 바꾼다. 유틸리티성을 띄게 만든다. 이런 함수는 재사용할 수 있다. 예를 들어, 추가적인 동작없이 유틸리티성 함수의 결과를 리턴하는 비즈니스적인 함수를 즉시 만들 수 있다.

**2주차**  
11. 변경가능한 데이터를 읽는 것은 액션이다. 계산으로 만들기 위해 데이터를 불변형으로 만든다. js는 수동으로 이를 구현해야한다. 중첩 객체도 변경되지 않아야 불변이라고 할 수 있다. 이 경우, 중첩된 객체를 얕은 복사로 충분하다. 변경이 필요할 때에는 그 중첩된 객체를 복사할 것이므로 안전하다. 이를 구조적 공유라고 한다. 이는 다른 함수형 언어에서도 사용하는 방식이다.모든 것을 불변형으로 만드는 것이 성능에 영향을 미칠 가능성은 높지 않다.

12. 쓰기와 읽기를 동시하는 경우 각각의 함수를 구현하거나 읽기 쓰기 값 반환값을 하나의 객체에 담아 반환한다.

13. 방어적 복사는 신뢰할 수 없는 코드와 함수형 코드가 대화하기 위해 쓰는 방법이다. 위험지대의 데이터가 언제 어떻게 변경될 지 알 수 없으므로 사용하기 위해선 깊은 복사한다. 깊은 복사된 데이터가 안전지대에서 움직일 때는 앞서 살펴본 얕은 복사 및 구조 공유를 사용해도 된다. 안전지대에서 다시 위험지대로 넘어갈 때는 다시 깊은 복사한다.

14. 함수를 작성할 때, 함수가 위치하는 계층을 고려하며 설계하면 구조적인 코드를 작성할 수 있다. 이런 계층형 설계는 이해하기 쉽고 재사용가능하기 좋은 코드를 작성하기 위함이다. 저수준의 함수일 수록 일반적이므로 재사용 및 조합하기 좋고 고수준일수록 조합되어있으므로 특정기능에 적합해진다. 예를 들어, 최상위 수준에 장바구니 세금 계산 함수가 위치하면 최하위 수준에는 언어 자체의 기능(for, index)등이 존재한다.

**3주차** 
15. 너무 구체적인 계층도 코드 스멜이다.

16. 작은 인터페이스를 유지하려고 노력하는 것이 일반적으로 좋은 확률이 높다(있는 함수가지고 조합해서 사용하기)

17. 계산함수에 액션함수를 추가하는 것을 경계하기. 예를 들어, 장바구니에 아이템 추가는 계산인데 아이템 추가를 기록하는 액션 함수를 아이템 추가 함수에 넣지 않을 것이다.

18. 무엇보다 중요한 것은 계층은 정답이 아니며, 지금 편하다면 굳이 패턴을 적용할 필요까지는 없다는 것이다. 코드 스멜 때문에 작업에 지장이 생길정도라면 패턴 적용을 적극적으로 고려해보자. 비즈니스는 기다려주지 않는다.

19. 코드는 기능적 요구사항과 비기능적 요구사항이 있다. 기능적 요구사항이란 비즈니스적으로 충족해야하는 사항. 비기능적 요구사항은 유지보수성, 테스트성, 재사용성이다. 저수준 함수일수록 고치기 어렵다. 고수준 함수들이 이미 의존하고 있기 때문이다. 테스트를 제한되게 작성해야한다면 저수준 함수들에 대하여 작성해야한다. 즉 자주 요구사항이 바뀌는 함수를 저수준에 작성해서는 안된다. 

20. 암묵적 인자를 찾아내고 중복 코드 스멜을 없애기. 예를 들어, 어떤 object의 값을 설정하는 함수가 있다고 가정했을 때, setPriceToProduct와 setShippingToProduct는 사실상 'price'와 'shipping'을 인자로 받으면 같은 함수라는 것이다. 위의 두 함수를 하나로 만들면 setField함수가 될 것이다. 이러한 인자들은 비즈니스 로직 상으로 제한시켜두면 된다. 예를 들어, typescript로 'price' | 'shipping'으로 제한시켜두는 것이다.

21. 모든 것을 고차함수로 만들 수도 있다. 그러나 어떤 패턴이던 목적은 좋은 코드를 만드는 것이지 엔지니어의 재미를 위한 것이 아니다. 더 좋은 코드를 만들어줄 경우에 쓰자

**4주차**  
22. 함수체인은 강력한 표현력이 있다. 가독성을 높이기 위해서 함수형 도구 함수에 이름을 붙여고차함수로 만들어도 좋지만 일반적으로 콜백에 이름을 붙이는 것이 더 명확하다.예를 들어, filter(getPriceOver1000)

23. 대부분의 경우, 단계들을 합칠(예를 들어, map 두번 쓰는걸 하나로 합치기) 수 있더라도 합치지 않는 것이 읽기 더 명확하다. 게다가 현대의 가비지 컬렉터는 매우 강력하다. 복사가 여러번 일어나더라도 상관없다는 것이다. 그러나 최적화가 필요한 경우 각 단계를 합칠 필요가 있는데, 이를 스트림 결합이라 한다.

24. 단계 별로 배열 전체를 처리하기, 작은 단계를 나누기, 조건문을 filter로 바꾸기, 구체적으로 이름 붙이기, pluck, frequenciesBy, groupBy, update,하스켈 Prelude

25. 360쪽의 var사용 같은 방식은 코드스멜아닌가?

26. 중첩객체에 재귀함수가 적합한 이유는 카피-온-라이트에 때문이다.
27. 함수의 인자로 콜백을 받아 함수 본문을 바깥으로 빼냄으로서 함수를 일반화할 수 있다.
28. 타임라인의 갯수를 줄이자
29. 공유자원(전역 변수 등)을 최소화 하자
30. 작업 순서를 통제해야할 때는 일단 요청되는 작업을 큐에 넣고 하나씩 빼면서 실행하면 직관적이다.
31. 반응형은 x를 하고 y를 하는 것에서 x가 일어나면 y를 하는 것으로 바뀌는 것
32. 어니언 아키텍처에서 핸들러가 DB도 호출하던데, 이렇게 어댑터 두개(컨트롤러와 리파지토리)를 하나로 결합된 형태로 사용하는 것이 현재의 방식(도메인이 추상화된 계층을 호출하는 것)과 비교해 어떤 장단점이 있을까? 








