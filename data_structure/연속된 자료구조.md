# 연속된(contiguous) 자료구조
contiguous data structures는 모든 원소를 단일 메모리 청크에 저장함.
각각의 데이터들이 저장된 메모리 공간들은 연속되어있으므로 Base Address(BA)를 알면 각각의 데이터에 즉시 접근할 수 있음(각 원소의 타입이 같다고 가정. 즉 같은 크기이므로 같은 간격만큼 떨어지게 됨).
BA + index * sizeof(type)으로 원하는 원소에 항상 즉시 접근 가능하므로 이 접근은 빅오 표기법으로 O(1)로 고정됨.

배열은 동적 배열과 정적 배열로 나눌 수 있는데, 필요에 따라 선택하면 되고 다양한 연산에서 동일한 성능을 나타냄. C언어에서 도입되어 C스타일 배열이라고도 함.

정적 배열의 예:
```c
int arr[10];
```
동적 배열의 예:
```c
int* arr = (int*)malloc(size * sizeof(int));
```
C++에서 동적 배열의 예:
```cpp
int* arr = new int[size];
```
정적 배열은 스택메모리 영역에 할당되므로 함수를 벗어날 때 자동으로 해제되는 반면 동적 배열은 heap에 할당되므로 사용자가 직접 해제하기 전까지 유지됨.

배열은 '연속'이라는 개념덕에 하나의 원소에 접근할 때 그 주변에 있는 원소도 cache됨. 그러므로 다음 원소에 접근할때는 그 원소를 캐시에서 가져오게 되어 매우 빠르게 동작함. 이러한 속서을 캐시 지역성(cache locality)이라고 표현하며 어떤 연산의 점근적 시간 복잡도에는 영향을 주지 않지만 실제 동작에서는 매우 빠른 동작이 되므로 큰 장점임. 배열에서 모든 원소에 순차적으로 접근하는 경우 다음 원소는 캐시에서 바로 참조가 가능하므로 배열은 캐시 지역성이 좋다고 판단할 수 있음.

# 연결된(linked) 자료구조
linked data structure에서는 여러개의 메모리 청크에 데이터를 저장하며 각 청크를 'node'라고 표현함. 각 node는 자신의 다음 원소에 해당하는 'next'라고 불리우는 포인터를 지님. 즉, i번째 원소에 접근하려면 i번 이동(O(n))해야함.

나뉘어진 청크는 데이터 삽입 또는 삭제에서 매우 뛰어난 성능을 보여주는데(이는 연속된 자료구조와는 다른 특징인데, 연속된 자료구조는 삽입 혹은 삭제시 하나의 데이터 청크를 유지하기 위해 메모리 주소를 모두 옮겨야하는 상황이 발생함. 물론 맨 뒤에 원소를 삽입한다면 O(1)로 수행가능하다. 그러나 그 외의 상황에서는 O(n)의 시간이 필요하다. linked된 자료구조는 어디에 삽입하던 O(1)), 이는 각 node가 오직 next로만 다음 데이터 청크(노드)를 가리키는 속성에서 비롯됨. 삽입은 삽입될 위치에 존재하던 노드가 삽입될 노드를 next로 가리키게 만들고, 삽입된 노드는 삽입될 위치에 존재하던 노드가 가리키던 노드를 가리키면 됨.

다만, linked 자료구조는 나뉘어진 메모리 청크라는 특성 때문에 캐시 지역성이 없으므로, contiguous 자료구조와 표면적 시간 복잡도에서는 아무런 차이가 없음에도 불구하고 순회시 contiguous가 더 빠른 모습을 보여준다.

# 특징 비교
#### contiguous
- 모든 데이터가 하나의 메모리 청크에 저장됨
- 원소에 접근하는 속도가 항상 O(1)
- 캐시 지역성 덕분에 순회가 매우 빠름
- 데이터의 크기와 자료구조의 크기가 동일

#### linked
- 데이터는 node별로 쪼개져 메모리 곳곳에 흩어져있음
- 원소 접근이 선형 복잡도를 가진다(O(n)으로, 접근 위한 용도로는 느리다고 볼 수 있음).
- 캐시 지역성이 없으므로 순회가 contiguous에 비해 느림(시간 복잡도는 동일)
- next 포인터를 저장해야하므로 데이터의 크기보다 자료구조의 크기가 큼

# 범용 자료구조는 내장되어있다
사용자가 직접 배열 혹은 연결 리스트를 구현할 필요는 없다. 이러한 범용적인 자료구조들은 거의 모든 언어에서 효율적인 구현을 통해 내장하고 있다.

# C 스타일의 단점
- 메모리 할당과 해제를 수동으로 처리해야하므로 memory leak의 위험이 잠재되어있다.
- []연산으로 배열의 원소에 접근할 때, 배열의 크기보다 큰 원소를 참조하려는 것을 검사하지 못합니다(길이 10인 배열에서 11을 참조하려는 행위).
- 배열 중첩시 가독성 심각하게 저해. 가독성은 생산성에 즉각적인 영향을 미친다.
- 깊은 복사가 기본적으로 동작하지 않으므로 수동으로 구현해야 함

이와 같은 단점들을 극복하기 위해 C++는 C스타일을 대체하는 std::array를 내장하고 있다.


