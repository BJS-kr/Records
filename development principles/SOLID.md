# Need of development principles
  우리는 개발중 수 많은 문제들에 직면한다. 문제가 발생하면 비용이 발생하며, 생상성과 효율의 저하로 이어진다. 규모가 커질 수록 그런 문제들은 더욱 심화된다. 개발자들은 수 많은 개발 경험을
 거치면서, 우리가 직면할 수 있는 문제들을 줄이고 효율성을 높이기 위해 개발 원칙들을 정립하기 시작한다. 원칙을 안 지킨다고 개발을 못하는 것도 아니고, 프로그램이 안 돌아가는 것도 아니지만 
 우리는 원칙을 정립하고 따름으로써 혁신적인 확장성 및 안정성을 보장 받을 수 있다. SOLID 외에 여러가지의 개발 원칙들이 있지만, 차차 정리하기로 하고 오늘은 가장 유명한 객체지향 개발 원칙인 SOLID에 대해서 알아보도록 하겠다.
 
 # What is bad code?
  SOLID를 설명하려면 먼저 나쁜 코드란 무엇인지 부터 짚고 넘어가야한다. SOLID에서 표방하는 모든 가치들은 '나쁜 코드'를 배제시키는 것이기 때문이다. 나쁜 코드의 몇가지 특징은 다음과 같다.
  ### 경직성(rigidity)
  모듈간 결합도가 너무 높아서 코드를 변경하기가 매우 어려운 구조를 말한다. 모듈간의 구조가 거미줄 처럼 엮여있어 어느 곳도 개선이 불가능 해진다.
  ### 취약성(fragility)
  한 부분을 수정하면 다른 부분에서 필연적일 정도로 버그가 발생하는 상황이다. 마찬가지로 코드의 개선을 매우 어렵게 만든다.
  ### 부동성(immobility)
  코드를 재사용할 수 없는 것을 일컫는다. 위와 마찬가지로 결합도가 너무 높아서 발생하는 문제이며, 비슷한 기능도 매번 새로 구현해야해서 비효울적으로 개발하게 된다.
 
 # S.O.L.I.D
 나쁜 코드의 특징도, SOLID 원칙도 각 항목이 상호 배타적이라기보다는 모두 상호 의존적인 특징을 띄므로 한 가지의 특징 혹은 원칙이 다른 항목을 그대로 촉발 시키는 경우가 많다.
 좋은 코드란 나쁜 코드의 특징과 정확히 반대된다고 이해한 후 SOLID의 개념을 파악해보자
 ### 1. Single responsibility
  **"모든 객체는 하나의 책임만을 진다"** -> **코드의 재사용성을 높인다**  
  가장 기본적이고 심플한 제 1원칙. 어렵지 않다고 여기면서도 의외로 무시되기 쉬운 원칙이다. 1원칙만 잘 지켜도 효율성과 안정성을 손쉽게 높일 수 있으니 항상 염두하고 개발하여야 한다.
  예를 들어 회계 보고서 객체를 정의하는 class가 있다고 생각해보자. 그 class의 메소드에 보고서 전송을 담당하는 메소드가 포함되어있다면 어떻게 될까? 이는 1원칙 위반일 확률이 높다.
  회계 보고서가 아니라 마케팅 보고서를 객체를 정의할땐 어떻게 해야된다는 말인가. 또 다시 전송 메소드를 마케팅 보고서 객체에 포함 시키는 수 밖에 없을 것이다. 단지 코드가 늘어나고 반복된다는 
  것이 문제가 아니다. 보고서 전송 체계가 바뀐다면 어떻게 될까. 그 모든 객체들을 모두 수정해야 한다. 이는 명백히 큰 비용으로 작용한다. 문제가 생길 확률이 엄청나게 높아지는 것은 말할 필요도 없다. 
  그렇다면 예를 든 보고서들을 개발하는 올바른 형태는 무엇일까? 각 보고서 종류별로 다른 객체가 존재하지만 전송은 하나의 함수, 인터페이스, 객체 등을 따르는 것이 올바른 방향일 것이다.
  
  ### 2. Open-Closed principle(OCP)
  **"확장에는 열려있고, 변경에는 닫혀있다"** -> **상호 결합도를 줄여 새 기능을 추가하더라도 기존 구현을 변경하지 않을 수 있다**  
  새로운 코드를 삽입할 때 기존의 코드의 변경을 최소화하여 비용을 절감할 수 있도록 하는 원칙입니다. 위에서 살펴본 보고서 전송의 예를 다시 한번 상상해보자. 전송 방법에 따라 전송 함수는 switch-case문으로
  적절한 구현을 매번 선택한다고 가정하자. 이는 OCP위반이다. 왜일까? 새로운 전송방법을 추가한다고 가정해보자. 보고서를 전송하는 부분이 단 한곳이라면 그나마 다행이겠지만, 아니라면 새로운
  보고서를 전송 방법을 구현 할 때마다 모든 switch-case문을 수정해야 한다. 명백한 OCP 위반인 것이다. 또한 이는 Single responsibility에도 위배된다. 전송 객체 하나가 여러 전송 방법을 모두 책임지고 있기 때문이다.
  올바른 방법은 각 전송방법에 따른 객체를 모두 분리시켜 적절한 곳마다 분리된 전송 방법들을 배치시키는 것이다.
  
  ### 3. Liskov substitution principle
  **"q(x)를 타입 T의 객체 x에 대해 증명할 수 있는 속성이라 하자. 그렇다면 S가 T의 하위 타입이라면 q(y)는 타입 S의 객체 y에 대해 증명할 수 있어야 한다."** -> **예상치 못한 작동을 방지한다**  
  정의 그대로인 얘기다. 하위 타입이라면 같은 q()함수에 대하여 똑같이 작동해야한다는 뜻이다. JS를 예로 들어, 인터페이스 T를 각각 implements하여 S와 U라는 새로운 class 두개를 생성했다고 가정하자.
  또한 s는 S, u는 U의 인스턴스라고 가정하자. q()의 인자로 T를 implements한 객체를 넣는다고 생각했을 때 q(s)와 q(u)는 모두 잘 작동해야 한다는 것이다. 또 다시 보고서 전송의 예를 떠올려보자.
  sendReport()함수는 보고서 객체를 인자로 받는 함수라고 가정해보자. sendReport(new FinancialReport(financialArguments))는 sendReport(new MarketingReport(marketingArguments))와 같게 작동해야 할 것이다.
  그렇지만 그렇게 작동하지 않을 경우 리스코프 치환 원칙에 위배되게 된다. 원인은 너무 다양할 것이다. 우리의 예로서는 특정 양식은 특정 전송방법으로 전송시 오류가 발생하는 경우를 떠올려 볼 수 있겠다.
  
  ### 4. Interface segregation principle(ISP)
  **"클라이언트는 자신이 이용하지 않는 메서드에 의존하지 않아야 한다"** -> **인터페이스를 분리하면 불필요한 의존관계가 사라져 더 가볍게 인터페이스를 이용 할 수 있다**  
  정의만 읽어봐도 이해하기 쉬운 원칙이다. Report 인터페이스에 다양한 메서드들이 포함되는 경우를 떠올려보자. 필요한건 sendReport() 하나뿐이라고 해도, 다른 메서드들도 어쩔 수 없이 구현해야만 할 것이다.
  올바른 방식은 필요한 인터페이스만 존재하도록 sendReport()외의 다른 메서드들은 제외한 interface를 만드는 것이다.
  
  ### 5. Dependency inversion principle(DIP)
  **"상위 계층이 하위 계층에 의존하지 않도록 의존 관계를 반전 시킴으로써 상위 계층의 구현을 하위 계층의 구현으로부터 독립시킨다"**  
  원칙 1. 상위 모듈은 하위 모듈에 의존하는 것이 아니라, 둘다 추상 모듈에 의존해야 한다.  
  원칙 2. 추상 모듈은 구체화된 모듈에 의존해서는 안된다. 구체화된 모듈은 추상 모듈에 의존해야 한다.  
  -> **추상모듈에 의존함으로써 확장성이 증가된다. 또한 상호 결합도가 낮아져 이식성이 증가된다.**  
  DIP의 예는 사실 프론트 JS코드에서 항상 발견 할 수 있다. 흔히 볼수 있는 EventListener가 바로 그것이다. 무슨 말인지 이해가 가지 않을 수 있다. 좀더 구체적인 예를 들어보겠다.
  click시 실행되며 click을 인자로 받는 onReceive(click)이라는 함수가 있다고 가정하자. 이 함수의 내부에는 alarm 메서드가 존재하며 클릭시 알람이 실행되게 된다.
  이는 DIP를 크게 위반한 설계다. 구체화된 모듈(alarm)이 구체화된 모듈(click)에 의존하고 있기 때문이다. 이를 원칙 1,2에 부합하도록 변경해보자. 먼저 상위 모듈(alarm)과 하위모듈(click)을 모두
  추상화된 모듈에 의존시켜야한다. 여기서 등장하는 것이 Event와 EventListener이다. 즉 click은 Event에, alarm은 EventListener에 의존시키는 것인데 EventListener는 또한 Event에 의존시킨다.
  이렇게 하면 2원칙까지 모두 만족된다. 작동 순서는 이러하다.  
  
  
  click은 event라는 인터페이스를 구현하고, 알람은 eventListener를 구현한다. event는 register라는 메서드를 가지며 eventListener는 onFire라는 메서드를 가진다고 가정한다. 
  click발생시 register(eventListener)가 동작하여 eventListener의 onFire()로 호출 된다. onFire는 알람을 표시한다. click과 alarm이 추상화된 모듈들의 관계를 통해 분리 된 것이다.
  이제 우리는 click뿐 아니라 mail, chat등의 각종 이벤트를 자유롭게 event인터페이스에 구현할 수 있고, 마찬가지로 alarm또한 팝업, 조건부 알람 등 원하는 대로 eventListener의 onFire도 구현 할 수 있게 되었다.
  확장성 및 이식성이 극대화 된 것이다.
  
  
  
  
  
  
