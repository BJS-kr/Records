// 1 -> 1
// 2 -> 3
// 3 -> 7
// 4 -> 15
// 5 -> 31
// 6 -> 63

const N = 3;
let th = 1;
let count = 1;
while (th <= N) {
  (th > 1 && (count += 2 ** (th++ - 1))) || th++;
}
console.log(count);

const one = ['1 3'];
const two = ['1 2', '1 3', '2 3'];
const three = new Map([
  [12, ['1 2', '1 3', '2 3', '1 2', '3 1', '3 2', '1 2']],
  [13, ['1 3', '1 2', '3 2', '1 3', '2 1', '2 3', '1 3']],
  [21, ['2 1', '2 3', '1 3', '2 1', '3 2', '3 1', '2 1']],
  [23, ['2 3', '2 1', '3 1', '2 3', '1 2', '1 3', '2 3']],
  [31, ['3 1', '3 2', '1 2', '3 1', '2 3', '2 1', '3 1']],
  [32, ['3 2', '3 1', '2 1', '3 2', '1 3', '1 2', '3 2']],
]);

if (N === 1) console.log(one);
else if (N === 2) console.log(two);
else {
  const result = [];

  (function hanoi2(current123Position = 1, n = 3) {
    if (n === N) {
      return result.push(three.get(current123Position * 10 + 3));
    }
    hanoi2(n + 1);
  })();

  console.log(result.flatMap((x) => x));
}

// // 예를 들어,
// // three는 _1to3
// // four는 _1to2 -> 맽 밑 원판 1 3 -> _2to3
// // five는 _1to3 -> 네 번째 원판 가운데로 -> _3to2 -> 맨밑 원판 마지막으로 -> _2to1 -> 가운데 원판 끝으로 -> _1to3
// const four = [
//   '1 2',
//   '1 3',
//   '2 3',
//   '1 2',
//   '3 1',
//   '3 2',
//   '1 2',
//   '1 3',
//   '2 3',
//   '2 1',
//   '3 1',
//   '2 3',
//   '1 2',
//   '1 3',
//   '2 3',
// ];
// 무조건 맨 위 세개로 기준을 잡을 수 밖에 없음
// 예를 들어, 5개라면 위에 세개를 치우고 네번째 껄 옮겨야함
// 그리고 다시 세개를 네번째 원판위에 쌓아야함
// 결국 맨 밑 원판이 끝으로 가야하기 떄문에
// 그래서 규칙은 이러함
// 3개를 옮긴다(7번) 밑에 원판을 옮긴다(1) 다시 세개를 옮긴다(7) 맨 밑 원판을 옮긴다(1) 세개를 옮긴다(7) 두번째 밑 판을 옮긴다(1) 세개를 옮긴다(7)
// 그러니까, n개라면 n-1개의 원판옮기기 + 1 + n-1개의 원판 옮기기라는 규칙이 생긴다.
// 다시 n-1개라면 n-2개의 원판 옮기기 + 1 + n-2개의 원판 옮기기
// ...
// 1개가 될때까지 반복
//
