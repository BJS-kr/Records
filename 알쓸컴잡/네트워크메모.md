DWDM 동시 다중 연결 및 전송
NIC
맥주소, 직렬화, 흐름제어(데이터를 받지 못할땐 통신 중지 요청)
일반적으로 10G이상의 NIC는 CPU대신 패킷 생성?!
L3 스위치가 되는 NIC?
서버와 스위치간 연결을 10기가비트 이더넷으로 구성할 경우, 스위치는 상위 스위치와의 통신 대역폭을 확보하기 위해 40기가나 100기가 비트 사용
숫자는 속도, BASE는 단일, BROAD는 다채널 통신, 마지막 문자는 케이블 타입
광케이블은 케이블 중에 짱이다. 그리고 진짜로 레이저를 사용한다…
NIC에 트랜시버가 포함된다는 소리인가?73쪽
허브는 거의 사용되지 않는다.
2계층 스위치는 현대의 허브 역할을 겸용한다. 그래서 스위칭 허브로도 불린다 맥주소를 이해할 수있다.
라우터는 패킷 포워딩한다. 사실 라우터는 일반 사용자들이 보기는 어렵지만 라우터와 유사한 역할을 하는 L3스위치와 공유기는 쉽게 찾아볼수있다.
LB는 보통 4계층을 이르고, L7 LB는 application delivery controller라고 부른다. L4스위치도 로드 밸런서의 한 종류이다. 스위치처럼 여러 포트를 가지고 로드밸런싱 역할을 수행한다. 로드밸런서는 4계층 포트를 확인할 수 있고 IP주소를 변경할 수 있다.
4계층에서 방화벽 동작. 3,4계층 정보를 확인해 정책과 비교하고 버리거나 포워딩
공유기는 스위치, 무선, 라우터 부분으로 나뉜다.
질문
IP 주소 변환은 NAT로 3계층 라우터 역할인줄 알았는데?
대체 L3스위치가 뭐임. 왜 234에서 다 스위치라는 용어를 쓰는거임

3장

1. 유니캐스트, 브로드캐스트, 멀티캐스트(애초에 목적지가 여러개), 애니캐스트(1:1이지만 아무나 한놈), 언노운 유니캐스트는 스위치가 주소를 학습하지 못해 유니캐스트임에도 불구하고 플러드 발생시키는것
2. 맥주소는 변경가능
3. NIC가 맥주소 확인 후 목적지가 자신이거나, 브로드캐스트나 멀티캐스트의 그룹이면 상위로 보냄. 무차별 모드로 주소가 다르더라도 받을 수 있음. 이런 특성으로 인해 브로드캐스트는 cpu사용량을 증가시킬 위험이 있음. 맥주소는 NIC에 종속된 것이므로 컴퓨터는 여러 맥주소를 가질 수 있음
4. IP주소는 네트워크주소와 호스트주소로 나뉘어져있다. 네트워크주소가 차지하는 부분이 클 수록 호스트 주소는 줄어든다. 예를 들어 네트워크 주소가 C클래스라면 호스트주소의 숫자는 2\*\*8이다.
5. A: 1~127(그러나 127은 루프백주소), B: 128~191, C: 192~223 반전은 이제 클래스 기반으로 네트워크 분할 안함...장난?
6. 어쨌든 실제로는 호스트 주소가 0이면 네트워크 주소를 대표하고, 255는 브로드캐스트 주소이므로 각 클래스 분할마다 할당할 수 있는 갯수는 -2개씩 제해진다.
7. CIDR(클래스리스 인터도메인 라우팅)은 단기대책이다 ㄷㄷ. 중기는 NAT와 사설IP, 장기는 IPv6
8. 서브넷 마스크체계에서 A,B,C클래스는 좀 다른 의미로 쓰인다. A는 255.0.0.0 B는 255.255.0.0 이런식인데, 기본 서브넷 마스크라고 불린다.
9. 서브넷 마스크를 통해 어떤 호스트의 주소에서 네트워크 주소를 뽑아낼 수 있는데, 그 이유는 255 255 이런것들이 원래는 이진수이기 때문에, 호스트 주소와 and연산해버리면 마스크가 없는 부분(서브넷 마스크가 0인 부분)만 싹 걸러진다. 서브넷 마스크의 이진수에서 1은 공백이 없이 이어져있기 때문에 마스크가 있는 부분과 호스트 주소와의 and연산을 하면 0인 부분이 걸러진다는 소리
10. 기본적으로 서브넷 마스크를 255.255.0.0 처럼 옥텟이 모두 0이거나 1인 경우로 표현하기도 하지만, 서브넷팅은 사실 더 복잡하다. 왜냐하면 옥텟단위가 아니라 비트단위로 마스크를 씌우기 때문이다. 예를 들어, 255.255.255.192는 11111111.11111111.11111111.11000000을 뜻한다.
11. 10번과 같은 경우에도 마찬가지로 0인 부분이 모두 1로 채워지면 브로드캐스트 주소, 모두 0이면 네트워크 주소이다. 이는 위의 and연산에서 이미 언급했다.
12. 서브넷을 잘 나눠야하는 이유는 관리성과 효율성 때문이다. 필요한 만큼만 라우터가 관리하는 것이 부담이 적고 관리자 입장에서도 편할수밖에 없다.
13. 인터넷에 접속하지 않거나 NAT하는 경우 사설 IP를 이용할 수 있다. 공유기는 대표적인 NAT장비이다.
14. RFC자체는 표준이 아니고 그냥 메모에 불과하다. 물론 메모에서 표준으로 승격된 RFC들도 존재한다. 이를 RFC standards라고 부를 수 있다.
15. 사설망에 아무거나 할당해도 되는 것은 아니다. 예를 들어 naver의 접속 ip를 내 사설망의 단말중 하나에서 사용하고 있다고 치자. 구성할때는 문제가 없다. 그런데 같은 사설망에 있는 어떤 단말이 naver에 접속을 시도할 경우 내 사설망에 있는 naver와 같은 ip를 가지고 있는 단말에 접근하게 된다. 16.계층별로 붙는 데이터는 무조건 두가지다. 그 계층에서 필요한 정보들과 상위 프로토콜 지시자
16. well-known port가 아니더라도 1024~49151의 범위는 유명 애플리케이션 등이 할당받아 사용거나 등록신청하지만 사설로 사용되기도 하는 혼재 구역이다. 49152~65536은 완전히 동적, 사설,임시 포트 구간이다.
17. 3계층장비(라우터와 L3스위치)는 LAN간 게이트웨이가 되어준다. 여기서 또 서브넷이 중요해지는데, 서브넷 마스크 and연산을 통해 먼저 로컬통신(같은 네트워크 소속)인지 원격 통신인지를 판단하고 게이트웨이를 통과할지 말지를 결정하기 때문이다. 이를 실무적으로 2계층통신(로컬 통신) 3계층 통신(원격지 통신)이라고 부른다. L2장비까지만 있어도 로컬 통신이 가능하기 때문이다(당연히 app부터 출발하므로 7~1계층 캡슐-디캡슐은 거친다. 다만 목적지를 찾는 것에 있어서 L2까지만 필요하다는 의미이다.).
18. 18에서, 로컬네트워크라면 기본 게이트웨이로 ARP요청을 보낼 필요없이 그냥 자신의 네트워크에 ARP브로드캐스트를 보내면 될 것이다. 원격네트워크라면 먼저 게이트웨이에 ARP를 보내야할 것이다.
19. 위와 같은 특성으로 인해 재밌는 현상이 발생하는데, 로컬 통신에서는 ARP 응답받은 송신 단말이 보내는 패킷의 MAC주소와 IP주소는 실제 응답 받는 단말의 MAC과 IP주소와 일치한다. 반면 원격 통신에서는 송신 단말 패킷의 MAC주소는 원격 네트워크 기본 게이트웨이 단말의 MAC주소이고, IP는 실제 수신 단말의 IP이다. 근데 정확히 왜 그런거임?;
    진짜로 패킷 하나당 잘 받았다고 응답하는 것이 아님. 한번에 여러개 보낼 수 있는데, 상대방의 수용능력에 따라 결정된다. 이는 수신측 윈도우사이즈에 의해 결정된다. 윈도우 사이즈는 원래 64KB이지만 현대에는 그냥 대폭 늘려서 통신한다. 데이터 유실을 감지할 경우 윈도우사이즈를 절반으로 줄이고 정상적으로 통신이 되면 서서히 늘려나간다.
    3way handshake: syn - syn/ack - ack
    수신자는 송신자가 보낸 SEQ에 1을 추가해 ACK에 넣어 보낸다.
    시간에 민감하지 않은 유튜브나 넷플릭스등은 UDP가 아니라 TCP를 사용한다. 미리 데이터를 더 받아놓아 원활한 시청 환경을 제공한다. 화상회의 같이 실시간 시청에 민감한 경우는 사용할 수 없는 방법으로, UDP를 이용해야한다.
    TCP는 유니캐스트만 가능하다. 반면 UDP는 유니, 멀티, 브로드 모두 가능하다
    ARP는 상대방의 맥주소를 알아내기 위한 프로토콜. 캡슐화할때 IP는 미리 알고 있으므로 가능하지만 2계층 캡슐화가 불가능하므로 ARP
    매번 ARP를 수행하지는 않는다. ARP테이블을 만들어 캐시해두는데, ARP의 결과는 영구적인 것이 아니므로 일정시간동안 통신이 없으면 테이블에서 삭제된다.
    그럼 2계층을 모르는데 어떻게 보내느냐? 브로드캐스트임을 뜻하는 문자열 (FF-FF-FF…)을 목적지 맥주소에 넣어 ARP한다. ARP프로토콜의 상대 맥주소는 0으로 채워 보낸다.ARP에 대한 응답은 유니캐스트이다. 이는 당연한 것이다.
    GARP는 ARP이나 자신의 맥주소와 IP를 알릴목적으로 사용된다. 송신자와 수신자 IP 및 송신자 맥주소는 모두 자신의 주소를 넣고, 수신자 맥주소만 브로드캐스트로 보낸다. 즉 브로드캐스트하나 패킷의 목적지는 자기 자신이다. 이는 IP주소의 충돌 감지, 상대방의 ARP 테이블 갱신, HA용도의 클러스터링, VRRP, HSRP를 위해 사용된다. 자신에게 보낸 것에 응답할리 없으므로 응답이 돌아온다면 주소가 충돌중이 것이다.
    GARP의 사용목적
    IP주소 충돌감지
    동일 네트워크에 있는 ARP테이블 갱신
    예를 들어, 어떤 단말이 DB클러스터에게 요청을 보낸다고 가정하자.
    요청을 받는 주소는 아마도 가상주소이겠지만 맥주소는 실제 맥주소여야한다. 그렇다면 요청 단말은 ARP요청을 통해 마스터 노드의 맥주소를 반환받게 된다.
    마스터가 다운되었다고 가정하자. 요청 단말은 마스터가 다운되었다는 것을 알 수 없으므로 여전히 요청에 다운된 노드의 맥주소를 담아 보낸다.
    위 와 같은 상황을 막기 위해 슬레이브 노드가 마스터 다운을 감지한 직후 GARP를 전파한다. 그렇게 되면 요청 단말의 ARP캐시가 갱신되므로 올바르게 요청을 보낼 수 있다.
    그러나 패킷을 가로채는 등의 문제 때문에 위와 같은 방식은 현재는 잘 쓰이지 않는다.
    b는 ARP캐시테이블 갱신이 목적이지만 이번에는 네트워크의 통신을 분배하는 스위치의 맥 테이블을 갱신시키는 것이 목적이다.
    DB는 실제 맥주소 대신 가상 맥주소를 사용한다. 이 경우 요청 단말은 ARP테이블을 갱신할 필요가 없다. 모든 클러스터 노드는 동일한 맥주소로 평가된다.
    DB클러스터에는 스위치가 위치해있고, 가상의 맥주소가 적절히 마스터를 찾아 갈 수 있도록 해야한다. 이때 스위치의 맥테이블에서 업데이트되어야 할 항목은 포트이다. 여기서 포트란, 3계층의 포트가 아니고 스위치가 가지고 있는 물리적 포트를 의미한다. 스위치의 맥테이블은 자신이 가지고 있는 포트와 맥 주소의 매핑이다.
    마스터가 다운될 경우, 슬레이브는 GARP를 통해 스위치의 포트를 갱신한다.
    HA솔루션에서 빠르게 failover가 되지 않는 경우, 솔루션 자체의 문제일 수도 있지만 GARP를 받은 스위치가 빠르게 맥테이블을 갱신하지 않아 문제가 되는 경우도 많다. 이런 경우, GARP를 보내는 속도, 횟수 혹은 스위치와 연결된 포트를 리셋해 MAC테이블을 초기화시키기도 한다.
    PDU(protocol data unit) 비트, 프레임, 패킷, 세그먼트 통칭
    각 계층마다 고유 명칭이 있지만 그냥 데이터를 쪼개 부르는 것 전체를 패킷이라고 통칭함
    스위치의 핵심기능
    플러딩
    허브처럼 모든 포트로 패킷을 흘려보낸다. 맥 테이블에 일치하는 주소가 없을 경우 행한다. 맥 테이블에 등록되면 필요한 곳에만 패킷을 흘려보내므로 패킷을 가로채기 힘들어져 보안에 도움이 된다.
    보통 통신은 ARP이후에 이뤄지므로 실제 통신에서는 플러딩은 일어나지 않는 경우가 대부분이나, 비정상적 플러딩도 일어난다.
    엉뚱한 맥주소를 학습시키거나 맥테이블을 가득차게 만들어 플러딩을 유도하기도 한다. 이유없이 플러딩이 일어난다면 무언가 위험한 상황이 발생하고 있음을 알아야한다.
    어드레스 러닝
    출발지의 맥주소를 학습하므로 브로드캐스트/멀티캐스트의 맥주소는 학습할 수 없다.
    사전학습된 주소도 있다. 이런 정보들은 패킷을 처리하기 위한 것이 아니라 스위치간 통신을 위해 사용된다. 스위치의 맥주소 테이블을 확인하기 위해 how mac address-table 명령어를 사용할 수 있다.
    포워딩/필터링
    등록된 곳으로만 보내고 다른 곳으로는 보내지 않는 것을 필터링이라고 함. 보내는 것을 포워딩이라고 함. 이 작업은 포트별로 수행가능함
    위의 작업은 오직 유니캐스트에서만 동작함. BUM트래픽에서는 필터링 하지 않고 모두 플러딩함
    이더넷-TCP/IP가 플러딩하는 경우가 극히 드문이유는 ARP할때 이미 맥 주소 습득이이뤄지기 때문이다. 일정 시간 동안 맥테이블을 유지되는데, 이 시간을 에이징 타임이라고 한다. 맥테이블의 에이징 타임이 ARP테이블의 에이징 타임보다 길어서 효율적으로 운용이 가능하다.
    VLAN은 하나의 스위치를 논리적으로 분할해 별개의 스위치처럼 랜을 운영하는 기법이다. 논리적이라도 네트워크가 분할되어있으므로 서로 통신하려면 3계층 장비가 필요하다
    VLAN이라고하면 대부분 포트기반 VLAN을 말한다. 말 그대로 포트별로 속한 VLAN이 다른 것이다. 그러나 MAC기반 VLAN도 존재한다. 맥 기반 VLAN은 점차 증가하고 있다.
    앞서 VLAN은 특정 포트는 특정 VLAN에 속해있다고했지만, 스위치간 통신을 위해 너무 많은 포트가 필요하게 되어 VLAN태그 기능이 생겨났다. 태그기능은 하나의 포트에 여러개의 VLAN을 함께 전송할 수 있게 해주는데, 이 포트를 두고 Tagged또는 Trunk 포트라고 부른다. 이더넷 프레임 중간에 VLAN ID필드를 끼워 넣어 이 정보를 이용한다. 스위치간 VLAN통신할 경우 포트라고 함은 일반적으로 태그 포트를 의미한다. 트렁크포트는 시스코에서 사용하는 용어로, 다른 네트워크 제조사는 트렁크 포틀를 여러개의 포트를 묶어 사용하기 위한 링크 애그리게이션의 의미로 사용한다. 일반적인 포트는 언태그 포트 또는 액세스 포트라고 부른다.
    하나의 스위치가 여러개의 네트워크를 관장하니 맥 주소 테이블에도 변화가 필요하다. 각 VLAN을 구분할 수 있는 필드가 맥 주소 테이블에 존재하게 되는데, 이를 통해 마치 각 VLAN별로 별도의 MAC테이블이 존재하는 것처럼 사용가능하다.
    언태그포트는 포트가 하나의 VLAN에만 속해있을 경우 사용가능하다. 태그포트라면 패킷을 전송할때 VLAN ID(태그)를 벗겨내면서 전송한다.
    물리 스위치와 가상 서버에 속한 가상 스위치가 통신할때도 이는 마찬가지로 태그포트로 설정해야하며 가상 스위치의 포트도 태그로 설정해야한다.
    SPoF(Single Point of Failure)는 하나의 장애로 시스템 전체가 멈추는 것을 일컫는다.
    네트워크로 통하는 장비가 스위치 하나라면, 그 스위치에 장애가 생길경우 전체 네트워크가 마비될 것이다. 대표적인 SPoF이다. 이를 막기위해 다중으로 스위치를 구성한다.
    그러나 다중으로 스위치를 구성하면 패킷이 네트워크에서 루프를 돌아 장애가 생길 수도 있다. 루프는 대부분 브로드캐스트 스톰 때문에 발생한다. 루프는 서로 주고받거나 3개 이상의 스위치라도 계속 루프가 생기는 등 여러 형태로 일어난다.
    스위치가 여러대 연결되어있다면 브로드캐스트시 패킷이 유입된 포트를 제외한 모든 포트로 패킷을 전송할 것이므로 다른 스위치로도 패킷이 전송된다. 이때 그 스위치도 마찬가지의 동작을 하므로 루프가 발생한다.
    스위치는 출발지의 맥주소를 학습하는데, 맥 주소테이블은 맥주소와 포트가 매핑된 형태이므로 다른 스위치를 돌아나온 패킷 정보는 포트 번호가 달라 정상적인 맥주소학습이 불가능해진다. 즉, 같은 맥주소에 다른 포트를 여러번 학습하는 상황이 발생하는 것이다. 이 현상을 MAC Address Flapping이라고 한다.
    이렇게 되면 맥주소 테이블에서 포트가 끝없이 변경되므로 스위치가 제 역할을 하지 못하고 패킷을 플러딩하게 된다.
    STP(스패닝 트리 프로토콜)은 위와 같은 상황을 막기 위해 개발되었다.
    STP는 전체 스위치 연결 구조가 어떻게 생겼는지 파악해야 작동한다. 이를 위해 BPDU라는 프로토콜로 스위치간에 정보를 전달하고 전체 네트워크 트리를 만들어 루프 구간을 확인한다. BPDU에는 일정한 형식이 있는데, 각 스위치의 ID와 같은 고유값을 지니고 있ㅇ르므로 스위치간에 이러한 정보들이 교환되면서 루프가 일어나고 있는지를 파악할 수 있게 된다. 루프가 감지되면 그 지점을 트래픽이 통과하지 못하도록 해 루프를 예방한다.
    스패닝 트리 프로토콜이 동작중일때 새로운 스위치를 연결하면 일단 트래픽이 차단된다. 해당 포트로 트래픽이 흘러도 되는지 확인하기 위해 BPDU를 실행하고 학습해 구조를 파악한다. 루프가 감지될경우 차단상태를 그대로 유지한다.
    차단상태에서부터 차단 해제까지는 다음 네 가지의 단계를 따른다.
    Blocking: 최대 20초(Max Age)동안 상대 스위치에게 BPDU를 받지 못했거나 후순위 BPDU를 받는 경우 리스닝으로 변경된다. BPDU기본 교환 주기는 2초이고 10번의 BPDU를 기다린다.
    Listening: 해당 포트가 전송 상태로 변경되는 것을 결정하고 준비하는 단계. 이 때부터 자신의 BPDU를 상대에게 전송한다. 총 15초동안 대기한다.
    Learning: 포트는 포워딩 할 수 있는 상태이며, 실제 패킷 포워딩이 일어날 경우 곧바로 동작하기 위해 MAC주소를 학습하는 단계이다. 15초 정도 소요된다.
    Forwarding: 정상 동작 상태
    스위치에 신규 장비를 붙이면 통신하는데 50여초가 소요된다. 연결된 장비가 스위치일 경우를 대비해 BPDU를 일정시간 기다리기 떄문이다. 스위치는 매우 적극적으로 루프를 방어하려고 한다.
    위와 같은 특성으로 인해 OS가 부팅될때 DHCP를 요청하고도 스위치가 정상 상태가 아니어서 IP를 할당받지 못하는 경우가 생긴다.

# 5장 3계층

1. 라우터와 L3스위치는 현대에는 구분하기 거의 어렵다.
2. 스위치와 반대로 라우터는 들어온 패킷의 목적지 주소가 라우팅 테이블에 없으면 패킷을 버림
3. 기존 2계층 헤더 정보를 제거 후 새로운 2계층 헤더 정보를 붙인다.

### 경로 지정(라우팅) - 핵심 역할

- ip주소를 기반으로 적절한 경로로 패킷을 포워딩한다
- 경로 지정은 두 가지 스텝으로 나뉜다.

- 경로 정보를 얻는다.
  1. 인접 네트워크의 정보를 얻는 방식
  2. 관리자가 직접 경로 정보를 입력하는 방식
  3. 라우터끼리 서로 경로 정보를 자동으로 교환
- 얻는 경로 정보를 확인하고 패킷을 포워딩한다.

- 라우터는 exact match가 아니더라도 가장 근접하다고 판단되는 경로(넥스트 홉)로 패킷을 포워딩한다.
- 네트워크를 한 단계씩 건너뛴다는 의미로 홉 바이 홉으로 표현한다.

- 다음 라우터의 IP를 지정하거나, 라우터의 나가는 인터페이스(포트 비슷)을 지정하거나, 둘 다 지정하는 방법이 있다.
- 일반적으로는 상대 라우터의 인터페이스 ip주소를 지정하는 방법을 사용한다.

- 인터페이스는 라우터의 물리 인터페이스가 일반적이지만 IP주소와 인터페이스를 동시에 사용할 때는 VLAN 인터페이스와 같은 논리 인터페이스를 사용할 수 있다.
- 라우팅테이블에는 목적지 주소, 넥스트 홉 IP주소, 나가는 로컬 인터페이스가 포함된다.
- PBR(policy based routing)도 사용되지만 특수한 목적으로만 사용된다.
- Loop Free 3계층: TTL
  - 3계층 헤더에는 TTL필드가 포함되어있어 유령패킷을 제거할 수 있다. TTL이 0이되면 라우터는 패킷을 드랍한다.
- 라우터가 경로 정보를 얻는 방법은 크게 세가지다.
  1. direct connected
  2. static routing
  3. dynamic routing
- 라우터가 수집한 원시적인 경로정보를 토폴로지 테이블이라고 부르고, 경로중 최적을 선별해 저장해두는 곳을 라우팅 테이블이라고 부른다.
- 단말에 IP주소가 기입될 때 자동으로 자신이 속한 네트워크의 라우팅 정보를 습득할 수 있다. 이 경로 정보를 direct connected라고하며, 테이블 상 connected라고 표현된다. 강제로 지울 수 없고, 네트워크 설정 자체가 삭제되거나 해당 네트워크 인터페이스가 비활성화 되어야 사라진다.
- 관리자가 목적지 네트워크와 넥스트 홉을 라우터에 직접 지정한 것을 두고 static routing이라고 한다. 스태틱 라우팅은 주고 받는 라우터 모두에 설정해주어야 정상적으로 통신한다.
- 라우터끼리 자신이 알고 있는 경로 정보나 링크 상태 정보를 교환해 전체 네트워크 정보를 학습하는 것을 다이나믹 라우팅이라고 한다. 대부분의 네트워크에서 사용된다.
- 스위칭: 패킷이 라우팅 테이블을 참조하고 최적의 경로를 찾아 라우터 외부로 포워딩하는 작업. 스위치와 이름이 비슷하지만 엄연히 3계층 개념
- 스위칭할 때, exact match가 없더라도 Longest Prefix Match로 경로정보를 찾는다.
- LPM은 exact match에 비해 매우 많은 자원을 소모한다. 그러므로 한번 스위칭한 정보는 캐시에 저장한다. 캐시하는 정보의 종류는 다변화될 수 있다. 목적지 ip만 캐시하거나 출발지와 목적지 모두, 혹은 포트번호까지 캐시할 수도 있다. 넥스트 홉 L2정보를 캐시하기도 한다.

- 토폴로지 테이블의 원시 데이터를 라우팅 테이블에 적재하기 위해선 가치있는 정보의 순위를 매길 수 있어야 한다.
- 첫 번째 기준은 LPM이이다.
- 두번째 기준은 정보를 얻은 소스이다. 다이렉트 커넥티드, 스태틱 라우팅, 다이나믹 라우팅 순으로 우선순위를 가진다.
- 우선순위 기준도 관리자가 직접 조정할 수 있다.
- 우선순위를 Administrative Distance, AD라고 부른다. 이 값은 제조사마다 조금씩 차이가 있다.
- 경로정보를 얻은 소스가 같다면 두번째 가중치는 Cost이다. Cost는 일종의 거리를 나타는 값으로, 라우팅 프로토콜마다 기준은 다르다. RIP는 홉의 갯수, OSPF는 대역폭, EIGRP는 다양한 값들을 연산해 나온 값을 코스트로 활용한다.
- Cost가 같다면 Equal-Cost Multi-Path, ECMP를 사용해 동일한 값을 가진 경로를 활용해 트래픽을 분산한다.
- 정리하면 LPM, AD, Cost, ECMP순으로 정보 우선순위를 매긴다.

### 라우팅 설정

- 다이렉트 커넥티드라면 라우터는 L2통신만을 이용해 목적지에 도달할 수 있다.
- 다이렉트 커넥티드는 외부 네트워크로 나가기 위한 첫번째 길목이다. 즉, 다이렉트 커넥트드 정보가 잘 못 입력되면 네트워크는 고립된다.
- 다이나믹 라우팅에서, 라우팅 프로토콜은 보통 유니캐스트 라우팅 프로토콜을 말한다.

### 브로드캐스트 컨트롤

1. 라우터는 멀티캐스트 정보를 습득하지 않고, 브로드캐스트 패킷을 전달하지 않는다. 이를 두고 브로드캐스트/멀티캐스트 컨트롤이라고 부른다. 다른 네트워크에 브로드캐스트가 전파되지 않도록 한다.
2. 위의 원리를 활용해 브로드캐스트가 많이 발생하는 네트워크의 경우 네트워크를 분할해 브로드캐스트로 인한 부하를 줄일 수 있다.
3.

### 프로토콜 변환

1. 현대 네트워크는 이더넷으로 수렴되므로 이 역할은 많이 축소되었음
2. 과거에 LAN이 WAN기술로 변환되어야했는데, 이 역할을 라우터가 담당했음

- 3계층 헤더 정보를 확인하기 위해 2계층까지 벗겨내고, 3계층 주소를 확인한 후 2계층 헤더 정보를 새로 만들어 내보낸다.
- 이를 이용해 서로 다른 프로토콜간 중재가 가능해진다. 어떤 프로토콜을 사용해 통신할지를 새로 정의해서 보낼 수 있으니까

# 6장 4계층

1. 포트(프로세스의) 번호, 시퀀스 번호, ACK 번호 등이 속한다.
2. 통신의 방향성, 순서와 같은 통신 전반에 대한 관리
3. 2번과 같은 정보들을 세션테이블에 보관하여 컨트롤하며, 4계층 이상에서 동작하는 장비들은 세션 테이블을 가진다.
4. 로드 밸런서, 방화벽과 같은 장비를 세션장비라고 부르기도 한다.
5. 세션 장비의 최우선 고려사항 3요소
   a. 세션 테이블
   b. symmetric(대칭) 경로 요구
   c. 정보 벼경(로드 밸런서의 경우 IP주소와 L7로드밸런서의 애플리케이션 프로토콜 정보 변경 등)

### 로드 밸런서

1. 4계층 이상에서 동작
2. 로드 밸런서는 웹이나 어플리케이션 뿐 아니라, FWLB(방화벽 로드밸런싱), VPNLB(VPN 로드밸런싱) 등 다양한 서비스를 위해 사용가능하다.
3. L4와 L7에서 동작하며, 현대의 로드밸런서는 보통 L4와 L7을 모두 지원한다. 4계층 정보만 가지고 로드밸런싱하면 4계층 로드밸런싱이라고 불리는 것 뿐이다. TCP, UDP 정보를 기반으로 동작하며, 특히 포트번호가 주로 사용된다.
4. L7 로드밸런싱은 애플리케이션 프로토콜 정보를 기반으로 동작하며, 이런 장비를 ADC(application delivery controller)라고 부른다. 프록시의 역할을 수행할 수 있고, Nginx의 리버스 프록시와 유사한 동작을 한다.

### L4 스위치

1. 로드 밸런싱 기능이 있는 스위치를 이른다.
2. 재부 동작은 4계층 로드 밸런서이지만, 외형은 스위치와 같이 여러개의 포트를 지닌다.
3. 부하분산, 성능 최적화, 리다이렉션을 제공한다.
4. 가상 서버, 가상 IP, 리얼 서버, 리얼 IP를 가지고 있는데, 사용자는 가상 IP를 바라보고 서비스를 이용하고 L4스위치는 요청을 받아 리얼 IP로 보내 서비스를 수행한다.

### ADC

1. 애플리케이션 계층에서 동작하는 로드밸런서
2. 대부분의 ADC는 L4스위치의 기능을 포함한다.
3. 온갖 동작이 가능하다. failover, 리다이렉션, 캐싱, 압축, 콘텐츠 변환, 인코딩 변환, WAF, HTML, XML 검증 및 변환을 수행할 수 있다.

### L4스위치 vs ADC

1. L4스위치는 4계층 정보만을 이용해 DoS를 어느정도 방어 할 수 있고, TCP 세션 재사용과 같은 보안 및 성능을 높여주는 기능도 수행할 수 있다.
2. ADC에서 웹서버 대신 압축을 수행해 부하를 낮출 수 있다. 하드웨어 가속 등 성능 최적화를 위한 ADC의 솔루션은 다양하다.
3. ADC에는 SSL 가속 카드가 내장되어 있는 경우가 많다. 리버스 프록시처럼 웹서버와의 통신은 일반 HTTP로, 외부통신은 자신이 HTTPS로 수행해 부하를 낮춰주기 위함이다.

### 방화벽

1. 트래픽을 사전에 정해진 정책에 따라 허용하거나 차단하는 장비
2. 일반적으로 3,4계층에서 동작하고 세션을 인지, 관리하는 SPI(Stateful Packet Inspection)엔진을 기반으로 동작하는 장비를 방화벽이라고 부르지만, 네트워크에서 보안을 제공하는 모든 장비를 방화벽이라고 부르기도 한다.
3. 방화벽은 NAT와 유사하게 세션 정보를 장비 내부에 저장한다. 세션 정보는 패킷이 외부로 나갈 때 저장되는데, 이를 통해 패킷의 입출력시 외부에서 출발한 패킷인지, 내부에서 출발한 것인지 가려낼 수 있다.
4. 방화벽의 기본정책은 나가는 모든 패킷을 허용하고, 외부의 모든 패킷을 차단하는 것이다. 세션 테이블의 존재로 세션의 방향성을 파악하는 것만으로도 복잡도를 많이 줄일 수 있다.

### 4계층 장비 통과의 유의점

#### 세션만료

1. A와 B사이에 세션이 연결된다. A와 B사이에는 세션테이블이 있는 장비가 있다고 가정하자. 그 장비의 세션테이블 값이 만료(세션 테이블은 메모리에 적재되므로 무한대로 저장할 수 없다. 만료시키던, 회전시키던 해야한다)된 후에 A와 B간의 통신이 시작되었다고 생각해보자.
2. 이 때, A와 B는 통신할 수 없게 된다. 세션 테이블에 정보가 없는데 뜬금없이 ACK패킷이 들어왔기 때문이다. 각종 설정을 통해 강제로 통과시키게 할 수 있지만, 이런 식의 해결은 보안에 취약하며 의도된 사용법도 아니다.
3. 세션 장비의 타임아웃 시간을 애플리케이션에 맞게 설정하는 방법도 있고, 포트번호나 IP주소마다 별도의 세션 만료시간을 설정할 수도 있다.
4. 세션 테이블에서 세션이 만료될 때마다 양측 통신 당사자에게 세션 종료를 통보할 수도 있다.
5. 소프트웨어 개발자 입장에서는, 더미 패킷을 주기적으로 보내 세션 테이블에서 삭제되는 것을 막는 방법이 있다. 이는 매우 흔하게 사용되는 방법이다.

#### 비대칭 경로

1. 인바운드 패킷과 아웃바운드 패킷이 같은 장비를 통과하는 것을 대칭 경로, 다른 장비를 통과하는 것을 비대칭 경로라고 한다.
2. 세션 장비는 상술했듯 세션 테이블이 있기 때문에 비대칭 경로로 통신하면 문제가 생긴다.
3. 비대칭 경로가 생기더라도 해결할 수 있다(네트워크의 효율성 등을 고려해 비대칭으로 설계하기도 한다).
4. 첫 번째 방법은 각 장비의 세션테이블을 동기화 시키는 것이다.
5. 두 번째 방법은 아웃바운드 기록이 없는데 인바운드 패킷이 도착한 경우 동일한 수준에 있는 다른 세션 장비로 패킷을 포워딩해서 처리하는 것이다. 다른 장비에는 그 패킷의 아웃바운드 정보가 있으므로 통신이 가능해진다.

#### 하나의 통신에 복수의 세션

1. 하나의 통신을 위해 하나의 세션이 사용되는 경우가 대부분이지만, 특별한 목적으로 복수의 세션을 사용하기도 한다.
2. FTP는 컨트롤 프로토콜과 데이터 프로토콜이 완전히 분리되어 있다. 오래된 프로토콜이라서 그렇다.

# 7장

## NAT/PAT

1. 여러개의 IP를 하나의 IP로 변환하기도 한다. 이의 공식적인 명칭은 NAPT이지만 실무적으로 PAT라는 말을 더 많이 쓰고 그냥 크게 묶어서 NAT로 부르기도 한다.
2. 사설, 공인 여부는 상관없다. 그냥 변환하면 다 NAT다. 그래서 IPv4 <-> IPv6간 변환인 AFT(Address Family Translation)도 NAT의 일종이다. 어쩄든 가장 많이 사용되는 구간은 사설 IP에서 공인 IP로 전환되는 경우이다.

### NAT가 필요한 이유

1. IP주소 고갈문제 해결
2. 보안 강화

- 외부 구간에서 내부 장비의 IP가 숨겨진다.
- 내부에서 출발한 통신만 허용한다(방화벽)

3. IP주소를 중복적으로 사용할 수 있게 해준다

- 네트워크간 분할되어있으므로 같은 IP주소를 써도 충돌이 없다.
- 사설네트워크간 직접 연결할 경우 충돌을 방지하기 위해 출발지와 도착지를 한꺼번에 변환하는 Double NAT를 수행한다.

4. 불필요한 설정 변경을 줄인다.

- 내부망 설정 변경할 필요없이 외부에서 할당받는 IP주소만 바꾸는 식으로 이전이 가능하다.

### NAT는 단점도 많다.

1. IP가 변환되는 문제때문에 트러블슈팅이 힘들어진다.
2. 애플리케이션을 개발할때 더 많은 고려사항이 생긴다.
3. NAT로 인한 오버헤드를 극복하기 위한 기술들이 출시되면서 복잡성이 더욱 증대되었다.

## NAT의 동작 방식

1. 출발 패킷이 NAT장비에 도달하면 공인IP주소로 NAT한다.
2. 변경 전후의 IP주소는 NAT테이블에 저장된다 <- 아주 궁금했던 부분!

## PAT의 동작방식

1. PAT가 다른 점은 포트까지 변환한다는 것 밖에 없다. 마찬가지로 포트 변환정보도 NAT테이블에 기록되어 응답을 돌려받았을 때 변환할 수 있게 한다.

## PAT의 특징

1.  IP주소 뿐 아니라 서비스 포트까지 함께 변경해 하나의 IP만으로도 다양한 포트 번호를 사용해 사용자를 구분할 수 있다.
2.  만약 서비스 포트가 모두 사용중이거나 재사용이 불가능하다면 PAT가 제대로 동작하지 않는다. 따라서 동시사용자가 많을 때는 PAT에서 사용하는 공인 IP주소를 Pool로 구성해야한다.
3.  PAT는 내부에서 밖으로 나가는 통신만 가능하다. 외부에서 요청이도달할경우 목적지를 특정할 수 있는 수단이 없기 때문(NAT테이블에 포트정보가 없으므로 드랍)

## SNAT/DNAT

1. Source NAT(출발지 변환)
2. Destination NAT(도착지 변환)
3. SNAT와 DNAT는 어느 하나만 수행되는 것이 아니고 SNAT로 갔으면 돌아오는 입장에서는 DNAT되어야하는 것이다.

## SNAT의 사용례

1. 사설망에서 공인망으로 통신할 경우
2. 대외계와 직접연결하더라도 SNAT를 통해서 보안수준을 높일 수 있다.
3. 대외사와 사설 IP가 겹치는 경우를 막을 수 있다. 1번과 비슷하지만 변환되는 주소가 공인일 필요가 없다.
4. 로드밸런서를 사용하는 경우(이는 12장에서 자세히 다룬다고 함)

## DNAT의 사용례

1. 로드밸런서에서 많이 사용된다. 사용자는 VIP로 요청을 보내고 로드밸런서는 도착지를 DNAT하니까
2. 대외망 연결들을 DNAT로 쉽게 관리할 수 있다. 대외사마다의 IP를 특정 IP대역으로 NAT하는 식이다. 사내IP와 중복되는 IP가 있더라도 중복도 피할 수 있다.

## 동적 NAT와 정적 NAT

1. 사전에 출발지와 목적지가 모두 정해지면 정적, 하나라도 정해지지 않고 동적으로 변경되면 동적 NAT라고 부른다.
2. 동적 NAT는 IP주소가 Pool에서 결정되므로 생긴다. 출발지나 목적지 중 최소한 한곳이 Pool이나 Range로 설정되어있다. NAT가 필요할 때 IP풀에서 어떤 IP로 매핑 될 것인지 판단해 NAT를 수행하는 시점에 NAT테이블을 만들어 관리한다. NAT테이블 타임아웃도 존재한다. 즉 서비스 설계를 잘해야한다.
3. 정적 NAT는 출발지와 목적지 매핑관계가 애초에 정해져있는 것이다. 즉 서비스방향에 따른 고려가 필요없다. NAT테이블이 미리 생성되어있는 것이다. NAT테이블 타임아웃도 없다.

# DNS

### 데이터 프로토콜과 컨트롤 프로토콜

1. 데이터 프로토콜은 실제로 데이터를 실어나르는 프로토콜
2. 컨트롤 프로토콜은 데이터 프로토콜이 잘 동작하도록 도와주는 프로토콜
3. TCP/IP 프로토콜을 도와주기 위한 주요 컨트롤 프로토콜들로 ARP, ICMP, DNS가 있다.

### 내부적인 DNS도 있다

내부 서비스간 연결에도 이름풀이를 사용할 수 있다.
내부와 외부 DNS는 당연한 말이지만 분리되어 있다.

### DNS구조 s및 명칭

www.naver.com으로 예를 들면,

1. 맨 뒤에 생략된 루트(. )
2. com(top-level)
3. naver(second-level)
4. www(third-level)

과 같이 뒤에서 부터 앞으로 해석된다. .으로 구분된 각 부분을 '계층'이라고 부르고 최대 128계층까지 구성할 수 있다. 도메인네임의 전체 길이는 255바이트까지 사용할 수 있다. 알파벳, 숫자, - 만사용할 수 있고 대소문자 구분은 없다.

### 루트 도메인

DNS서버는 사용자가 쿼리한 도메인에 대한 값을 가지고 있거나, 없으면 루트 도메인을 관리하는 루트 DNS에 쿼리하게 된다. 루트 DNS는 총 13개가 존재한다. DNS서버를 설치할때 루트 DNS에 대한 정보는 기본적으로 가지고 있으므로 별도로 루트DNS정보를 설정할 필요는 없다.

### TLD(Top-Level Domain)

TLD는 IANA에서 정한 총 6가지 유형으로 구분된다.

1. Generic(g)
2. country-code(cc)
3. sponsored(s)
4. infrastructure
5. generic-restricted(gr)
6. test(t)

괄호친 약어에 TLD를 붙여서 부르는 식이다. gTLD, sTLD등

#### gTLD

가장 익숙한 TLD일것이다. 세글자 이상으로 구성되며 별 제한없이 사용된다.
com(일반 기업), edu(교육), gov(정부), int(국제), mil(미연방 군사기관), net(네트워크 관련 기관), org(비영리)등이며 필요에 의해 더 만들어지고 있다.

#### ccTLD

두 글자의 국가 코드. kr등과 같다. cc가 TLD일 경우 second-level domain은 gTLD를 사용하는 것이 일반적인데, gTLD를 두글자로 줄여 사용하거나(co.kr), 호주와 대만처럼 gTLD를 그대로 사용하기도 한다(com.au)

#### sTLD

특정 목적을 위한 스폰서를 둔 최상위 도메인. 민족 공동체, 전문가 집단, 지리적 위치등이 될 수 있다.
.aero, .asia, .edu, .museum등이 속한다.

#### Infrastructure

인프라 식별자 공간 지원 전용
단 하나 .arpa 뿐이다.
.arpa는 인터넷 안정성을 유지하기 위해 새로운 모든 인프라 하위 도메인이 배치될 도메인 공간 역할을 한다.

#### grTLD

특정 기준을 충족하는 사람이나 단체가 사용하는 도메인
.biz, .name .pro등이 있다.

#### tTLD

개발 프로세스중에 테스트 목적으로 사용
.test이다.

## DNS동작 방식

1. 로컬에서 도메인과 IP주소를 관리하는 파일을 hosts파일이라고 한다. 이를 설정해두면 해당 도메인 리스트는 항상 DNS캐시에 저장된다.
2. 도메인을 쿼리하면 DNS서버에 질의하기 전에 로컬 캐시부터 확인한다.
3. DNS캐시에는 DNS질의를 통해 획득한 동적 정보와 hosts파일로 부터 유래한 정적 캐시가 함께 있다.

#### DNS의 입장에서

1. 전 세계 도메인 정보를 한곳에 저장할 수 없기 때문에, 자신이 가진 도메인 정보가 아니면 다른 DNS에 질의한다.
2. 자신이 가진 정보가 아니면 루트 DNS에 쿼리하고, 루트는 쿼리한 TLD의 값을 확인해 해당 TLD를 관리하는 DNS가 어디인지 응답한다.
3. 그 응답을 받은 DNS서버는 응답받은 정보를 토대로 다시 DNS서버에게 쿼리한다.
4. 루트 DNS부터 차례대로 내려와 최종값을 클라이언트에게 전달하는 식이다.
5. 클라이언트에게 처음 질의를 받은 DNS가 응답을 돌려줄 책임자가 된다.

#### 재귀적 쿼리 vs 반복적 쿼리

로컬 DNS서버가 루트에 한번 질의하고, 루트가 다시 질의해야할 정보를 알려주고 이런 식으로 반복되는 것을 반복적 쿼리라고 부른다. 즉, 로컬 DNS서버가 DNS서버들에 대하여 클라이언트가 되는 것이다.
재귀적 쿼리는 클라이언트(호스트)와 로컬DNS간에 사용된다.

#### 마스터와 슬레이브

DNS서버는 마스터와 복수의 슬레이브로 나눠져있다. 쿼리 응답 우선순위는 마스터가 더 좊지는 않고 둘 다 도메인 쿼리에 응답한다.

1. 마스터는 Zone파일을 직접 관리하는지 여부로 결정된다. 마스터는 존 파일을 직접 생성해 도메인 관련 정보를 관리한다.
2. 슬레이브는 존 파일을 복제해간다. 이를 두고 영역 전송(Zone Transfer)라고 한다.
3. 슬레이브를 만들 때 도메인을 복제해올 마스터 정보가 입력되어야 한다.
4. 마스터는 영역 전송이 가능한 슬레이브를 명시할 수 있다.

#### DNS의 마스터와 슬레이브는 일반적인 이중화가 아니다.

일반적으로 이중화 전략이라고하면 마스터가 죽었을때 그대로 서비스를 하기 위함이지만, DNS의 경우에는 액티브가 죽었을 때 또다른 액티브나 스탠바이가 정상응답 할 수 없다. 마스터에 문제가 발생하고 일정시간이 지났을 때 이러한 경우가 생기는데, 이를 만료시간이라고 부른다. 만료 시간안에 영역 전송이 이뤄지지 않으면 슬레이브의 Zone 정보는 사용할 수 없게 되기 때문이다. 따라서 만료시간 안에 슬레이브를 마스터로 전환해내야 서비스 장애를 막을 수 있다. 만료시간은 SOA레코드에 설정된다.

#### DNS의 주요 레코드

1. A
   기본 레코드. 도메인 주소와 IPv4주소의 매핑. `1:1 매핑이다. 동일한 도메인을 가진 A레코드를 여러개 만들어 다른 IP주소와 매핑이 가능하다.
   반대의 경우로, 다수의 도메인에 하나의 IP주소를 매핑하는 것도 가능하다.
2. AAAA
   A레코드와 역할은 완전히 같다. 다만 IPv6이다.
3. CNAME
   별칭 레코드. A레코드가 도메인 네임에 IP주소를 매핑한다면 CNAME은 별칭에 도메인 네임을 매핑한다. CNAME의 대표적인 예는 www이다.이는 효율성을 위한 것인데,
   예를 들어 www.naver.com과 naver.com이 각각으로 취급된다면 ip주소를 바꿀 때 둘을 모두 바꿔야 할것이다. 그런데 www.naver.com이 naver.com을 매핑하고 있다면 naver.com의 IP주소만 변경해도 연쇄적으로 www.naver.com도 정상적으로 바뀐것과 마찬가지인 것이다.
4. SOA(Start Of Authority)
   도메인 영역에 대한 권한을 나타내는 레코드. 도메인 영역 선언시 SOA는 필수 항목이다. 도메인 영역에 SOA레코드를 만들지 않으면 도메인은 넹미 서버에서 정상적으로 동작할 수 없다. 그 밖에 도메인 관리에 필요한 속성값들을 설정한다. 도메인 동기화에 필요한 타이머나 TTL 값과 함께 도메인의 네임서버나 관리자의 정보도 SOA 레코드에 설정한다.
5. NS
   도메인에 대한 권한이 있는 네임서버 정보를 설정하는 레코드. 하위 도메인에 대한 권한을 다른 네임 서버로 delegate하는 역할로도 많이 사용된다.
6. MX(Mail eXchange)
   메일 서버를 구성할 때 사용되는 레코드. 해당 도메인을 메일 주소로 갖는 메일 서버를 MX레코드에 선언한다. 우선순위 값이 있어 다수의 MX레코드 선언이 가능하다. 우선 순위가 높은 서버로 메일을 보내고 실패하면 다음 순서의 MX레코드의 서버에서 처리하는 식이다.
7. PTR
   A레코드와 반대로 IP주소에 대한 질의를 도메인 주소로 응답하기 위한 레코드이다. 즉, 역방향 조회용 레코드이다. A레코드와 달리 하나의 IP주소에 대해 하나의 도메인 주소만 가질 수 있다. 즉, 하나의 IP에 대한 PTR레코드는 오직 하나이다.
8. TXT
   도메인에 대한 설명 같은 간단한 텍스트를 입력할 수 있는 레코드이다. 공백 및 대소문자를 허용한다. 최대 255자이다.

#### DNS에서 알아두면 좋은 내용

1. 도메인 위임(DNS Delegation)
   도메인은 그 도메인에 대한 정보를 관리하는 네임 서버를 지정하지만, 도메인 내의 모든 레코드를 그 네임서버가 직접 관리하지 않고 일부 영역에 대해서는 다른 곳에서 레코드를 관리하도록 위임하기도 한다. 이러한 방식을 도메인 위임이라고 한다. CDN이나 GSLB가 대표적인 경우이다. 도메인은 계층 구조여서 특정 계층의 레코드를 위임하면 해당 레코드의 하위 계층은 함께 위임된다. 즉, 도메인 위임 기능을 쓰면 특정 영역을 다른 네임서버에서 관리할 수 있는 권한을 위임하게 된다. 꼭 CDN이나 GSLB뿐 아니라 계열사에서 특정 도메인을 분리하거나 하는 등의 용도로 쓸 수 있다.

2. TTL
   DNS에 질의해 응답받은 결괏값을 캐시에서 유지하는 시간을 뜻한다. 너무 작아도 자주 DNS서버에 요청해 좋지 않고, 너무 크면 변경된 내용이 적용되는데 오랜 시간이 걸린다. 만약 IDC이전이나 공인 IP, 서비스의 변경 등이 예정되어있다면 미리 DNS의 TTL을 극도로 줄여 변경을 바로 적용하는 것이 좋다. 윈도우에선 기본 1시간이고 리눅스에선 3시간이다.

- 참고
  - refresh: 보조 네임서버에서 영역 전송을 통해 정보를 받아오는 주기를 뜻하고
  - retry: 보조 네임 서버가 주 네임서버로 접근이 불가능할 때 재시도하는 주기
  - expire: 보조 네임 서버가 주 네임 서버로부터 도메인 정보를 받아오지 못할 때 유지되는 시간. 해당 시간 동안 도메인 관련 정보를 받아오지 못하면 주 네임서버에서 삭제된 것으로 간주하고 보조 네임 서버에서도 삭제한다.

3. 화이트 도메인
   정상적으로 발송하는 대량 이메일이 RBL 이력으로 간주되어 차단되는 것을 예방하기 위해 사전에 등록된 개인이나 사업자에 한해 국내 주요 포탈 사이트로의 이메일 전송을 보장해주는 제도. 한국 인터넷 진흥원(KISA)에서는 불접적으로 발송되는 스팸메일을 차단하는 활동을 하는데, 이를 위해 정상적인 도메인을 인증, 관리하는 제도가 '화이트 도메인'이다. 반대로 불법 스팸 메일을 발송하는 사이트를 실시간 블랙리스트로 등록해 메일 발송을 제한한다. 이 실시간 블랙리스트를 RBL(realtime blocking list)라고 한다. 화이트 도메인을 등록하려면 KISA RBL사이트에서 화이트 도메인으로 등록해야한다. 이를 위해선 사전에 해당 도메인 레코드에 SPF(sender policy framework)레코드가 설정되어있어야 한다. SPF레코드를 통해 사전에 메일 서버 정보를 공개하면 수신 측 메일 서버에서는 해당 도메인을 통해 발송된 메일이 실제 메일 서버에 등록된 정보와 일치하는지 확인 할수 있다. 메일 정보와 도메인의 SPF정보가 일치하지 않을 때 비정상적인 이메일 서버에서 전송된 것으로 간주하 스팸 처리 등을 할 수 있다. SPF레코드를 작성하려면 TXT레코드를 사용한다.

4. 한글 도메인
   도메인 주소는 영문 뿐 아니라 http://한국인터넷진흥원.한국 처럼 한글 주소로 만들 수도 있다. 도메인을 영문 외의 언어로 등록하기 위해선 DNS에서 해당 문자열을 Punycode로 변경하고 이 Punycode로 DNS에 도메인을 생성해야한다. 아스키로 인코딩된 형태이다. Punycode는 RFC 3492에 정의되어있다.

## GSLB(Global Server/Service Load Balancing)

1. GSLB는 DNS와 동일하게 도메인 쿼리에 응답해줄 수 있다.
2. 로드밸런서처럼 헬스체크가 가능하다.

위와 같은 이유로 인텔리전스 DNS라고도 불린다.

### GSLB의 동작방식

1. DNS질의
2. LDNS(Local DNS)가 NS서버를 찾기 위해 root부터 순차 질의 시작
3. NS서버에게 도메인 질의
4. DNS서버가 GSLB에 도메인을 위임했으므로 GSLB서버가 NS서버라고 LDNS에 응답
5. LDNS가 GSLB에게 질의
6. GSLB가 자신에게 설정된 분산 설정에 따라 IP주솟값을 응답
7. LDNS가 클라이언트에게 응답

### GSLB구성 방식

1. 도메인 자체를 GSLB로 사용

- 도메인에 대한 모든 레코드를 GSLB에서 설정. 즉 GSLB자체가 도메인 네임 서버 역할을 한다. 이경우 헬스체크 기능이 불필요할 뿐 아니라 모든 레코드에 대한 질의가 GSLB를 통에 이루어지므로 GSLB에 부하를 주게된다.

2. 도메인 내의 특정 레코드만 GSLB사용

- 모든 레코드에 대해 GSLB를 사용이 필요한 경우는 별로 없다. GSLB가 필요한 레코드만 처리하도록 설정하는데,
  특정 레코드에 대해서 GSLB로 처리를 이관하는 경우는 두가지다.
  a. 별칭(CNAME)사용
- 실제 도메인과 다른 별도의 레코드로 GSLB에 등록한다. GSLB를 운영해주는 외부 사업자가 있거나 GSLB를 사용해야 하는 도메인이 매우 많은 경우, 별도의 GSLB를 운영하기 위해 사용된다

- DNS서버에 CNAME레코드로 CDN과 같은 외부 GSLB를 지정하면 CNAME레코드의 값으로 등록된 FQDN을 GSLB로 재질의해 서버를 찾아가게 된다.
  즉, CNAME값으로 등록되는 FQDN이 GSLB가 네임 서버로 등록된 도메인을 사용해 GSLB로 재질의하게 만드는 것이다. (그림 7-49로 이해하기 쉬움)

b. 위임(NS사용)

- 계층적으로 GSLB를 이용한 FQDN를 관리할 때 사용된다.
- 실제 도메인과 동일한 레코드를 사용하여 도메인 전체를 위임하는 방식이 대표적이다.
- NS 주소를 GSLB로 알려주고 GSLB가 질의한 도메인의 값을 알려주는 방식(그림 7-50)

CNAME사용과 NS사용은 혼용해서 사용되기도 한다.

### GSLB 분산 방식

분산 방식은 장비에 따라 조금씩 차이가 있을 수 있다. 분산 알고리즘은 라운드 로빈이나 최소 접속, 해싱 등 다양하다.
보통 두 가지의 헬스체크 방법을 제공한다.

1. 서비스 응답 시간/지연(RTT/Latency)
2. IP에 대한 지리(Geography)정보(가장 가까운 사이트로 서비스 분산)

## DHCP

1. DHCP는 네트워크 정보 동적 할당 프로토콜이다.
2. 보통 운영망과 같은 곳은 정적할당 받아 사용하나, 사무실의 사용자 등은 동적할당 받아 사용한다.
3. IP주소, 서브넷 마스크, 게이트웨이, DNS정보를 자동으로 할당받는다.

#### 프로토콜

1. BOOTP(Bootstrap Protocol)라는 프로토콜을 기반으로 한다. DHCP와 BOOTP는 비슷하지만 BOOTP에는 없는 몇가지 기능이 추가된 형태이다. DHCP와 BOOTP는 호환된다.
2. DHCP는 서버와 클라이언트로 동작하며, 클라이언트의 서비스 포트는 68(bootpc), 서버의 서비스 포트는 67(bootps)이다. DHCP에 대한 명세는 RFC 2131에 기술되어 있다.

#### DHCP 동작방식

아직 IP를 사용할 수 없으므로 UDP로 주고 받는다.

1. DHCP Discover

- DHCP클라가 DHCP서버를 찾기 위해 브로드캐스트 전송

2. DHCP Offer

- DHCP서버가 DHCP클라이언트에게 IP주소를 제안. DHCP서버가 가지고 있는 IP리스트인 DHCP IP Pool에서 하나를 선택한다.
- 특정 클라이언트(MAC, IP)의 요청이 오면 고정값을 할당하도록 설정할 수도 있다.
- 단지 IP주소 뿐 아니라 서브넷, 게이트웨이, DNS정보, IP주소 임대 시간, DHCP서버 자신의 정보 등을 포함해 전송한다.
- 클라이언트가 IP주소를 사용하는 도중에 IP임대시간 만료가 도래하면 원칙적으로 IP는 수거되고 1번과정부터 반복해야하지만 실제로 그런 반복작업을 하지는 않는다.갱신 과정을 거쳐 사용중인 IP주소가 다시 Pool에 반환되지 않도록 할 수 있다. 임대시간의 50%가 경과하면 갱신과정을 수행한다. 50%시점에 갱신이 실패하면 75%시점에 다시 시도한다. 갱신은 유니캐스트로 진행되므로 초기 임대과정에 비하여 절차가 짧고 쓸모없는 브로드캐스트가 발생하지 않는다. 권고되는 임대시간이 따로 존재하지는 않는다. 클라이언트가 어느정도 고정되어있다면 임대시간이 길어야 적절할 것이고, 불특정 다수의 클라이언트가 자주 바뀐다면 임대시간도 짧게 해 사용된 IP가 빨리 반환되도록 하는 것이 옳을 것이다.

3. DHCP Request

- 제안받은 IP주소와 DHCP 서버 정보를 포함한 DHCP요청을 브로드캐스트 전송. DHCP서버가 여러대일 경우를 대비하여 브로드캐스트하는 것이다.
- 제안을 보낸 서버는 자신이 보낸 제안의 응답임을 확신할 수 있으므로 자신이 보낸 패킷에 대해서만 응답한다.

4. DHCP Acknowledgement

- DHCP크라가 IP주소를 사용하겠다고 응답하면 서버가 해당 IP를 어떤 클라이언트가 언제부터 사용했는지 정보를 기록하고, DHCP Request메세지를 정상적으로 수신했다고 응답
- 내용은 DHCP Offer와 동일

##### DHCP Starvation

앞서 언급한 것 처럼 DHCP는 Pool에서 IP를 꺼내 할당하는데, 공격자가 가짜로 대량의 IP할당을 요청하게 되면 Pool이 비게 되어 정상적인 할당이 불가능하게 된다.

# 8장

## 서버네트워크 설정 및 확인

### 라우팅 관련 명령어

#### 리눅스

1. 전체 네트워크 서비스 재시작
   systemctl restart network.service
2. 네트워크 서비스 중 특정 인터페이스 재시작
   ifdown ifcfg-eth0
   ifup ifcfg-eth0
3. 네트워크 인터페이스의 설정값 및 상태 확인
   ifconfig(CentOS 7.0이상부터는 net-tools를 설치해야 동작. net-tools는 대부분의 리눅스에서 사용된다)
4. 3번을 net-tools없이 유사하게 확인
   ip address
5. 송수신되는 패킷 정보 알아보기
   ip -s link
6. 라우팅 테이블 확인
   - ip route
   - netstat -r -n
     위 두 명령어가 완전히 같지는 않다. 필요한 정보에 따라 선택하자!
7. 라우팅 테이블 추가(서버 네트워크 인터페이스가 복수일 경우 필수)
   - route add {-host | -net} Target[/prefix] [gw GW] [metric M] [[dev] If]
   - ip route add
     라우팅 테이블에 우선순위를 부여해 목적지 게이트웨이를 active-standby로 구성할 수 있다. 더 높은 우선순위가 있는 라우팅 테이블이 active가 되고, active가 실패할 경우 active-standby가 failover하는 식이다.
8. 라우팅 테이블 삭제
   route del {-host | -net} Target[/prefix] [gw GW] [metric M] [[dev] If]
   라우팅 테이블이 삭제된다고 하더라도 디폴트 라우팅이 남아있다면 외부와 통신할 수 있다. 디폴트라우팅 마저 삭제되었다면 원격지 통신은 불가능하고 네트워크 카드가 속한 로컬 네트워크 통신만 가능하다.
9. 영구적 라우팅 설정(7,8은 재부팅시 원복임)
   (영구적 라우팅은 리눅스 종류별로 다름)

### Windows

1. 네트워크 연결창
   실행 -> ncpa.cpl
2. 설정정보확인
   ipconfig(기본정보)
   ipconfig /all(상세정보)
3. 라우팅 확인 및 관리
   route print
   route add
   route delete
   route change

## 서버의 라우팅 테이블

서버도 외부 네트워크와 통신하기 위해 라우팅 테이블을 가지고 있다. 별도 설정 없이도 네트워크 정보를 설정할 때 IP, Subnet Mask, Default Gateway IP 주소를 입력하게 되는데, 이 때 디폴트 라우팅이 라우팅 테이블에 자동 등록된다. 이 디폴트 라우팅을 통해 네트워크 기본 설정만 마치면 내부 & 외부와 원활한 통신을 할 수 있게 된다.

라우팅 테이블의 항목은 다음과 같다.

1. 목적지
2. 서브넷
3. 게이트웨이(선택된 목적지로 가기 위해 서버에서 선택하는 넥스트 홉)
4. 인터페이스
5. 우선순위(메트릭, 동일한 라우팅 테이블이 두개 이상 존재할 때 어떤 라우팅 테이블을 선택할지 결정하는 값. 낮을 수록 우선수위가 높다)

### 네트워크 확인을 위한 명령어

1. ping(Packet InterNet Groper)
   - 주요 옵션: -c(count), -i(interval), -I(interface), -s(packetsize)
   - 윈도우는 옵션명이 조금 다름
2. tcping(윈도우)

   - 주요 옵션: -n(count) -t(중지 될 때까지 지정된 호스트로 ping 지속 전송) -i(interval) serverport(80 default)
   - ping은 만능이 아니다. 살아있는 것 외에는 확인할 수 없고 ping자체가 막혀있을 수도 있다. 예를 들어 네이버도 핑이 막혀있다.
   - tcping은 ping과 달리 TCP포트를 통해 확인한다. 따라서 '서비스 자체'가 살아있는지 확인할 수 있다.
   - tcping은 기본 명령어가 아니다. 인터넷에서 다운받아 설치하자

3. traceroute(리눅스)/tracert(윈도우)
   - 목적지까지의 경로를 확인하는 명령어
   - 통신에 문제가 있을 때 어느 구간부터 문제가 발생했는지 알아 낼 수 있다.
   - 윈도우는 ICMP기반 탐색, 리눅스는 UDP를 기반으로 탐색
4. tcptraceroute
   - 출발지와 목적지를 확인하는 것은 3.과 같지만 실제 서비스 포트를 이용해 경로를 추적한다.
   - 매우 유용하다고 생각된다. 사실상 TCP통신을 다루는 경우가 대부분이므로
   - tcptraceroute는 설치해서 사용해야한다. 각 운영체제별 설치법을 통해 설치하자
5. netstat(network statistics)
   - 다양한 네트워크 정보 총체적으로 전달
   - 서비스 포트 상태를 확인하는 용도로 가장 많이 사용된다. 현재 서버에서 특정 서비스가 정상적으로 열려있는지, 또는 외부 TCP 세션이 정상적으로 맺어져있는지, 서비스가 정상적으로 종료되고 있는지 등을 확인할 수 있다.
   - 서비스 문제가 생겼을 기본 정보를 확인할 수 있게 해준다.
   - 주요 옵션: -a(모든 연결과 수신 대기 포트), -n(주소와 포트번호를 숫자로 표시), -r(라우팅 테이블 표시), -i(인터페이스별 입출력 패킷 통계), -s(네트워크 통계), -p(PID와 프로그램 이름), -t(tcp만 출력), -4/6(IPv)
   - 사용례: netstat -ant | grep LISTENING(모든 연결과 수신 대기 정보를 숫자로 표기해 출력하면서 LISTENING인 것만 필터링)
6. ss(socket statistics)
   - 기존의 netstat을 대체할 뿐 아니라 다양한 옵션을 제공해 더 많은 정보를 확인할 수 있다(게다가 더 짧네)
   - 주요 옵션: -a(전체 소켓), -l(listening중인것만), -i(자세한 정보), -p(현재 소켓에서 사용중인 프로세스), -n(서비스 명이 아닌 실제 포트 번호로 서비스 포트 표기), -4, -6, -s(프로토콜 별 통계), -t/u(tcp 혹은 udp지정)
   - state(연결상태)로 필터링이 가능하다. 상태값은 매우 다양하다. 예를 들어 established, closed, closing, listen등이다.
   - 사용례: ss -lp | grep http, ss -it4 state connected
7. nslookup

   - 도메인 관련 내용을 질의해 결괏값을 전송 받을 수 있는 명령
   - 도메엔에 매핑된 ip정보를 확인하기 위해 사용
   - nslookup은 대화형 모드 등을 제공하므로 사용례는 요약에 적지 않겠다.

8. telnet(tele network)
   - 매우 오래된 표준 프로토콜
   - 오직 평문만을 사용하므로 감청될 수 있다.
   - 대신 ssh사용이 권고된다.
   - 요즘엔 특정 서비스가 열려있는지 확인하는 용도 정도다.
9. ipconfig
   - 윈도우에서 사용하는 명령어
   - 주요 옵션: /all(모든 정보), /displaydns(DNS 캐시 정보), /flushdns(DNS 캐시 삭제), /registerdns(DNS 캐시 갱신), /release(모든 네트워크 연결 해제), /renew(모든 네트워크 연결 재연결), /showclassid(네트워크 어댑터 클래스 ID 표시), /setclassid(네트워크 어댑터 클래스 ID 설정)
10. tcpdump

- 네트워크 인터페이스로 오가는 패킷을 캡처
- 장애 처리나 패킷 분석이 필요할 때 자주사용
- 전체 패킷을 캡처하면 분석이 어려우니 보통 분석에 필요한 패킷만 필터링
- 주요 옵션: -i(인터페이스), src IP, dst IP, host IP, -n(호스트 네임을 실제 ip로), -nn(이름으로 표시되는 서비스 포트를 실제 포트 번호로), src port, dst port, port, tcp, udp, -c(출력 결과의 개수), -w(출력 파일명), -r(파일로 저장한 파일 출력), and, or, not
- 사용례: tcpdump -i eth0 tcp port 80, tcpdump -i eth0 tcp port 80 and host 172.16.10.10 -w dumpfile.pcap
- 근데 와이어샤크를 더 많이 사용함.tcpdump로 저장한 파일도 와이어샤크에서 볼 수 있음

# 9장

### 보안 3요소

- 기밀성 -> 인가된 자만 접근할 수 있음
- 무결성 -> 정확하고 완전하게 유지됨
- 가용성 -> 정보가 필요하면 획득할 수 있음

### Trust, Untrust, DMZ

- 트러스트: 외부로부터 보호받아야할 네트워크
- 언트러스트: 그냥 외부
- DMZ: 우리가 운영하는 내부네트워크이지만 신뢰할 수 없는 외부 사용자에게 공개해야하는 네트워크

### 네트워크 보안의 두 분야

- 인터넷 시큐어 게이트웨이
  - Trust or DMZ로부터 Untrust로 통신을 통제
  - 방화벽, SWG(Secure Web Gateway), Web Filter, Application Control, Sandbox등이 포함
- 데이터 센터 시큐어 게이트웨이
  - Untrust로부터 Trust 또는 DMZ로
  - 방화벽, IPS, DCSG(Data Center Secure Gateway), WAF(Web Application Firewall), Anti-DDoS등이 포함된다

### 정책적 구분

1. 화이트리스트

- 회사 내부망 등에서

2. 블랙리스트

- 문제가 있던던 패킷, IP등을 목록화시켜 데이터베이스를 만들어 방어. 공격 패턴(시그니처) 분석
- 시그니처 분석의 결과는 정탐, 오탐, 미탐으로 나뉜다.
- 보안정책을 섣불리 수립했다가 정상 패킷을 공격으로 간주하는 등(오탐)의 참사가 날 수 있으니 조심해야한다.
- 보안 정책이 정상이라도 데이터 자체가 없어 첫 공격이 가능한(제로 데이 어택)등이 가능할 수 있으니 주의하자
- 보안은 화이트리스트와 블랙리스트를 적절히 혼용해야한다.

### 네트워크 보안 장비들

DDoS-방화벽-IPS-WAF 처럼 여러 단계로 공격을 막도록 배치하게 됨

#### DDoS

1. 기존의 DoS자체는 한곳에서 공격이 일어나므로 정탐도 쉽고 방어도 비교적 쉬웠음
2. 그러나 DDoS는 다수의 봇을 사용해 분산 공격을 수행한다.
3. DDoS방어장비는 데이터 센터 네트워크 내부와 외부의 경계에서 공격을 방어한다. 볼류메트릭 공격을 우선 막기 위해서이다.
4. 볼류메트릭이란 회선사용량을 과도하게 발샏시켜 회선 사용 자체를 방해하는 공격이다. 그러므로 가장 바깥쪽에서 Mitigate해야한다

#### 방화벽

1. 4계층 패킷 필터링 장비
2. 3,4계층 정보를 기반으로 정책을 세운다
3. 정책을 기반으로 패킷을 통과시키거나 거부한다.
4. 일반적으로 DDoS장비 뒤에 위치시켜둔다.
5. 최근의 고성능 방화벽은 ASIC이나 FPGA를 사용해 가속하므로 대용량 데이터센터에서도 문제없이 사용가능하다

#### IDS(Intrusion Detection System), IPS(Intrusion Prevention System)

1. 기존에는 IDS와 IPS를 구분했지만 최근에는 애플리케이션 공격을 방어하는 장비를 IPS로 통칭한다.
2. 방화벽에서 잡을 수 없는 다양한 공격을 방어한다.
3. 사전에 공격 데이터베이스(시그니처가 저장된)를 제조사나 위협 인텔리전스로부터 공급받는다.
4. 화이트리스트와 블랙리스트방식 모두 가능하다.
5. 최근엔 방화벽과 IPS장비를 통합한 DCSG장비 시장이 커지고 있다.

#### WAF

1. 웹서버 보호 전용
2. 웹프로토콜 공격 방어(HTTP, HTTPS등)
3. WAF는 다양한 형태로 제공된다.

- 전용 네트워크 장비
- 웹 서버 플러그인
- ADC플러그인
- 프록시 장비 플러그인

4. IPS에서 방어할 수 없는 IPS 회피 공격을 방어할 수 있다. IPS에서는 데이터를 조합하지 않고 처리하지만 WAF는 프록시 서버와 같이 패킷을 데이터 형태로 조립해 처리하기 때문이다. 즉, 데이터를 일부 제거하거나 수정하는 등의 고도화된 동작도 가능하다.

##### 샌드박스

해커들은 보안 장비를 우회해야한다. 이를 위해 악성 코드를 관리자 PC에 우회적으로 심고 이 악성 코드를 이용해 관리자 PC를 컨트롤 하는 방식으로 진화해왔다. 관리자가 어떠한 방법으로든 악성 코드에 감염되면, 해커가 구축한 외부의 C&C(Command And Control)서버와 연결되도록 조작한다. 이 때 기존 방화벽은 관리자가 통신하는 것으로 인식해 탐지할 수 없다. 이 공격들이 발전해 현재 APT(Advanced Persistent Threat)와 ATA(Advanced Target Attack)가 되었다. 이를 막기 위해 C&C와의 통신을 탐지할 수 있는 다양한 Anti-APT솔루션들이 개발되었다.

샌드박스는 APT공격을 방어하는 대표적 장비이다. 악성코드를 샌드박스 시스템안에서 직접 실행시킨다. 가상 운영체제 안에서 각종 파일들을 직접 실행시키고 그 행동을 모니터링해 그 파일들의 악성 여부를 판단한다. 이를 통해 기존의 보안장비에서는 방어 불가능했던 공격들을 무력화 시킨다. 최근 악성 코드들은 다크웹에서 공개되거나 사고 팔리느니 경우가 많다. 다양한 변종이 출현해 탐지가 어렵고 기존의 장비가 탐지하지 못하도록 암호화, 난독화하거나 매우 오랫동안 여러단계를 거쳐 공격하기도 한다. 그러므로 하나의 APT솔루션이 모든 공격을 방어할 순 없다. 다양한 보안 장비와 솔루션, 새로운 공격을 유기적으로 방어해야한다.

##### NAC(Network Access Control)

인가된 사용자만 접속할 수 있게 만드는 기술

#### IP제어

NAC와 공통적이거나 비슷해보이는 경우가 많다. 하지만 IP제어 솔루션은 국내에서 많이 사용하는 기술로, NAC와는 다른 목적으로 개발되었다.
보안사고 추적이 쉽도록 고정 IP사용 권고 지침이 금융권에 내려오면서 IP를 할당하고 추적하는 솔루션 형태로 개발되었다. 정확히 의도된 IP가 아니면 네트워크를 사용하지 못한다.

#### 접근 통제

운영자가 서버, DB, 네트워크 장비에 직접 접근해 관리하면, 각 사용자에 대한 권한을 관리해야하는데 문제가 발생했을 때 직접 관리자가 내용을 추적하고 감시하기가 어렵다. 이를 해결하기 위해 서버나 DB등에 대한 직접 접근을 막고 작업 추적 및 감사를 할 수 있는 접근 통제 솔루션이 개발되었다. 에이전트 기반, 에이전트리스 등 구현 방법에따라 다양하게 분류될 수 있지반 대부분 Bastion Host를 기반으로 구현된다.

서버 접근을 위한 모든 통신은 Bastion Host를 통해서만 가능하다. 서버는 오직 배스천 호스트에서 출발한 패킷만 허용한다. 배스천 호스트의 보안, 감사 수준을 높여 보안을 강화한다. 최근의 솔루션들은 단순히 접근 통제 뿐 아니라 사용자가 작업한 모든 이력을 저장하는 식으로 발전했다. 화면을 레코딩하거나 모든 키보드 타이핑을 저장하기도 한다. 서버에 접근하면 그에 대한 로그도 모두 저장한다.또한 권한제어를 통해 사용 가능한 명령어 범위를 제한할 수도 있다.

#### VPN

사용자 기반의 VPN서비스를 제공해주는 장비를 VPN장비라고 한다. 기존에는 별도의 VPN서비스를 제공하는 하드웨어가 있었지만 현재는 대부분 방화벽이나 라우터 장비에 VPN기능이 포함되어 있다. 자세한 내용은 VPN절에서...

#### 방화벽

##### 초기 방화벽

방화벽은 상태기반 엔진을 가지고 있어야한다. 그러나 초기엔 패킷의 인과관계를 확인하지 못하고 장비에 등록된 정책만으로 단순 필터링을 수행했다. 이런 형태는 패킷의 세션 정보나 방향성과 상관이 없으므로 stateless 또는 packet filter 방화벽이라고 부른다.
이런 형태에서는 5-tuple을 사용한다. 5-tuple이란 source IP, Destination IP, Protocol No, Source Port, Destination Port를 뜻한다. 이 정책의 일치여부에 따라 통과시키거나 차단한다.

이런 방식은 간단한 정책을 정의할 때는 효과적이나, 인터넷 통신과 같이 불특정 다수 기반의 정책을 정의하면 Rule set이 복잡해지고 보안이 약화된다. 또한 패킷 단위 필터링이므로 5-튜플에 포함되지 않는 정보(3,4계층 헤더 등)을 변조해가며 공격하면 적절한 대처가 불가능하다. 다만 패킷필터링 자체는 부하가 적고 간단히 동작하므로 완전히 없어지지 않고 네트워크 장비나 방화벽에서도 특수한 기능을 위해 남겨둔다. 패킷 필터링 엔진과 SPI엔진을 함께 동작시키기도 한다.

##### 현대적 방화벽:SPI(Stateful Packet Inspection)

상태기반 방화벽(SIF, Stateful Inspection Firewall)은 현재 우리가 방화벽이라고 부르는 모든 방화벽이다. 현재 방화벽이라고 부르는 모든 장비는 SPI엔진을 탑재한다.

SPI가 필요한 이유는 패킷 필터링이 사실상 보안역할을 하기 힘들기 때문이다. 예를 들어 3 way-handshake조차도 처리하지 못한다.
일단 목적지가 불특정 다수의 웹이 될 수 있다. 이경우 외부로 나가는 모든 패킷을 허용해야한다. 또한 외부가 불특정 다수이므로 들어오는 모든 패킷도 허용해야한다. 사실상 효용이 없는 것이다. SPI는 이러한 단점을 보완해 패킷의 인과와 방향성을 인지한다.내부에서 외부로 접근을 시도한 통신과 외부로부터 시작된 통신을 구분해 처리한다.

방화벽 장비의 동작은 장비별로 다르다. 그러므로 장비별 Packet Processing Flow를 반드시 확인해야한다. 그러나 일반적인 순서는 다음과 같다.

1. 패킷이 장비에 도달시 세션 상태 테이블(3,4계층의 세부 필드 포함)을 확인한다.
2. 세션 정보가 세션테이블에 존재하면 포워딩 테이블을 확인(라우팅, ARP포함)한다.
   - 세션 정보가 없으면 방화벽 정책을 확인한다.
   - 방화벽 정책은 최상단부터 확인하며 최종 정책까지 확인 후 정책이 존재하지 않으면 암시적 거부 규칙을 참고해 차단한다.
   - 규칙이 존재한다면 세션테이블에 저장한다.
3. 조건에 맞는 정보가 포워딩 테이블에 존재할 때, 적절한 인터페이스로 패킷을 포워딩한다.
   - 포워딩 테이블과 일치하는 조건이 없다면 패킷을 폐기한다.

대부분의 방화벽은 통신 전체의 세션로그를 저장할 수 있다. 보안사고 발생시 세션로그를 확인한다.

##### ALG(Application Layer Gateway)

FTP등 너무나 오래된 프로토콜들은 방화벽 개념이전에 개발된 프로토콜이므로 방화벽을 고려하지 않고 설계되어 정상적인 통신이 불가능한 경우들이 있다. 그러므로 방화벽이 오히려 FTP의 동작을 이해하고 그에 맞게 동작해야한다. FTP는 컨트롤 프로토콜과 데이터 프로토콜이 분리되어 동작하고 반대로 세션을 맺는다. FTP는 애플리케이션 계층의 프로토콜이므로 기존의 SPI의 3,4계층 정보로는 FTP를 방화벽이 이해할 수 없다. 그래서 방화벽에서 애플리케이션 프로토콜을 확인할 필요가 있는데, 이런 기능을 ALG라고 한다.

#### 방화벽의 한계

방화벽이 개발되자 많은 공격들이 힘들어져 계정 탈취가 아닌 서비스 중단(DDoS)가 새로운 트렌드가 되었다. SPI엔진을 사용하는 방화벽은 적은 리소스로도 공격을 효과적으로 방어하기 때문에 필수적인 보안으로 자리잡았지만 3,4계층 정보로만 방어한다는 한계가 있다. 이를 보완하기 위해 ALG로 애플리케이션 단계를 일부 이해할 수 있기는 하지만 근본적으로 바이러스나 웜을 탐지해내기는 힘들다.

또한 취약점은 대부분 애플리케이션 단계에 존재한다. 그러므로 방화벽의 한계는 명확하다. 이러한 취약점 공격을 막기 위해 등장한 보안장비가 IPS이다.

#### 더 현대적인 방화벽 NGFW, UTM

SPI방화벽은 레거시 방화벽이라고 불린다. 요즘의 방화벽은 방화벽 단독이라기보다는 네트워크 보안장비의 기능 대부분이 통합되어있고, APT공격에 대응하는 샌드박스 기능이 연계되어 제공되기도 한다. NGFW(next generation firewall)와 UTM(unified threat management firewall)은 방화벽을 애플리케이션 영역까지 확장한 개념이다. 내부적으로 구현하는 방식은 다른데, NGFW는 다양한 보안장비의 기능이 논리적(not 물리적으로)으로 통합되어있고 UTM은 물리적으로 통합되어 동작한다. 두 장비 모두 다양한 보안 방책을 제공하며, 애플리케이션 계층을 포함해 보안을 제공한다.

## IPS(Intrusion Prevention System), IDS(Intrusion Detection System)

IDS는 Detection단어 그대로 공격 탐지를 목적으로 개발된 시스템이다. 그러므로 공격에 직접 개입하거나 방어하지 않고 트래픽을 복제해 검토하고 침입여부를 판별한다.

IPS는 공격이 발견되면 직접 차단하는 능력을 가진다. 트래픽을 복제하는 것이 아니라 트래픽이 지나가는 인라인에 배치된다. 최근의 솔루션은 대부분 IPS이다.

#### 호스트기반 IPS, 네트워크기반 IPS

예를 들어 엔드포인트 방어 중점. 클라우드를 많이 쓰다보니 클라우드 네트워크의 여러 가지 제약 사항 때문에 HIPS(Host based IPS)가 많기는 하지만 여러 불편함(서비스와 리소스 공유, 장애 발생 시 장애 주체 파악 어려움) 때문에 클라우드 내부에서도 네트워크 기반인 NIPS로 바뀌는 추세이다.

#### IPS의 동작방식

기본적으로 IPS는 공격 데이터베이스를 사용해 패턴 매칭방식으로 운영된다.
그러나 Protocol Anomaly, Profile Anomaly등의 다른 기법으로도 사용한다.

##### Pattern Matching

시그니처 방식, 데이터베이스 방식 등으로도 불린다. 많은 공격 데이터를 보유하고 있을 수록 유효한 탐지 및 방어가 가능하다. 최신 공격 방식을 신속히 반영하는 것이 중요하다.

##### Anomaly

패턴 매칭의 가장 큰 단점은 어떤 변화를 유의미한 변화로 볼 것이냐, 혹은 새로운 공격 패턴을 적절하게 인지하고 있는가를 확신할 수 없다는 점이다. 예를 들어, 웜은 4시간이면 인터넷 전체에 퍼진다. 심지어 더 빨라지는 변종에 매번 데이터베이스를 업데이트하기는 어렵다.

그렇기에 화이트리스트를 사용한 방어가 대세가 되었는데, 이를 기반으로 한것이 어노말리이다.

어노말리는 특정 기준이상의 행위를 이상하다고 판단한다.

##### 프로파일 어노말리

관리자가 정해놓은 기준과 다른 행위가 일어나면 공격으로 판단한다. 이는 향후 DDoS장비로 진화했다.

##### 프로토콜 어노말리

앞서 언급했듯이, 보안의 발전에 따라 해커들의 공격 기법은 권한이 있는 사용자가 직접 파일을 실행하게 만드는 것이 주 목적이 되었다. 감염된 PC는 C&C서버와 통신할 때 일반적이지 않은 프로토콜을 사용하는 경우가 흔하다. 방법은 다양한데, well-known port와 프로토콜이 서로 일치하지 않을 때 등이다.

###### IPS, IDS의 한계와 극복(NGIPS)

IPS의 근본적인 문제는, 네트워크를 방해하지 않기 위해 Flow엔진을 사용하는데에 있다. Flow엔진은 패킷을 보아 데이터로 변환해 검사하는 것이 아니라 패킷이 흘러가는 상황을 감시하는 것이다. 그러므로 비교적 쉽게 IPS를 우회하는 것이 가능하다.

IPS는 오탐이 많이 발생하므로 튜닝을 오랫동안 해주어야한다.

NGIPS는 애플리케이션을 인지하거나 다양한 시스템과 연동할 수 있고 특히 APT공격을 방어하기 위한 일부 기능이 탑재되어있거나 외부 시스템과 연동할 수 있다. 방화벽처럼 기존의 IPS 시장은 축소되고 있고 NGIPS가 대세가 되고있다.

참고로 공격 데이터베이스를 구축하기 위해 일부러 취약한 서버를 올려놓고 공격대상이 되어 정보를 수집하기도 하는데, 이를 두고 허니팟이라고 한다.
