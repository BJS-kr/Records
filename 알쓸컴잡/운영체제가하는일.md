# 이 내용은 요약임
책 옮겨쓰기는 의미가 없다고 생각한다. 책에 있는 내용은 책을 보면 된다.
다만 운영체제가 무엇을 하는지에 대한 개요 내용으로 적겠다.

# H/W, S/W 그리고 Kernel mode와 User mode
OS는 어쩌면 당연한 소리로 H/W를 제외한 모든 영역에 존재한다고 말해도 틀리진 않지만, OS layer를 특정하기 위해 생각해보면 Kernel mode와 User mode의 일부인 Service layer를 합친 영역을 일컫는다. 
# Process
Process는 명령 집합인 Program이 인스턴스화된 상태를 일컫는다. 그리고 그 Process는 전용 공간인 Virtual Memory내부에서 작동한다(현대의 컴퓨터는 Multi tasking이 너무나 당연하므로 Virtual memory라고 표현했다). Process는 최소한 하나의 Thread를 가진다. Thread가 없는 Process는 아무도 없는 사무실과 같다.
# Thread
Thread는 Process 내의 개별 flow다. 복수로 존재할 수 있다. 실제 작업 처리 주체다.
한 Process에 소속된 Thread들은 Process가 할당받은 Virtual Memory를 공유한다.
# 자원관리
현대의 컴퓨터는 대부분 수백개의 프로세스(프로세스는 Task라고도 불린다. 즉 Multi tasking)와 수천개의 스레드를 항상 실행하고 있다. 
그런데 한정된 코어수와 메모리를 어떻게 사용할 수 있을까? 작업 주체인 스레드가 CPU코어를 나눠서 써야하는 계획을 수립하고 실행하는 것을 Scheduling이라고 부르는데, Kernel의 책임이다. 

# 기억공간
Process는 공통 메모리 구간을 할당받는다고 언급했다. 정확히는 Thread마다 stack을 할당받고, 프로세스마다 Heap과 실행코드 영역을 가진다. stack은 사무실에서 자신의 자리라고 생각하면 된다. 사무실은 분명 공통공간이지만 자신의 자리는 자신만을 위한 것이다. Heap 탕비실이라고 생각하자. 사무실에 속한 직원은 누구라도 사용할 수 있다.실행코드 영역은 프로그램 실행순서가 적재된 공간이다. Heap은 공용공간 답게 Stack에 비해 훨씬 넓은 공간을 가진다. Stack은 특별한 이유가 없다면 약 1MB이다. Heap은 32bit기준 보통 약 1.7GB 정도이다. 항상 그렇다는 것이 아니고 대략적이라는 것이다. 이는 목적에 따라 조정될 수 있다. 

# Virtual memory
사실 결론은 간단하다. 가상 메모리란 1차메모리와 더불어 n차 메모리를 합해 논리적 메모리로 추상화시키는 메모리 관리 방법이다. 자세히 살펴보자. 자원은 한정되어 있는데 수천개의 스레드가 어떻게 실행될까. 심지어 OS도 일정량의 메모리를 항구적으로 점유중인데 말이다. 사무실의 예로 돌아가보자. 사무실에 근무하는 인원은 10명인데, 미팅이 잦아 항상 두 명정도는 외근을 나가며, 10명이 순환적으로 외근한다고 생각해보자. 외근시 업무를 위해 노트북이 몇 대 필요할까? 당연하게도 10대가 아닌 2대다. 컴퓨터에도 이 원리가 똑같이 적용된다.

멀티태스킹 중인 컴퓨터는 동시에 여러 프로세스를 실행중이지만 모두 '사용중'인것은 아니다. 예를 들어, 문서 편집프로그램을 실행하고 있다가 인터넷 서핑을 하게 되었다고 생각해보자. 문서 편집 프로그램은 분명히 실행중이지만 사용되고 있지는 않다.
그리고 인터넷 서핑을 하기 위해 브라우저를 실행한 시점에, RAM의 유휴공간이 부족했다고 가정하자. 이 때 Kernel은 작업 우선순위가 낮은 문서 편집 프로그램의 메모리를 RAM이 아닌 2차 메모리에 적재해 주메모리의 공간을 확보할 수 있다. 이 시점에, 프로세스는 자신의 메모리 위치가 주메모리인지 n차 메모리인지 알 수 있을까? 없다. 정확히 말하면 알 필요가 없다. 애초에 모든 프로세스는 '논리적 주메모리'를 할당받는다.

그런데, 프로세스가 할당받은 메모리는 실제 메모리가 아닌 논리적 메모리이기 때문에 그 논리적 메모리에 입출력을 실행하며 돌아가던 프로세스는 어떤 이유로든 간에 죽어버렸을 때 실제 메모리를 해제할 수 없다는 큰 문제가 생긴다. 쓰는 프로세스가 없는데 메모리가 점유되고 있는 것이다. 이를 어떻게 해결할까? 프로세스가 죽으면 프로세스가 쓰고 있던 '논리적 메모리'를 회수한다. 이 작업은 Kernel이 실행하며, 그 논리적 메모리가 물리적 메모리의 어느 영역인지 OS는 당연히 알고 있으므로 해제가 가능하다. 

운영체제가 메모리를 할당해 주는 단위를 Page(따로 설정하지 않았다면 window 기준 아마 4KB. 메모리 관리 최소단위)라고 하는데, 2차 메모리에 적재되는 것을 page-out 혹은 swap-out이라고 한다. 반대로 유휴공간이 남거나 연산을 시작해야할 때 주메모리로 다시 옮기는 것을 page-in, swap-in이라고 한다. 그런데 1차메모리가 가득찬 상태에서 2차메모리에 올라간 메모리에 I/O를 한다면 어떻게 될까? 주메모리에서 연산하던 때와는 다르게 비교할 수 없이 느려진다. 다만 돌아는 간다. 
2차 메모리가 부족해도 page-out이 원활하지 않으니 장애가 생긴다. 그래서 1차메모리와 2차메모리는 둘 다 여유 있게 구비해야한다.

# Shared Memory
IPC 기법 중 Shared Memory를 Virtual memory에 이어 생각해보자. 여러가지가 있지만 Shared Memory를 생각해보자. 프로세스끼리 메모리를 침범할 수 없는 것은 당연하다. 그러나, 아주 예외적인 상황이 있는데 Virtual Memory의 특정 부분을 공유시키는 기법을 OS가 사용한다. 예를 들어, RAM에 0x1111이라는 메모리 위치가 존재한다고 가정하자. 그리고 Process 1과 Process 2는 소유한 가상 메모리 공간에 Process 1:0x1112와 Process 2: 0x1113을 가지고 있다고 가정해보자. 운영체제는 shared memory기법을 통해 논리적 메모리인 Process 1:0x1112와 Process 2: 0x1113를 물리적 메모리 0x1111를 가리키도록 매핑해두었다.

위에서 설명한 논리적 메모리와 물리적 메모리를 통해 프로세스간 소통이 가능해진다. Process 1이 어떤 데이터를 공유 메모리 구간에 적재하면 Process 2가 받을 수 있는 것이다. Shared Memory의 예는 의외로 쉽게 찾아볼 수 있는데, 바로 복붙이다. 다른 프로세스간에 가지고 있는 정보를 즉시 옮길 수 있는 이유는 당연히 IPC덕이다.


