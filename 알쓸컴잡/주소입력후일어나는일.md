**아는 지식을 총 동원해서 최대한 자세히 적어보겠습니다**
# 1
브라우저에 주소를 입력했다는 것은 TCP연결을 실행하는 말과 같다(브라우저의 default 동작이 TCP임). 브라우저는 L7 application process이니 kernel에게 tcp연결 요청을 한다. tcp 연결 요청이니 kernel과 통신은 socket으로 일어난다. 브라우저는 well-known port(0~1023, 1024는 사용안함)를 제외한 랜덤 포트(1025~65536) 중 빈 포트를 자동으로 할당받으므로 딱히 포트를 지정하지 않아도 연결이 자유로운 것이다. 연결은 local-ip, local-port, remote-ip, remote-port, protocol 다섯 가지 항목중 하나라도 다르면 다른 커넥션으로 취급되므로 같은 호스트의 여러브라우저에서 한 목적지에 접속하는 것도 가능하다. OS마다 다른 kernel network component(예를 들어 window라면 IOCP)는 먼저 DNS가 매핑된 주소가 있는지 hosts 파일을 검사한다. hosts에 정보가 없으면 DNS cache를 조사한다. DNS cache는 일정 기간이 지난 기록들을 삭제하므로 접속했던 곳이라도 정보가 없을 수 있다. 이 곳에도 없으면 DNS 질의를 요청한다. DNS 질의는 경우에 따라 다르게 일어난다. PC의 설정에 따라 달라지는데, 예를 들어 공유기를 쓴다면 PC의 네트워크 기본설정이 먼저 공유기(NAT이자 사설망을 분리하는 router이자 l3 switch일 가능성 농후)에 DNS질의를 요청하도록 설정되어있을 수 있다. DNS질의는 우선순위를 정해 수행할 수 있으므로 단지 router에 질의가 1순위였다는 것이다. 이 경우 공유기에 DNS forwarding 기능이 내장되어있다면 공유기가 직접 DNS질의를 수행한 후 반환한다. 두 번째는 ISP가 제공해준 DNS설정을 사용하는 것이다. 사실 이 방식이 default이다. 세 번째는 컴퓨터의 설정에 따라 DNS에 직접 질의를 할 수 도 있다. DNS는 분산형 데이터베이스 구조를 가지고 있고, 계층적이므로 원하는 정보가 나올때까지 DNS질의는 포워딩된다. 주소를 찾으면 다시 host pc로 반환된다. 
여기까지 진행했을 때, IP주소를 알게 되었으므로 정말로 TCP 연결 시도가 일어난다. HTTP는 L7 프로토콜이며 이 단계에서 데이터는 message라는 용어로 불린다. PC의 커널단계에 들어가 TCP(transport, L4): segment, IP(network, L3): packet, Ethernet(NIC, data link, L2): frame, NIC{NIC는 layer2라고 보통 일컬어지지만 정확히 말하면 layer 1의 역할도 함. 전기신호를 변환해 내보내기 때문}(physical, L1): 디지털 전기 신호 -> 아날로그 전기 신호까지 변환되며 PC를 떠나 네트워크 회선으로 신호가 입력된다. NIC에는 MAC주소가 있다. MAC주소는 data link계층 ethernet 헤더가 목적지와 출발지 MAC주소를 포함한다. 사실 ethernet은 header 뿐 아니라 trailer도 존재한다. 전송도중에 오류가 발생하지 않는지 확인하는 용도로 사용한다. 아직 ethernet frame을 만들 수는 없다. 목적지 MAC주소를 모르기 때문이다. MAC주소를 채우기 위해선 ARP가 필요하다. IP 주소와 MAC주소는 그 자체로 놓고 봤을 때 아무런 연관이 없다. 그러므로 IP를 통해서 MAC을 알아내야하는데, 먼저 ARP Packet을 네트워크에 뿌린다. 방금 이더넷 프레임을 만들 수 없다고 했는데 이 패킷이 네트워크로 나갈 수 있는 이유는 목적지 MAC을 모두 F로 채워 브로드캐스트임을 표시하기 때문이다. AR protocol field에도 마찬가지로 대상자 MAC 주소를 모두 0으로 채워넣어져있다. 목적지의 컴퓨터는 자신을 대상으로 한 브로드캐스트가 도달했을 때 유니캐스트한다. 그 이유는 출발지의 정보가 들어있기 때문에 자신을 출발지로 바꾸고 도달한 ARP packet의 출발지를 목적지로 설정하면 되기 때문이다. ARP를 요청한 호스트는 응답이 반환되면 정상적으로 ethernet frame을 생성할 수 있고 ARP는 종료된다. 전송해야할 총 데이터는 일정 크기의 패킷으로 나뉘어 전송되므로 전송마다 ARP를 요청한다면 엄청난 네트워크 지연이 생길 것이다. 데이터 전송을 하기도 전에 네트워크를 왕복하는 작업이기 때문이다. 그래서 ARP를 수행하고 나면 ARP테이블에 IP와 MAC주소가 매핑됩니다. 이후 전송은 이 테이블을 참조하여 진행되지만, IP는 언제든 바뀔 가능성이 있으므로 일정 시간동안 매핑된 정보를 활용하지 않으면 삭제된다.

# 2
아마도 어떤 엔드포인트 PC는 사설망에 속해있을 가능성이 높다. 지금 이 글을 쓰는 컴퓨터만 해도 공유기를 사용하고 있으며, 공유기(NAT를 수행하며 router이자, l2 switch이자, hub이자, 리피터)가 사설망을 구축하고 있다. 애초에 일반 사용자용 PC는 router의 DHCP로 IP를 할당받았을 가능성이 높다. l2 switch의 기능이 포함되어있으니 MAC주소 테이블이 있고, dummy hub와 같은 일은 일어나지 않는다. ethernet 프레임에 존재하는 정보를 참고해 출발지 MAC주소가 없다면 등록한다. 이를 MAC주소 학습이라 한다. 목적지의 MAC주소가 테이블에 없다면 switch는 연결된 모든 호스트에 데이터를 전송한다. 물론 이더넷 헤더를 참조해 자신에게 온 데이터가 아니면 무시되므로 모든 PC에서 데이터를 확인할 수 있는 일은 일어나지 않는다. 이렇게 모든 PC에 요청을 보내는 현상을 Flooding이라고 한다. 반대로 목적지가 등록되어 있었다면 특정 목적지를 향하여 전송하는데, 이를 MAC 주소 필터링이라고 한다. 참고로 이런 MAC주소 참조 동작은 bridge에서도 일어나지만 bridge의 역할은 근거리 LAN을 이어주는 역할 뿐이다. switch는 전이중통신을 사용한다.
IP header에도 목적지 출발지 IP 정보가 들어있지만 switch는 2계층이므로 3계층 정보에 도달할 수 없다. 이렇듯 모든 네트워크 장비는 자신이 속한 계층과 하위계층의 정보에만 접근이 가능하다.

# 3
아마도 요청은 다른 네트워크로의 포워딩이 필요할 것이다. 라우터는 네트워크를 분리해 인식할 수 있는 것이지 네트워크를 분리하는 존재가 아니다. 예를 들어 스위치가 두개 연결되어있고 각 스위치에 pc들이 연결되어 있다면 라우터는 스위치의 연결별로 네트워크로 처리할 수 있다. 1 라우터 = 1 네트워크가 아니라는 것이다. 참고로 스위치의 상위 연결이 또 다시 스위치일 수도 있다. 모든 장비가 순서대로 1개씩 배치되어있지는 않다. 라우터의 IP 주소를 두고 보통 기본 게이트웨이라고 한다. 라우터는 네트워크의 출입구 역할을 하므로, 다른 네트워크로의 전송이 필요하다면 일단 기본 게이트웨이로 보내야한다. 라우터는 라우팅 테이블에 경로정보를 등록하고 관리하는데, 목적지까지의 정보가 기록되어있다는 것이 아니라 이 IP주소와 가장 가까운 라우터의 주소를 추론해 내보낸다. IP주소는 라우터가 알고 있는 주소와 일치하지 않는 경우도 존재하므로 exact match가 아니더라도 가장 근접한 정보를 찾아 라우팅한다. 이때 주로 Longest prefix Match(LPM)을 사용한다. exact match를 벗어나 LPM알고리즘을 돌리는 것은 리소스가 많이 소모되는 작업이므로 캐시를 적극적으로 활용합니다. 한번 라우팅된 정보는 캐시에 저장됩니다. router에서는 IP header의 한 부분은 TTL이 적극적으로 사용되는데, TTL은 라우터를 한번 거칠때마다 -1됩니다. 이는 라우터간 서로 next hop으로 인식하는 등 패킷이 표류할 경우를 대비해 TTL이 0이 되는 순간 제거되게 하기 위함입니다. 라우터끼리 건너뛰는 것을 hop by hop이라고 표현한다. 라우터가 최적의 경로를 찾아 포워딩 해주는 작업을 switching이라고 부르는데, 이는 엄연히 L2 스위치와는 전혀 별개의 작업이다. 또한 라우팅 알고리즘은 Dynamic routing을 가장 많이 사용하는데, 주기적으로 또는 상태정보가 변경될 때마다 인접 라우터끼리 경로정보를 교환하며 네트워크를 학습하는 것입니다. static routing은 수동 테이블 관리 방식인데 규모가 작은 네트워크(건물 내 등)에서는 가능하지만 대규모 네트워크에서는 불가능해 대부분 dynamic routing이 사용된다.

# 4
목적지에 도달한 후, decapsulation하면서 TCP연결을 시도한다. 이 때 도달한 패킷(#1. syn bit 1), 응답 패킷(#2, ack 1, syn 1), 응답의 응답(#3, ack 1) 총 세개의 패킷으로 3way handshake가 일어난다. 연결을 확립하고 데이터 전송이 시작된다. 32bit seq(sequence number)로 각 패킷의 도달 유무를 확인한다. 각 패킷에 대한 Seq num을 송신하면 수신자가 ACK Seq num 으로 응답하는 것이다. TCP에는 송신자가 전송 실패했을 경우 재전송하는 등의 작업이 포함된다. 참고로 SYN or FIN flag를 가진 패킷은 payload를 가질 수 없다. 

다만 송신자는 예를 들어 syn3을 보냈다면 ack3이 올때까지 단순히 대기하는데, UDP보다 전송이 느린 주요 원인이 된다. 또한 수신측에서도 window(TCP 연결 데이터 수신 버퍼)를 비우는 속도가 네트워크 수신 속도보다 느리면 지연이 발생하는데, 송신측은 자신의 Maximum segment size가 수신측의 window size(ack 보낼때 window size같이 보냄)보다 작을 때만 송신하기 때문이다. window size가 충분하지 않은 이유는 단순히 수신측의 하드웨어 부하로 발생할 수 있다. 이는 네트워크의 지연 원인이 네트워크 자체로 일어나지 않을 수 있다는 점에서 시사하는 바가 크다.
HTTP 1.0은 req-res사이클마다 재연결 해야했지만 1.1부터는 여러 req-res사이클을 단일 연결로 처리할 수 있게 되었다. 이는 keep alive헤더로 표시된다. 연결이 확립된 후 HTTP Request가 시작된다. L7 프로토콜이므로 송신자의 L7부터 수신자의 L7까지 도달해야한다. 분할 전송 및 순서대로 전송하는 tcp의 특성이 이 곳에서 생긴다. 모든 요청-응답이 완료되면 4-way handshake로 세션을 종료한다. 

패킷분석으로 이해하기 좋은글: https://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/