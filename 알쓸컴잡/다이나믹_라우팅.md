# 라우팅
라우터가 패킷을 처리할 때는 크게 두 가지 작업을 수행합니다.
* 경로 정보를 얻어 경로 정보를 정리하는 역할
* 정리된 경로 정보를 기반으로 패킷을 포워딩 하는 역할
라우터는 자신이 알고 있는 주소, 목적지가 아니면 패킷을 버리므로 패킷이 들어오기 전에 경로 정보를 충분히 수집하고 있어야 합니다. 인터넷에 존재하는 주소와 경로는 매우 빠르게 늘고 있으며 같은 클래스에 있는 주소조차 서브네팅된 상태로 분산되어 존재하므로 경로 정보가 기존보다 훨씬 많아졌습니다. 라우터는 이런 복잡하고 많은 경로 정보를 얻어 최적의 경로 정보인 라우팅 테이블을 적절히 유지해야 합니다.

라우터에 전달되는 패킷은 라우터가 알고 있는 주소들과 정확히 일치하지 않는 경우가 더 많습니다. 그래서 Exact Match가 아니라고 하더라도 목적지에 가장 근접한 정보를 찾아 패킷을 포워딩 해야합니다.

라우터는 단말부터 목적지까지의 경로를 모두 책임 지는 것이 아니라 인접한 라우터 까지만 경로를 지정하면 인접 라우터에서 다시 최적의 경로를 파악해 라우터로 포워딩합니다. 이런 식으로 한 단계씩 네트워크를 뛰어넘는 방식을 hop by hop 라우팅이라고 부르고 인접한 라우터를 next hop이라고 부릅니다.

그러나, 교과서적인 hop by hop은 사실 [MPLS](https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%A4%91_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_%EB%A0%88%EC%9D%B4%EB%B8%94_%EC%8A%A4%EC%9C%84%EC%B9%AD)와 같은 고성능 네트워크 기법에 밀려 급격히 사라지는 추세입니다.

라우터가 수집한 경로 정보, 원시 데이터(Raw data)를 Topology table이라고 하고, 이 경로 정보 중 최적의 경로를 따로 저장한 것을 Routing table이라고 부릅니다. 최적의 경로란 경로 정보를 받은 방법과 거리를 기준으로 정해집니다. 예를 들어, 목적지 네트워크 정보가 동일한 서브넷에 속해 있을 경우 가중치의 우선 순위는 다음과 같습니다.
1. 내가 갖고 있는 네트워크(Direct connected)
2. 내가 경로를 직접 지정한 네트워크(Static routing)
3. 다른 라우터를 통해 경로를 전달 받은 네트워크(Dynamic routing)

라우팅 프로토콜 중에서도 어떤 라우팅 프로토콜을 통해 경로 정보를 얻었는가에 따라 우선순위가 다릅니다. 이는 장비에 미리 설정되어있는 preset값이며 관리자가 필요에 따라 조정하는 것도 가능합니다. 또한 우선순위의 설정값도 장비 제조사마다 조금씩 다릅니다. 어쨌든 이러한 우선 순위를 AD(Administrative Distance)즉, 관리 거리라고 부릅니다. AD의 라우팅별 가중치 값은 다양하므로 필요하다면 찾아서 보는 것을 권장합니다.

마지막으로, 라우터의 라우팅 스위칭 역할을 하나로 묵어 다시 설명하면 전체적인 우선 순위는 다음과 같습니다.
1. Longest Match(Switching)
2. AD(Routing)
3. Cost(Routing)
4. 부하분산(ECMP(Equal-Cost Multi-Path)는 가중치와 Cost 값 까지 동일한 경우 동일한 Cost를 가진 경로를 모두 활용해 트래픽을 분산하는 방식입니다. Routing입니다)

예를 들어, Static routing은 AD에서 높은 우선 순위를 가지는데, 라우터가 이보다 높은 우선순위를 가진 경로로 포워딩하게 만들고 싶다면 Longest Match로 목적지 주소와 더 많이 일치하는 주소가 입력된다면 Static routing을 무시하고 동작하게 됩니다.

라우팅 테이블에 저장하는 데이터에는 다음의 정보가 포함되어 있습니다.
* 목적지 주소
* 방향
* 거리
자세한 [라우팅 테이블](http://www.ktword.co.kr/test/view/view.php?m_temp1=1327) 


패킷이 라우터에 들어와 라우팅 테이블을 참조하고 최적의 경로를 찾아 라우터가 포워딩 해주는 작업을 Switching이라고 합니다. **이는 L2 Switch와는 다른 것입니다.** 앞서 라우팅 테이블에 있는 주소 정보와 목적지가 정확하게 일치하지 않는 경우가 더 많다고 언급했는데, 이 때 최대한 가깝게 매치되는 경로 정보를 찾는 과정을 거칩니다. 이 때 사용되는 알고리즘을 (LPM)Longest Prefix Match나 Maximum Prefix Length Match라고 합니다. 라우터가 이런 작업을 수행하는 것을 Matching 혹은 Match Rule이라고 부릅니다. 이런 특성때문에 라우터나 스위치에서 관리할 수 있는 Routing table을 LPM table라고도 부릅니다. Exact Match는 리소스 소모가 적은 반면 이러한 알고리즘의 실행은 많은 부하가 걸리는 작업입니다. 그러므로 대부분의 라우터는 이러한 소모를 최대한 줄여줄 수 있는 캐시 기법들을 사용중입니다. 한 번 스위칭을 실행한 정보는 캐시에 저장하여 라우팅 테이블 보다 우선적으로 확인 합니다.

### loop free L3: TTL
참고로, 3계층 IP헤더에는 TTL이라는 필드가 있습니다. 이 필드는 패킷이 네트워크에 살아 있을 수 있는 시간을 제한합니다. 인터넷 구간에서 쓸모없는 패킷이 돌아다녀 대역을 낭비하는 것을 막기 위해 라우터는 주소가 불분명한 패킷을 버리는데, 사이트가 갑자기 사라지거나 대안 경로를 찾는 과정에서 두 라우터가 서로를 Next hop으로 인식하여 패킷이 두 라우터 사이에서 계속 오가는 경우도 발생할 수 있습니다. 그래서 모든 패킷에는 TTL값이 있습니다. 실제 초와 같은 시간이 아니라고 홉을 지날때마다 TTL값이 1씩 줄어들며 0이되면 네트워크에서 버려집니다.

# 라우팅 방법들
라우터가 경로 정보를 얻는 방법은 매우 다양하지만 크게 세 가지 방법으로 구분할 수 있습니다.
## Direct connected
 IP주소를 입력할 때 사용된 IP 주소와 서브넷 마스크로 해당 IP 주소가 속한 네트워크 주소 정보를 알 수 있습니다. 라우터나 PC에서는 이 정보로 해당 네트워크에 대한 라우팅 테이블을 자동으로 만듭니다. 이 경로 정보를 Direct connected라고 부릅니다. 이 방법으로 생성되는 경로 정보는 인터페이스에 IP를 설정하면 자동 생성되는 정보이므로 정보를 강제로 지울 수 없고 해당 네트워크 설정을 삭제하거나 해당 네트워크 인터페이스가 비활성화 되어야만 자동으로 사라집니다.
## Static routing
관리자가 목적지 네트워크와 Next hop을 라우터에 직접 지정해 경로 정보를 입력하는 것을 Static routing이라고 합니다. 스태틱 라우팅은 관리자가 직접 지정하므로 직접적으로 설정 및 관리할 수 있습니다. Direct connected처럼 연결된 인터페이스 정보가 삭제되거나 비활성화되면 연관된 스태틱 라우팅 정보가 자동 삭제 됩니다.

네트워크는 양방향이므로 되돌아 오는 패킷도 고려해야하는데, 예를 들어 Router 1 -> Router 2경로를 Static routing했다면 되돌아오는 패킷은 Router 2에서 Next hop을 Router 1로 설정해주어야 합니다.

## Dynamic routing
Static routing은 네트워크 변화가 적은 경우에 관리자가 손쉽게 관리 할 수 있지만 규모가 큰 네트워크에서는 사용하기 어렵습니다. Static routing은 라우터 너머의 다른 라우터의 상태 정보를 파악할 수 없어 라우터 사이의 회선이나 라우터에 장애가 발생하면 장애 상황을 파악하고 대체 경로로 패킷을 보낼 수 없기 때문입니다.

Dynamic routing은 이렇듯 관리자가 모든 네트워크 경로 정보를 관리하기가 어렵거나 대체 경로를 찾기 힘든 Static routing의 단점을 보완합니다. 라우터끼리 자신이 알고 있는 경로 정보나 링크 상태 정보를 교환해 전체 네트워크 정보를 학습합니다. 주기적으로 또는 상태 정보가 변경 될 때 라우터끼리 경로 정보가 교환됩니다. 그러므로 라우터가 연결된 회선이나 라우터 자체에 장애가 발생하면 이를 인지해 대체 경로로 패킷을 포워딩 할 수 있습니다. 관리자의 개입 없이 라우터끼리의 정보교환만으로 장애를 인지하고 트래픽을 우회할 수 있으므로 대부분의 네트워크에서 Dynamic routing이 이용됩니다. 네트워크는 SPoF(Single Point of Failure)에 대처하기 위해 항상 복수의 경로를 유지합니다.

Dynamic routing 프로콜은 여러 종류가 있습니다. RIP, OSPF, IS-IS, IGRP, EIGRP, BGP와 같이 다양하지만, 최근에서는 OSPF와 BGP프로토콜이 주로 사용되며 특히 BGP가 많이 사용됩니다. BGP의 동작원리는 Distance vector인데, 인접한 라우터에서 경로 정보를 습득하는 라우팅 프로콜입니다. 인접 라우터가 이미 계산한 라우팅 테이블을 전달받으므로 처리에 리소스가 많이 필요하지 않다는 장점이 있지만 역으로 인접 라우터끼리만 정보를 교환 핟나는 점 때문에 멀리 떨어진 라우터의 경로 정보를 얻는데 많은 단계를 거쳐야해서 오랜 시간이 걸릴 수 있다는 단점이 있습니다.

