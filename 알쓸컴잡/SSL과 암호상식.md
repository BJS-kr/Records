### 암호학의 일반 상식 정도라고 가볍게 생각해주시면 감사하겠습니다
# checksum
누산 후 자리올림을 사사 시키며 계산을 지속하는 경우가 많다. 예를 들어 9와 7이 있다면 9 + 7 = 16(누산값)에서 10의 자리를 버리고(사사) 6으로 만든다는 것이다. 동일한 깊이의 다른 사사된 누산값과 또 다시 반복하며 진행된다는 것.
# hash
hash는 단방향이다. 어떤 함수가 존재한다고 가정했을 때 인자 -> 값 flow는 당연하지만 값 -> 인자 flow는 당연하지 않은 것과 같다. 물론 양방향 함수는 존재하지만 hash는 단방향이라는 것이다. hash는 입력값이 1자리라도 달라지면 전혀 다른 값이 나온다.
checksum의 원리를 그대로 활용하는데(원리를 활용한다는거지 checksum이 hash의 하위 개념이라는 말이 아니다. checksum과 hash는 다르다. checksum은 기본적으로 보안성이 없다. 즉, 조작이 가능하다. 반면 hash는 조작할 수 없다. 결과값을 의도하는 것도 불가능하다. 어떤 결과를 얻기 위한 방법자체가 존재하지 않는 다는 것이다. 모든 결과값은 항상 예측 불가능하다. 그렇기 때문에 역계산도 자동으로 불가능해진다. 이는 수학적 영역이다), 이 때문에 hash는 입력 값의 크기와 상관없이 항상 길이가 일정하다. 자리 올림이 발생하면 사사 시키기 때문이다. 물론 이 뿐만은 아니고 수학적 원리를 조금 더 가미하게 된다.

대표적인 알고리즘은 MD-5(16진수 사용. 0-9와 영문자 6개 활용) 및 SHA-1, SHA-2 family등이다. 

**보안 3대 요소를 떠올려보자**
1. 기밀성(Confidentiality)
2. 무결성(Integrity)✩✩✩✩
3. 가용성(Accessability)

기밀성과 관련된 것: 암호기술
무결성과 관련된 것: hash ✩✩✩✩✩
가용성과 관련된 것: DR(Disaster Response 혹은 Recovery) Disaster가 꼭 화재, 해일 같은 것은 아니고 ransomware도 재해다.

예를 들어, mov를 복제한다고 가정하자. 원본과 복사본이 완전히 같음(Integrity)를 어떻게 알 수 있을까? 바이너리를 시작부터 끝까지 비교해야할까? 매번 그 작업을 반복한다는 것은 말도 안된다! 애초에 그럼 데이터 비용이 항상 2배가 된다. 기가바이트 단위의 데이터를 생각해보면 납득이 갈 것이다.

그렇다면 hash를 사용하면 어떨까? 예를 들어 MD5를 사용해 일정길이의 hash를 생성했다고 가정해보자. 단 1bit만 달라도 결과가 다르므로 분명히 같음을 효율적으로 확신할 수 있게 된다. 실제로 torrent도 데이터를 분할하고 분할된 데이터마다 hash를 비교함으로써 분할된 데이터가 합쳐져 완벽한 원본이 됨을 검증한다. 

PW저장에도 hash를 활용해 일정한 길이를 저장하는 경우는 많은 개발자들이 이미 익숙할 것이다.

# PKI(Public Key Infrastructure)
## symmetric 암호화 원리
원문(평문), 즉 대상이 존재한다. 그 대상을 key(임의의 값)으로 암호화하는데, XOR(Exclusive Or: bitwise연산에서 두 값의 같은 자릿수 부분이 같은 값이면 0 다르면 1)한다. 그 XOR결과물이 암호문이다. 그리고 이 과정을 암호화라고 한다. 암호문을 평문으로 바꾸는 것을 복호화라고 한다. 그런데, XOR연산을 했으니 역연산(다시 XOR)하면 평문이 나오지 않을까? 맞다. 그래서 대칭키는 복호화가 가능하다. 물론 연산을 반복하는 등의 추가적인 알고리즘들이 들어가있긴 하지만 핵심은 위의 내용이 전부다.

가장 많이 쓰이는 알고리즘은 AES-128이며 3DES, SEED128, ARIA등도 쓰인다.
## asymmetric
암호화를 하는 key와 복호화를 하는 key가 다르면 asymmetric이다. 즉, 대칭 비대칭이라는 용어가 가리키는 것은 key에 관한 것이다. 우리는 사실 asymmetric key를 매일같이 쓰고 있다. 바로 SSL 통신 때문이다. 왜 SSL에 대칭키는 불가능할까?
생각해보자. 정보를 안전하게 전송하려면 암호화해서 전송해야한다. 수신자는 암호화된 데이터를 수신한 후 평문으로 복호화해 내용을 파악해야 한다. 이 때 대칭키를 사용하면 딜레마가 발생한다. 수신자에게 키를 전송해야하기 때문이다. 그렇다면 키를 안전하게 전송하기 위해서 또다시 암호화를 해야한다. 그리고 그 키를 복호화 하기 위해 또 다시 키가 필요하다. 딜레마가 발생하는 것이다.
이를 해결하기 위해 비대칭 키가 등장한다.

# SSL(Secure Socket Layer)
SSL에서 비대칭키 체계가 어떻게 활용될까? client와 server간의 이야기로 생각해보자.

1. 먼저 client의 pc는 public key와 private key를(즉, 키쌍) 생성한다. 마찬가지로 server도 키쌍을 생성한다. 즉, 현재까지 키쌍 두개가 생성된 것이다.
2. 키 교환이 일어난다. 이 때 client와 server가 교환하는 키는 public key이다. 당연하게도 public key는 네트워크의 public구간을 통과하기 때문에 해커든 누구든 마음 먹으면 볼 수 있다.
3. 교환된 public key로 전송할 데이터를 암호화 한다. 이 것이 안전한 이유는 어차피 데이터가 중간에 감청되더라도 복호화를 네트워크에 노출된 적 없는 private key로만 할 수 있기 때문이다.
4. 결론적으로 public key는 암호화, private key는 복호화를 담당하는 구조이다.

## 키 교환
사실 위에서 설명한 방식은 통신 속도를 느리게 만드는 주범이다. 애초에 키를 생성하는 것이 알고리즘에 따라 다르긴 하겠지만 엄청난 전산자원을 소모하기 때문이다. 규모가 커지면 그 여파는 엄청나게 된다. 그렇다면 키쌍을 통신이 시작될 때 생성하지말고 미리 생성하면 통신 지연을 완화할 수 있다.

그런데 하나 더 생각해볼 것이 있다. 대칭키가 비대칭 키보다 전산자원 측면에서 효율 적이다. 그렇다면 대칭키를 활용할 방안은 없을까? 이를 구현하기 위해 client pc에서는 사실 키 쌍이 아니라 대칭키 하나를 생성한다. 그렇다면 위의 설명과 모순이다. 어떻게 대칭키를 안전하게 전달한다는 것인가. 이를 해결하기 위해 서버는 여전히 키쌍을 생성한다. 그리고 public key를 client에게 일방적으로 전달한다. 이 후 client는 server의 pub key를 이용해 자신의 대칭키를 암호화시켜버린다! 그리고 이 암호화된 키를 다시 서버에게 전송함으로써 키교환이 안전하게 이루어지는 것이다. 즉, 효율성도 챙기고 키를 안전하게 전달도 하는 극한의 이득이 완성된 것이다. 참고로 client가 생성한 대칭키는 한 번의 연결 세션에만 사용되고 버려지는데, 이와 같은 특성으로 인해 session key라고 불린다.

그런데 또 함정이 있다. 서버가 보내준 pub key의 무결성을 어떻게 확신할 수 있는가? 없다. 왜 없는가? 해커가 통신 감청을 하다가 pub key가 전송되는 순간 가로채 드랍한 후 해커가 생성한 pub key를 대신 client에게 전송할 수가 있는 것이다. 이후 client가 응답한 응답도 가로채 해커의 pri key로 복호화 할 수 있다. 그렇다면 서버는 어쨌든 응답을 받아야하니 해커의 존재를 즉시 눈치챌 수 있지 않을까? 아니다. 해커는 애초에 훔쳐둔 서버의 pub key를 가지고 평문화시킨 응답을 다시 서버의 pub key로 암호화해서 서버에 전송한다. 서버는 복호화가 정상적으로 되니 클라이언트와 서버 둘다 공격을 눈치챌 수가 없는 것이다. 

이러한 공격을 MITM(Man in the Middle) Attack이라고 한다. 물론 현대의 기업 보안은 MITM을 충분히 막아낼 수 있도록 대책을 세워두고 있다. 그 대책이란 바로 제 3자 즉, 인증 기관이다. 서버와 클라이언트는 중간자를 '신뢰'한다. 중간자의 인증체계는 크게 세 가지다(더 있지만 이 정도만 기억해도 원리는 이해할 수 있다). 
1. CA(Certification Authority) -> VeriSign, COMODO등 기업
2. RA(Registration Authority) -> CA와 연계되어 있는 키 생성자 파트너. 당연히 CA와 RA간은 다양한 방법으로 보안 커넥션을 유지한다.
3. VA(Validation Authority)
## 조금 더 자세한 SSL 검증 과정
server가 RA에게 키 쌍 생성을 요청 한 후, 키를 전송받고 서버에 소지한다. RA가 생성하는 키는 단순한 랜덤 키가 아닌, 구매자 혹은 소지자를 확인할 수 있는 부가 정보가 포함된 상태다. 물론 그 정보들은 hash되어있다. 또 한 그 hash도 암호화된다. 이 부분이 꽤나 중요한데, 다음 문단에서 설명한다. 

어쨌든 그 서버가 RA로 부터 받은 pub key 더불어 부가 정보들(유효기간, 소지자 등등등)까지 합해서 '인증서'라고 부른다.

이전에 살펴본 것 처럼 pub key를 교환한다는 개념까진 같으나, 이젠 단순한 key대신 인증서를 전송하게 된다.
이제는 중간에 해커가 인증서를 가로채 pub key값을 변경한다고 하더라도 포함된 hash값으로 검증할 수 없게 될 것이다. 그렇다면 해커가 hash값까지 변경하면 되지 않을까? 맞다. 변경하면 hash값도 맞출 수 있다. 그러나 의미가 없다. 검증은 단순하게 이뤄지지 않는다. CA-RA가 관리하는 데이터를 참조하여 검증하기 때문이다.
더 정확히 말하면 기업끼리 애초에 제휴가 되어있다. 예를 들어 MS window를 쓴다고 가정하면, CA의 인증서를 검증할 수 있는 체계가 아예 운영체제에 설치된다. 간단히 설명하자면 '인증서'를 인증할 수 있는 또 다른 '내부 인증서'를 컴퓨터에 설치한다. 보안 관련 업데이트에 이런 사항이 설치되는 경우가 잦다. 상단에서 인증서에 포함된 hash또한 암호화를 한다고 언급했다. 여기서 또 다른 키쌍이 등장한다. 바로 CA가 내부적으로 지니고 있는 CA pub key와 CA pri key다. 그리고 인증서의 hash를 암호화하는 키가 CA pri key다. 복호화는 CA pub key로 한다. 이상하게 생각되어야 한다. 지금까지는 pub key로 암호화하고 pri key로 복호화하는 체계만 봤기 때문이다. 그 이유는, CA pub key를 기관 인증서(클라이언트가 서버한테 받는거 말고 운영체제에 설치된 인증서들)에 포함시켜 클라이언트의 인증서의 암호화된 hash를 복호화해 hash값을 비교해야 하기 때문이다. 이 논리대로라면 CA pri key로 암호화를 하고 CA pub key로 복호화를 할 수 밖에 없는 것이다.

설치되어있으니 볼수도 있다. certmgr.msc를 실행해보자. 수 많은 정보와 더불어 이렇게 많은 인증서가 설치되어있었나 싶을 정도의 숫자의 인증서를 볼 수 있다. 

마지막으로 언급할 것이 있다. 위의 구조를 뒤집어 보자. 뒤집힌 형태도 매일같이 사용되는데, 바로 공인인증체계가 지금까지 설명한 구조를 반대로 만든 것이다. 생각해보자. 개인이 인터넷 뱅킹에 접속할 때 은행은 자신이 RA가 되며 연계된 CA도 당연히 존재한다. 그 CA의 예를 들면 YesSign(금융결제원)이다. 개인은 RA와 CA를 신뢰한다. 그리고 그들로부터 키쌍을 전달받아 개인이 소지하고 있다(공인인증서 찾기 할때 나오는 그것). 위에서 설명한대로 public key에 온갖 정보가 박혀 있고 은행거래를 하고자 할 때 그 인증서를 보낸다. 그러면 RA인 은행은 CA인 YesSign에게 진위여부를 조회한다. 



