# 상식
application proxy: application이 의미하는 바는 user mode라는 것이고, user mode라면 proxy process가 socket을 통해 연결을 받았다는 뜻이고, socket이라는 것은 stream data라는 뜻이다. 

inline + out of path proxy: 커널 중 IP영역에 관여하므로 packet에 관여하는 것이 자명.
# 활용
### 1. 우회
요청 당사자가 목적지에 도달하려고 할 때, 프록시를 통해 우회한 후 도달하게 되면 송신자는 이 요청이 마치 프록시에서 전송된 것 처럼 인식하게 됨. Tor 프로젝트가 대표적인 예인데, 모든 요청을 프록시를 거쳐서 전송시켜 요청자의 정체를 항상 숨겨줌. 해킹에도 좋은 수단인데, 해커의 위치를 숨기기 위해 프록시를 통해 공격할 수 있음. 근데 문제는, 자신의 정체가 숨겨지는 것은 좋은데 내 요청이 프록시를 통해 가는 순간 프락시는 소켓에 오가는 모든 정보를 감청할 수 있게 됨. VPN도 우회의 개념이 있으나 보통 Proxy는 Web수준(보통 HTTP)의 우회고 VPN은 Network수준의 우회임.

### 2. 분석
평문으로 전송하면 모든 정보가 노출되므로 SSL을 붙여서 HTTPS로 보호하는데, SSL로 암호화 되는 계층이 Socket 수준(User mode)이다보니 요청이 IP계층까지 내려왔을 땐 이미 헤더를 제외한 모든 정보가 암호화된 상태라 wire shark등을 통한 패킷 분석(자신의 패킷 분석도 중요한 부분임. 특히 어플리케이션의 크기가 커질 수록)이 어려워짐. 그렇다면 Socket수준으로 돌아가서 암호화가 되기 전에 분석하는 방법을 쓰게 되는데, Proxy가 SSL을 대행하게 되고 WAS와 Proxy간의 소켓 연결은 평문으로 이뤄지게 만들면 데이터 분석도 가능하고 암호화도 가능한 형태를 만들 수 있다.

### 3. 감시 및 보호
이해를 위해 가상의 네트워크 환경을 상상해보자. 3.3.3.x대역이 존재하며, Router가 게이트웨이로써 1번을 사용하며 3.3.3.1을 가진다. 이후 엔드포인트들은 3.3.3.2~ 의 주소들을 할당받은 상태라고 하자. 그리고 엔드포인트중 어딘가에 프록시가 존재하는데, 프록시의 주소는 3.3.3.100이라고 가정한다. 그리고 모든 PC들은 그 3.3.3.100의 프락시를 사용한다.

이 상태에서, 3.3.3.2 host가 악성코드가 존재하는 사이트에 연결을 시도한다고 가정하자. 그렇다면 그 요청은 3.3.3.100으로 일단 간 후 다시 악성 사이트에 연결될 것이다. 그리고 악성 사이트가 보내는 응답 또한 다시 프락시로 되돌아오게 될 것이다. 
그렇다면 호스트에 도달하기 전 프락시에서 악성 코드 유입을 막을 수 있다.

이런 식의 프록시는 Virus Wall로 부를 수 있다. 또한 3.3.3.x 대역에 포함된 모든 컴퓨터는 프록시를 통해 접속하므로 프록시 관리자는 무슨 요청이 들어오는지도 감시할 수 있다. 이런 식의 구현은 특히 사내 인터넷과 같은 곳에 많이 사용되는데, 예를 들자면 회사원 A씨가 업무시간에 Bitcoin거래소에 접속하는 것을 볼 수 있다던가 하는 것이다. SSL은 프락시가 대행하므로 요청내용도 모두 평문으로 감시할 수 있다.
이걸 생각해보면, 프락시는 꽤 위험하다. 특정 요청에 대해 그 요청을 원래 목적지로 전달하는 대신 자신이 대신 가짜응답을 보내는 것도 가능하기 때문이다. 아니면 각 호스트들의 인터넷에 대한 접근 자체를 제어해버릴 수도 있다. 이런식으로 프락시가 위치하는 structure자체를 이해하고 있으면 매우 다양한 방식으로 프락시를 활용할 수 있다. 

### 4. Reverse proxy
1~3번의 공통점이 무엇일까? 바로 프락시가 클라이언트의 요청을 대리하고 있다는 점이다. 일반적으로 프락시라고 하면 1~3번과 같은 형태를 일컫는 말이며, 이를 forward proxy라고 한다. 그런데, 요청을 받는 입장에서도 proxy를 둘 수가 있다. 그러니까, 클라이언트와 서버의 사이에 proxy가 위치해있는 것은 맞는데 proxy가 클라이언트 대신 서버를 대리하는 것이다. 그리고 Reverse Proxy가 있다면 아마 WAS에는 직접 접근할 수 없을 것이고 Proxy를 통해서만 접근이 가능하며 Proxy와 WAS사이의 경로는 Private할 것이다. 이 Proxy도 요청대리이므로 당연히 보호와 감시의 역할을 수행할 수 있다. 이 때, Proxy가 공격을 식별하고 차단할 수 있다면 이를 WAF(Web Application Firewall)이라고 부른다. WAS와 혼동하지 말자.
WAF의 중요한 특징은 감시 트래픽의 단위가 Packet이 아닌 Socket stream이라는 것이다(L7 HTTP->Socket->application proxy니까 당연). 이런 구조가 좋은 점은 특히 대량의 트래픽을 받기 쉬운 상황에서 유리한데, 예를 들어 파일업로드가 가능한 서버라고 가정하면 해커가 악성 파일을 업로드하는 것을 방지하기 위해 파일 내용을 검사해야하는데, 파일의 크기가 커짐에 따라 이를 서버에 모두 맡기면 서버의 부하가 매우 커진다. 수백메가바이트 혹은 몇 기가 바이트의 파일을 떠올려보자. 이런 처리를 프락시 컴퓨터가 대신 하는 구조는 매우 일반적이며, WAF는 필수개념이다.





