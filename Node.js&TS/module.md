nodejs는 CJS와 ESM를 모두 사용할 수 있다. 이 두 형태는 왜 존재하는 것일까
# 모듈은 왜 필요한가
1. 코드 베이스를 분리할 수 있다. 이를 통해 코드를 구조적으로 관리할 수 있다.
2. 코드를 재사용할 수 있게 해준다. 즉, 모듈화 된다.
3. 간단한 인터페이스만 노출할 수 있다. 즉, 은닉된다.
4. 종속성을 관리할 수 있게 해준다.
# CJS
브라우저가 아닌 환경에서 구동할 수 있도록 고안된 명세
## 노출식 모듈 패턴(revealing module pattern)
JS는 네임스페이스가 없다. 예를 들어, 여러개를 임포트 할 경우 같은 이름의 코드를 덮어 쓸 수 있다. 이런 식으로 스코프 오염 가능성이 내재 되어있다. 이를 해결하기 위해 네임스페스를 모방하는 동작을 많이 사용했는데, 이는 CJS의 바탕이 되었다.
노출식 모듈 패턴의 예는 다음과 같다.
```js
// RM_test를 네임스페이스처럼 활용
const RM_test_1 = (()=>({ a:() => 1, b:() => 'a', c:'hello!' }))();
const RM_test_2 = (()=>({ a:() => 9, b:() => 'z', c:'bye!' }))();

// RMP를 사용하여 네임스페이스를 분리한 것처럼 사용가능
RM_test_1.a()
RM_test_2.a()
```
## CJS의 탄생
CJS의 핵심
1. require는 로컬 파일 시스템으로부터 모듈을 임포트하게 해준다.
2. exports와 module.exports는 특별 변수로서, 현재 모듈에서 공개될 기능들을 내보내기 위해 사용된다. 즉, module.exports에 할당되지 않은 이상 모듈의 모든 내용은 private이다.

개략적 순서는 다음과 같다.
1. 모듈의 이름을 입력받는다. 이는 require.resolve에게 전달된다.
2. 모듈이 최초 로딩이라면, module객체(module = {exports:any})를 생성한다. 경로정보에 캐시된다. 이미 로딩되었다면 단지 cache hit이다.
3. 모듈의 public API라고 할 수 있는 module.exports가 호출자(require)에게 반환된다.

require함수는 동기적이다. 그러므로 비동기적으로 초기화되는 module.exports를 참조하지 못한다(예를 들어, 비동기 콜백 내에서 초기화). 초기에는 비동기 require도 지원했었다. 그러나 과도한 복잡성 때문에 곧 삭제되었다. 물론 개발을 하다보면 비동기적으로 초기화가 필요한 경우들도 생긴다. 이 때도 손쉽게 해결 가능하지만 require는 여전히 동기적이므로 추가적인 패턴이 필요하다.

## require.resolve
CJS는 file system을 통해서 모듈을 로드한다고 언급했다. 그렇다면 어떤 식으로 resolve하는 것일까. require는 모듈의 이름을 통해서 경로를 반환할 수 있는데, 다음 세 가지 알고리즘을 따른다.
1. 파일모듈: 이름이 /로 시작할 경우 절대 경로로 간주하고 탐색한다. ./로 시작하는 경우 상대경로로 간주하며 탐색 시작 위치는 요청한 모듈이다.
2. 코어모듈: 1의 경우가 아니라면 코어모듈부터 탐색한다.
3. 패키지모듈: 2에서 탐색을 실패하면 탐색 시작 위치는 요청 모듈이 된다. 시작 위치로부터 node_modules를 찾는다. node_modules를 찾으면 그 내부를 탐색한다.

코어 모듈을 제외하고, 파일 모듈과 패키지 모듈은 파일 혹은 디렉터리가 모두 moduleName과 일치할 수 있으므로, 탐색 알고리즘은 다음의 일치를 검사한다.
* <moduleName>.js
* <moduleName>/index.js
* <moduleName>/package.json의 main 속성에 지정된 디렉터리 혹은 파일
즉, 각종 설치 패키지에 index.js 혹은 package.json이 꼭 필요한 이유가 탐색 알고리즘 때문인 것이다.

위 내용이 시사하는 중요한 점은, 종속성 지옥을 매우 쉽게 해결할 수 있다는 것이다. 예를 들어, 디렉토리 위치가 다른 상태에서 node_modules를 분리한다면 같은 이름으로 require한다고 하더라도 다른 버전 혹은 다른 파일을 참조시키게 할 수 있다.
같은 이름의 패키지의 다른 버전이 필요한 경우는 자주 발생하므로 특히 유용하다고 할 수 있다.






# ESM
향후 크게 지배적으로 성장하겠지만 현재는 CJS 코드의 양이 우세.
# 차이점과 상호 이용

