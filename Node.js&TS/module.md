nodejs는 CJS와 ESM를 모두 사용할 수 있다. 이 두 형태는 왜 존재하는 것일까
# 모듈은 왜 필요한가
1. 코드 베이스를 분리할 수 있다. 이를 통해 코드를 구조적으로 관리할 수 있다.
2. 코드를 재사용할 수 있게 해준다. 즉, 모듈화 된다.
3. 간단한 인터페이스만 노출할 수 있다. 즉, 은닉된다.
4. 종속성을 관리할 수 있게 해준다.
# CJS
브라우저가 아닌 환경에서 구동할 수 있도록 고안된 명세
## 노출식 모듈 패턴(revealing module pattern)
JS는 네임스페이스가 없다. 예를 들어, 여러개를 임포트 할 경우 같은 이름의 코드를 덮어 쓸 수 있다. 이런 식으로 스코프 오염 가능성이 내재 되어있다. 이를 해결하기 위해 네임스페스를 모방하는 동작을 많이 사용했는데, 이는 CJS의 바탕이 되었다.
노출식 모듈 패턴의 예는 다음과 같다.
```js
// RM_test를 네임스페이스처럼 활용
const RM_test_1 = (()=>({ a:() => 1, b:() => 'a', c:'hello!' }))();
const RM_test_2 = (()=>({ a:() => 9, b:() => 'z', c:'bye!' }))();

// RMP를 사용하여 네임스페이스를 분리한 것처럼 사용가능
RM_test_1.a()
RM_test_2.a()
```
## CJS의 탄생
CJS의 핵심
1. require는 로컬 파일 시스템으로부터 모듈을 임포트하게 해준다.
2. exports와 module.exports는 특별 변수로서, 현재 모듈에서 공개될 기능들을 내보내기 위해 사용된다. 즉, module.exports에 할당되지 않은 이상 모듈의 모든 내용은 private이다.

개략적 순서는 다음과 같다.
1. 모듈의 이름을 입력받는다. 이는 require.resolve에게 전달된다.
2. 모듈이 최초 로딩이라면, module객체(module = {exports:any})를 생성한다. 경로정보에 캐시된다. 이미 로딩되었다면 단지 cache hit이다.
3. 모듈의 public API라고 할 수 있는 module.exports가 호출자(require)에게 반환된다.

require함수는 동기적이다. 그러므로 비동기적으로 초기화되는 module.exports를 참조하지 못한다(예를 들어, 비동기 콜백 내에서 초기화). 초기에는 비동기 require도 지원했었다. 그러나 과도한 복잡성 때문에 곧 삭제되었다. 물론 개발을 하다보면 비동기적으로 초기화가 필요한 경우들도 생긴다. 이 때도 손쉽게 해결 가능하지만 require는 여전히 동기적이므로 추가적인 패턴이 필요하다.




# ESM
향후 크게 지배적으로 성장하겠지만 현재는 CJS 코드의 양이 우세.
# 차이점과 상호 이용

