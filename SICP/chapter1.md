SICP에서, 본문의 내용은 다량의 연습 문제를 해결하며 그 의미를 되돌아볼 수 있도록 구성되어 있다. 그러므로 본문의 내용을 옮기기 보다는 연습문제를 해결해 나가는 과정을 기록한다. 
1.1~1.4문제는 매우 기초적인(예를 들어, a + b)수준이므로 생략하고 1.5 문제부터 기록한다.
# Chapter 1: 함수를 이용한 추상화

#### 1.5) 아래와 같은 함수 선언이 있고, 언어 해석기가 인수 우선 평가하는지 정상 순서 평가하는지를 판단하고 근거를 서술하라
```js
function p() { return p(); }

function test(x, y) {
  return x === 0 ? 0 : y;
}

test(0, p());
```
#### 1.5 A
위 함수를 통해 자바스크립트는 인수 우선 평가 해석기임을 알 수 있다. 
근거 1) 정상 순서 평가 해석기였다면 인수를 평가하는 것이 아니라 표현식을 단지 인수에 대입해놓았을 것이다.
근거 2) test는 실행되지 못한다. p()는 탈출 조건없는 무한 재귀로, 인수 우선 평가 방식인 js는 p()의 평가를 결국 실패하게 된다.

#### 1.6) 아래와 같이 조건문을 대체하는 함수와 이를 활용한 뉴턴 방법으로 제곱근을 구하는 함수를 작성했을 때 어떤 일이 생기는지 설명하라
```js
function conditional(predicate, then, else) {
  return predicate ? then : else;
}

function sqrt_iter(guess, x) {
  return conditional(is_good_enough(guess, x), guess, sqrt_iter(improve(guess, x), x));
}
```
#### 1.6 A
최적화 측면에서 굉장히 불리하고, 프로그램이 실행될 가능성도 낮아진다. 1.5에서 살펴보았듯, JS는 인수 우선 평가 해석기이다. 원래의 술어, 귀결, 대안 구조라면 술어가 참을 반환한다면 대안은 평가되지 않을 것이다. 그러나 위의 함수 선언은 조건이 함수의 인자로 평가되므로 무조건 모두 평가된다. 불필요한 부분까지 평가할 뿐 아니라 실행이 되지 않을 수도 있다.

