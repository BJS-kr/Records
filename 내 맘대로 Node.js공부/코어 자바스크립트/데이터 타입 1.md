# 데이터타입의 종류

### 기본형(primitive type)
Number, String, Boolean, Null, Undefined  

### 참조형(reference type)
Object, Array, Function, Date, RegExp  
(added in ES6)Map, WeakMap, Set, WeakSet  
 
### 기본형과 참조형에 대한 흔한 오해
일반적으로 기본형은 할당이나 연산시 복제되며 참조형은 참조된다고 알려져있다.
그러나 엄밀히 말하면 기본형 참조형 모두 복제이다. 다만 기본형은 값이 담긴 주솟값을 바로 복제하며 참조형은 값이 담긴 주솟값들의 묶음을 가리키는 주솟값을 복제한다는 것이 차이점이다.
이 부분을 잘 이해하기 위해선 immutability라는 개념에 대한 정확한 이해가 필요하며, 또한 immutability를 이해하기 위해선 메모리 영역에서 자바스크립트의 데이터가 어떤 방식으로 처리되는지를 이해해야 한다.
모든 데이터는 바이트 단위의 식별자 즉, '메모리 주솟값(memory address)'를 통해 구분과 연결이 가능하다. 우리가 사용하고 있는 '변수'와 '식별자'라는 용어또한 정확히 정의할 필요가 있다. 
변수는 variable, 식별자는 identifier로서 변수는 말 그대로 변할 수 있는 값 즉, 데이터를 가리키는 것이고, 식별자는 어떤 데이터를 식별하는데 사용되는 이름 즉, 변수명이다.
```javascript
var a = 10; 
```
는 곧, 변경가능한 데이터를 만들며 그 식별자는 'a'라는 뜻이 된다. '변수'는 데이터가 아니라 데이터가 담길 수 있는 공간 내지 그릇정도로 이해하는 것이 좋다. 컴퓨터는 이에 따라 메모리에 식별자 a가 담긴 공간을 할당하며, 앞으로 a에 접근하고자 할때는 식별자 a가 담긴 메모리(변수영역)에 접근하여
그 내부에 담긴 정보들을 가져온다. '정보'이지 '데이터'가 아니다. 그 정보란 식별자가 가리키는 데이터의 주솟값이 된다. 컴퓨터는 식별자와 데이터를 한 곳에 저장하지 않는다. 왜 변수영역에 데이터를 함께 저장하지 않고 번거롭게 데이터는 데이터 영역에 따로 저장하는 것일까?
데이터 변환 및 메모리를 효율적으로 관리하기 위함이다. 예를 들어 변수영역과 데이터 영역이 구분되어 있지 않다고 가정하고, 변수 영역에서 데이터 변환을 함께 처리한다고 생각해보자. 식별자들은 정해진 위치에 있던 모든 데이터들과 주솟값으로
연결되어있을 것이다. 그 중간에 새로운 데이터가 포함되어 변경작업을 한다면 먼저 추가적인 메모리를 확보하는 작업을 실시한 후에 추가된 데이터보다 뒤에 있는 데이터의 위치를 모두 옮긴 후(옮겨진 데이터들의 주솟값들이 모두 변경), 식별자들이
이동시킨 주소를 각 식별자들과 다시 연결해야 한다. 또 다른 예로, '5'라는 값을 가진 500개의 식별자가 있다고 가정해보자. 변수영역과 데이터 영역이 나눠져있지 않다면 필연적으로 식별자 500개와 
5라는 데이터 500개가 만들어져야 한다. 그러나 데이터 영역이 분리되어있다면 5라는 데이터는 데이터 영역 어딘가 한군데에서만 존재하고, 그 주솟값은 500개의 식별자에 연결하기만 하면 되는 것이다.
메모리 관리의 효율성이 대폭 상승한다. 즉 효율성을 위해선 변수영역과 데이터영역을 분리해야하는 것이다. 

식별자에 연결된 데이터를 변경하면 그 데이터 자체가 변하는 것이 아니라 새로운 데이터를 만들어 새로이 데이터 영역 어딘가에 할당하고 그 주소를 식별자와 연결시킨다. 추가를 하던 삭제를 하던 새로운 데이터를 만들어 연결시키는 것이다. 

### 상수(constant) vs 불변값
변수(varible)와 상수를 구분 짓는 변경 가능성의 대상은 '변수 영역'이고, 불변성 여부를 구분하는 대상은 '데이터 영역'이다. 불변성이란 한 마디로, '한번 만들어진 데이터는 변경되지 않는다'이다.
우리는 위에서 어떤 식별자에 할당된 데이터를 변경할때 그 데이터 자체를 변경하는 것이 아니라 새로운 데이터를 만든 다는 것을 살펴보았다. 이는 기본형 데이터에만 적용되는 것은 아니며,
참조형 데이터라고 하더라도 설정에 따라 불변성을 띄거나, 아예 불변값으로 활용하는 방안도 있다. 

### 참조형
기본형 데이터와 참조형 데이터의 가장 큰 차이는 '객체의 변수(property) 영역'이 별도로 존재한다는 점이다. 우리는 앞서 데이터가 데이터 영역에 할당 된다고 알게 되었다. 객체의 변수의 영역이란
그 데이터 영역에서 또 다시 객체의 변수 영역으로 연결되어 할당된다는 의미이다. 우리가 앞서 살펴본 데이터 영역에는 객체의 변수 영역과 연결시켜 줄수 있는 주솟값들이 지정되게 된다.
이단 구조로 이해하면 좋다. 변수영역에서 데이터 영역으로 주솟값으로 연결되고(1단), 데이터 영역에서 객체의 변수 영역으로 주솟값으로 연결된다(2단).

바로 여기서 불변하지 않는 즉,'가변성'을 이해할 수 있다. 객체의 변수영역에서는 또 다시 데이터 영역과의 연결이 일어난다. 데이터는 불변이다. 그러나, 객체의 변수영역의 변수들은 얼마든지 새로이
대입 될 수 있다. 참조형 데이터는 '객체의 변수 영역을 데이터로 가진다'고 하여 가변하다고 표현되는 것이다. 그러나 오해하지 말아야 할 것은, 그 객체의 변수들은 다시 불변인 데이터 영역으로 연결된 다는 것이다.
예를 들어 참조형 데이터인 임의의 object1의 프로퍼티인 a를 변경한다고 가정해보자. object1은 생성시 할당받은 데이터 영역의 주소를 바라보고 있다. 그 주소엔 또다시 객체의 변수의 영역으로 연결되는 주소가 들어있다.
obeject1의 a를 변경했을때, object1이 바라보고 있는 데이터 영역의 주솟값은 변하지 않는다. a값의 변경은 객체의 변수 영역에서 이루어지고 있기 때문이다. 마치 기본형 데이터에서 불변성때문에 일어나는
일들이 '객체의 변수의 영역'에서 일어나고 있는 것이다. object1이 바라보고 있는 데이터 영역의 주솟값은 변하지 않았는데도 말이다.

이번엔 참조형 데이터 내부의 프로퍼티에 다시 참조형 데이터를 할당(nested object)하는 과정을 생각해보자. 어떤 객체의 내부 프로퍼티가 어레이인 상황을 떠올리면 된다. 어떤 일이 일어날까?
객체의 변수 영역은 다시 데이터 영역을 가리키는 것을 기억하는가? object1 내부 프로퍼티인 어레이가 데이터 영역을 가리키면 그 데이터 영역은 다시 새로운 객체의 변수 영역을 가리킨다!
즉 연결이 1단 더 늘어난 것이다. 객체 내부의 객체가 가리키는 새로운 객체의 변수 영역이 탄생한다. 이때부턴 같은 일이 일어난다. 내부 프로퍼티 어레이의 값이 변경되더라도, 어레이가 가리키고 있는
데이터 영역의 주소는 변하지 않는다. 대신 앞서 살펴본 것 처럼 새로운 객체의 변수 영역에서만 변동이 일어나게 된다. 

### 변수 복사. 참조형 vs 기본형
```javascript
var a = 10;
var b = a;

var obj1 = { c: 10, d : 'ddd' };
var obj2 = obj1;
```
이 때, a와 b에 연결된 데이터의 주솟값은 같다. 마찬가지로 obj1과 obj2가 연결된 데이터 영역의 주솟값도 같다. 그러나 앞서 살펴보았듯이, 저 두개의 obj가 연결된 데이터 영역의 주소에는
또 다시 객체의 변수 영역으로 연결되는 주솟값만이 저장되어 있을 것이다. 그렇다면 그 내부로 들어가보자. obj의 프로퍼티 c는 어디를 가리키고 있을까? a,b가 가리키고 있는 데이터 영역과 같은 곳을
가리키게 된다. 앞서 객체의 변수영역은 또 다시 데이터 영역을 가리키게 된다고 설명했다. 그 상황이 일어난 것이다. a,b,c 모두 'ddd'라는 데이터는 가리키고 있지 않으므로 obj의 프로퍼티d는
데이터 영역에 새로운 공간을 할당받아 'ddd'를 저장하고 그 주솟값을 지니게 된다. 

여기까진 기본형 데이터와 참조형 데이터가 동일하다. 복사할때 같은 데이터 영역 주소를 가리키게 된다는 것 말이다. 
그러나 동작에는 큰 차이가 발생하게 된다.

b의 값을 15로 변경한다고 생각해보자. 15라는 데이터는 여지껏 데이터 영역에 존재하지 않고 있으므로, 새로운 주소에 15라는 데이터가 들어가게 될 것이고 b가 가리키는 주솟값도 마찬가지로 그 주소를 가리키게 될 것이다.
즉 a,b가 가리키는 주소는 달라지게 된다. 

이번에는 obj2의 프로퍼티 c를 20으로변경한다고 생각해보자. obj1과 obj2가 가리키는 주소가 달라질까? 달라지지 않는다. obj들은 여전히 데이터 영역의 한곳을 가리키고 있다. 당연하다. 변경은
그 데이터 영역에 저장된 주소를 타고 들어갈 수 있는 객체의 변수 영역의 c가 변경된 것이니까 말이다. c는 새로운 값 20으로 변경되기 위해 데이터 영역에 20을 생성하고 그 주솟값과 자신을 연결한다.
여기까지 왔다면 기본형과 참조형 데이터의 가장 큰 차이를 이해한것이다.
```javascript
a !== b
obj1 === obj2
```
가 된 것이다. a,b,obj1,obj2 모두 변수 영역에 나란히 서있는데도 말이다.
'기본형은 값을 복사하고 참조형은 주소를 복사한다'는 말은 틀렸음을 여기서 이해할 수 있다. 엄밀히 말하면 모든 데이터는 참조형이다. 지금까지 살펴보았듯, 기본형이던 참조형이던 데이터 영역의
주소를 복사해 자신과 데이터를 연결하는 형식을 가진다. 다만 기본형은 주솟값을 한 번만 복사(데이터 영역 -> 변수 영역)하는 것이고 참조형은 객체의 변수 영역을 가지므로 도달하기 위한 단계가 더 있는 것일 뿐이다.

```javascript
var obj1 = { c: 10, d : 'ddd' };
var obj2 = obj1;

var obj2 = { c: 20, d : 'ddd'};
```
```javascript
obj1 !== obj2
```
마지막으로 obj내부의 프로퍼티를 변경하는 것이 아닌, obj 자체를 변경할때는 어떤 과정이 일어나는지 생각해보자. 이때는 마치 기본형 데이터를 변경하는 것과 똑같은 과정이 일어난다.
데이터 영역에 새로운 주소에 값을 할당하고 그 값과 obj가 연결된다. 물론 그 새로운 주소에는 그 obj의 내부 프로퍼티들이 연결된 객체의 변수 영역의 주소가 담긴다.


hasOwnProperty메소드를 통해 프로토타입 체이닝으로 상속된 프로퍼티를 복사하지 않도록 활용 할 수도 있다. ES5의 getter/setter를 복사하는 방법은 ES6의 Object.getOwnPropertyDescriptor 또는 ES2017의 Object.getOwnPropertyDescriptors외에는 마땅한 방법이 없다.

간단하게 깊은 복사를 처리할 수 있는 또 하나의 방법은 JSON을 활용하는 것이다. 객체를 JSON으로 표현된 문자열로 전환했다가 다시 객체로 전환하는 것이다.

다만 단점이 명확한데, JSON으로 전환할 수 없는 프로퍼티들은 모두 무시하게 된다는 점이다. 메서드, 숨겨진 프로퍼티인 **proto**나 getter/setter등이 누락된다는 것이다. httpRequest로 받은 데이터를 저장한 객체등을 복사할 때 등 순수한 정보만을 활용할 때 좋은 방법이다.

```javascript
var copyObjectViaJSON = (target) => {
  return JSON.parse(JSON.stringify(target));
};
```

# undefined와 null

자바스크립트에는 '없음'을 뜻하는 값이 두 가지가 있다. undefined와 null이 그것이다. 마치 같은 의미로 보이는 이 두값의 의미는 미세하게 다르고, 사용 목적 또한 다르다.

undefined는 사용자가 명시적으로 지정할 수도 있고, 자바스크립트 엔진이 자동으로 부여할 수도 있다. 자바스크립트 엔진은 값이 예상되는 곳에 값이 없다면 undefined를 반환한다. 이러한 경우는 총 세가지가 있다.

1. 값을 대입하지 않은 변수. 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에게 접근할 때

2. 객체 내부의 존재하지 않는 프로퍼티에 접근을 시도할 때
   (ReferenceError : x is not defined)

3. return문이 없거나 호출되지 않는 함수의 실행 결과

이 중 1번의 경우를 조금 더 자세히 살펴보자. 1번의 경우가 배열에 적용될 경우엔 특이한 동작을 확인 할 수 있다.

```javascript
var arr1 = [];
arr.length = 3;
console.log(arr1); // [empty x 3]

var arr2 = new Array(3);
console.log(arr2); // [empty x 3]

var arr3 = [undefined, undefined, undefined];
console.log(arr3); // [undefined, undefined, undefined]
```

empty는 말 그대로 빈, undefined조차도 할당되어있지 않은 상태를 나타낸다. 즉, 놀랍게도 undefined는 비어있지는 않은 상태인 것이다.
이는 출력결과의 차이로도 이어진다. 순회와 관련된 많은 어레이 메서드들이 empty는 순회 대상에서 제외시키게 된다.

```javascript
var arr1 = [undefined, 1];
var arr2 = [];
arr2[1] = 1;

// undefined 0 / 1 1
arr1.forEach(function (v, i) {
  console.log(v, i);
});
// 1 1
arr2.forEach(function (v, i) {
  console.log(v, i);
});

// [NaN, 2]
arr1.map(function (v, i) {
  return v + i;
});
// [empty, 2]
arr2.map(function (v, i) {
  return v + i;
});

// [undefined]
arr1.filter(function (v) {
  return !v;
});
// []
arr2.filter(function (v) {
  return !v;
});

// undefined011
arr1.reduce(function (p, c, i) {
  return p + c + i;
}, "");
// 11
arr2.reduce(function (p, c, i) {
  return p + c + i;
}, "");
```

이러한 현상들이 마치 배열에서만 나타나는 특이한 현상인 것 처럼 소개했지만, 배열도 '객체'인것을 떠올려보면 이는 지극히 당연한 것이다. 존재하지 않는 프로퍼티를 순회할 수 없는 것은 당연하다. 배열은 무조건 length 프로퍼티만큼 공간을 확보하고 공간에 인덱스로 이름붙이는 식으로 동작한다고 생각하기 쉽지만, 실제로는 객체와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 등의 동작을 하게 된다. 즉 값이 지정되지 않은 인덱스는 '아직 존재하지 않는 프로퍼티'에 지나지 않는다.

반대로 undefined는 비어있음을 나타내기는 하나, 값으로 취급되고 고유의 키 값이 실존하며 순회의 대상이 된다.

그러나, 자바스크립트 엔진이 반환하는 undefined는 해당 프로퍼티 내지 배열의 키 값이 '존재하지 않음'을 나타낸다. 정리하자면 직접 할당한 undefined는 값으로 동작하나, 자바스크립트 엔진이 반환하는 undefined는 문자 그대로 값이 없음을 나타낸다.

이러한 undefined의 특성에 따른 혼란을 피하고자, undefined 할당은 지양하는 것이 바람직하다. 자바스크립트 엔진이 반환하는 undefined 외에는 undefined가 존재하지 않도록 하는 것이다. 값이 없음을 나타내고자 할때는 undefined 대신 null을 사용하면 된다.

null의 사용에는 주의할 점이 있는데, typeof null이 object라는 점이다. 이는 자바스크립트 자체 버그이다. 따라서 어떤 변수의 값이 null인지 여부를 판단하기 위해서는 typeof 대신 다른 방식으로 접근해야 한다.

```javascript
var n = null;
console.log(typeof n); // object

console.log(n == undefined); // true
console.log(n == null); // true

console.log(n === undefined); // false
console.log(n === null); // true
```

이와 같이 동등 연산자(equality operator,==)로 접근 했을 땐 null과 undefined를 같다고 판단하므로 일치 연산자(identity operator, ===)를 사용해야만 null인지 undefined인지를 정확하게 판단할 수 있다.




