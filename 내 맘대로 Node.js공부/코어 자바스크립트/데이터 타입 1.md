# 데이터타입의 종류

### 기본형(primitive type)
Number, String, Boolean, Null, Undefined  

### 참조형(reference type)
Object, Array, Function, Date, RegExp  
(added in ES6)Map, WeakMap, Set, WeakSet  
 
### 기본형과 참조형에 대한 흔한 오해
일반적으로 기본형은 할당이나 연산시 복제되며 참조형은 참조된다고 알려져있다.
그러나 엄밀히 말하면 기본형 참조형 모두 복제이다. 다만 기본형은 값이 담긴 주솟값을 바로 복제하며 참조형은 값이 담긴 주솟값들의 묶음을 가리키는 주솟값을 복제한다는 것이 차이점이다.
이 부분을 잘 이해하기 위해선 immutability라는 개념에 대한 정확한 이해가 필요하며, 또한 immutability를 이해하기 위해선 메모리 영역에서 자바스크립트의 데이터가 어떤 방식으로 처리되는지를 이해해야 한다.
모든 데이터는 바이트 단위의 식별자 즉, '메모리 주솟값(memory address)'를 통해 구분과 연결이 가능하다. 우리가 사용하고 있는 '변수'와 '식별자'라는 용어또한 정확히 정의할 필요가 있다. 
변수는 variable, 식별자는 identifier로서 변수는 말 그대로 변할 수 있는 값 즉, 데이터를 가리키는 것이고, 식별자는 어떤 데이터를 식별하는데 사용되는 이름 즉, 변수명이다.
```javascript
var a = 10; 
```
는 곧, 변경가능한 데이터를 만들며 그 식별자는 'a'라는 뜻이 된다. '변수'는 데이터가 아니라 데이터가 담길 수 있는 공간 내지 그릇정도로 이해하는 것이 좋다. 컴퓨터는 이에 따라 메모리에 식별자 a가 담긴 공간을 할당하며, 앞으로 a에 접근하고자 할때는 식별자 a가 담긴 메모리(변수영역)에 접근하여
그 내부에 담긴 정보들을 가져온다. '정보'이지 '데이터'가 아니다. 그 정보란 식별자가 가리키는 데이터의 주솟값이 된다. 컴퓨터는 식별자와 데이터를 한 곳에 저장하지 않는다. 왜 변수영역에 데이터를 함께 저장하지 않고 번거롭게 데이터는 데이터 영역에 따로 저장하는 것일까?
데이터 변환 및 메모리를 효율적으로 관리하기 위함이다. 예를 들어 변수영역과 데이터 영역이 구분되어 있지 않다고 가정하고, 변수 영역에서 데이터 변환을 함께 처리한다고 생각해보자. 식별자들은 정해진 위치에 있던 모든 데이터들과 주솟값으로
연결되어있을 것이다. 그 중간에 새로운 데이터가 포함되어 변경작업을 한다면 먼저 추가적인 메모리를 확보하는 작업을 실시한 후에 추가된 데이터보다 뒤에 있는 데이터의 위치를 모두 옮긴 후(옮겨진 데이터들의 주솟값들이 모두 변경), 식별자들이
이동시킨 주소를 각 식별자들과 다시 연결해야 한다. 또 다른 예로, '5'라는 값을 가진 500개의 식별자가 있다고 가정해보자. 변수영역과 데이터 영역이 나눠져있지 않다면 필연적으로 식별자 500개와 
5라는 데이터 500개가 만들어져야 한다. 그러나 데이터 영역이 분리되어있다면 5라는 데이터는 데이터 영역 어딘가 한군데에서만 존재하고, 그 주솟값은 500개의 식별자에 연결하기만 하면 되는 것이다.
메모리 관리의 효율성이 대폭 상승한다. 즉 효율성을 위해선 변수영역과 데이터영역을 분리해야하는 것이다. 

식별자에 연결된 데이터를 변경하면 그 데이터 자체가 변하는 것이 아니라 새로운 데이터를 만들어 새로이 데이터 영역 어딘가에 할당하고 그 주소를 식별자와 연결시킨다. 추가를 하던 삭제를 하던 새로운 데이터를 만들어 연결시키는 것이다. 

### 상수(constant) vs 불변값
변수(varible)와 상수를 구분 짓는 변경 가능성의 대상은 '변수 영역'이고, 불변성 여부를 구분하는 대상은 '데이터 영역'이다. 불변성이란 한 마디로, '한번 만들어진 데이터는 변경되지 않는다'이다.
우리는 위에서 어떤 식별자에 할당된 데이터를 변경할때 그 데이터 자체를 변경하는 것이 아니라 새로운 데이터를 만든 다는 것을 살펴보았다. 이는 기본형 데이터에만 적용되는 것은 아니며,
참조형 데이터라고 하더라도 설정에 따라 불변성을 띄거나, 아예 불변값으로 활용하는 방안도 있다. 

### 참조형
기본형 데이터와 참조형 데이터의 가장 큰 차이는 '객체의 변수(property) 영역'이 별도로 존재한다는 점이다. 우리는 앞서 데이터가 데이터 영역에 할당 된다고 알게 되었다. 객체의 변수의 영역이란
그 데이터 영역에서 또 다시 객체의 변수 영역으로 연결되어 할당된다는 의미이다. 우리가 앞서 살펴본 데이터 영역에는 객체의 변수 영역과 연결시켜 줄수 있는 주솟값들이 지정되게 된다.
이단 구조로 이해하면 좋다. 변수영역에서 데이터 영역으로 주솟값으로 연결되고(1단), 데이터 영역에서 객체의 변수 영역으로 주솟값으로 연결된다(2단).

바로 여기서 불변하지 않는 즉,'가변성'을 이해할 수 있다. 객체의 변수영역에서는 또 다시 데이터 영역과의 연결이 일어난다. 데이터는 불변이다. 그러나, 객체의 변수영역의 변수들은 얼마든지 새로이
대입 될 수 있다. 참조형 데이터는 '객체의 변수 영역을 데이터로 가진다'고 하여 가변하다고 표현되는 것이다. 그러나 오해하지 말아야 할 것은, 그 객체의 변수들은 다시 불변인 데이터 영역으로 연결된 다는 것이다.
예를 들어 참조형 데이터인 임의의 object1의 프로퍼티인 a를 변경한다고 가정해보자. object1은 생성시 할당받은 데이터 영역의 주소를 바라보고 있다. 그 주소엔 또다시 객체의 변수의 영역으로 연결되는 주소가 들어있다.
obeject1의 a를 변경했을때, object1이 바라보고 있는 데이터 영역의 주솟값은 변하지 않는다. a값의 변경은 객체의 변수 영역에서 이루어지고 있기 때문이다. 마치 기본형 데이터에서 불변성때문에 일어나는
일들이 '객체의 변수의 영역'에서 일어나고 있는 것이다. object1이 바라보고 있는 데이터 영역의 주솟값은 변하지 않았는데도 말이다.

이번엔 참조형 데이터 내부의 프로퍼티에 다시 참조형 데이터를 할당(nested object)하는 과정을 생각해보자. 어떤 객체의 내부 프로퍼티가 어레이인 상황을 떠올리면 된다. 어떤 일이 일어날까?
객체의 변수 영역은 다시 데이터 영역을 가리키는 것을 기억하는가? object1 내부 프로퍼티인 어레이가 데이터 영역을 가리키면 그 데이터 영역은 다시 새로운 객체의 변수 영역을 가리킨다!
즉 연결이 1단 더 늘어난 것이다. 객체 내부의 객체가 가리키는 새로운 객체의 변수 영역이 탄생한다. 이때부턴 같은 일이 일어난다. 내부 프로퍼티 어레이의 값이 변경되더라도, 어레이가 가리키고 있는
데이터 영역의 주소는 변하지 않는다. 대신 앞서 살펴본 것 처럼 새로운 객체의 변수 영역에서만 변동이 일어나게 된다. 

### 변수 복사. 참조형 vs 기본형
```javascript
var a = 10;
var b = a;

var obj1 = { c: 10, d : 'ddd' };
var obj2 = obj1;
```
이 때, a와 b에 연결된 데이터의 주솟값은 같다. 마찬가지로 obj1과 obj2가 연결된 데이터 영역의 주솟값도 같다. 그러나 앞서 살펴보았듯이, 저 두개의 obj가 연결된 데이터 영역의 주소에는
또 다시 객체의 변수 영역으로 연결되는 주솟값만이 저장되어 있을 것이다. 그렇다면 그 내부로 들어가보자. obj의 프로퍼티 c는 어디를 가리키고 있을까? a,b가 가리키고 있는 데이터 영역과 같은 곳을
가리키게 된다. 앞서 객체의 변수영역은 또 다시 데이터 영역을 가리키게 된다고 설명했다. 그 상황이 일어난 것이다. a,b,c 모두 'ddd'라는 데이터는 가리키고 있지 않으므로 obj의 프로퍼티d는
데이터 영역에 새로운 공간을 할당받아 'ddd'를 저장하고 그 주솟값을 지니게 된다. 

여기까진 기본형 데이터와 참조형 데이터가 동일하다. 복사할때 같은 데이터 영역 주소를 가리키게 된다는 것 말이다. 
그러나 동작에는 큰 차이가 발생하게 된다.

b의 값을 15로 변경한다고 생각해보자. 15라는 데이터는 여지껏 데이터 영역에 존재하지 않고 있으므로, 새로운 주소에 15라는 데이터가 들어가게 될 것이고 b가 가리키는 주솟값도 마찬가지로 그 주소를 가리키게 될 것이다.
즉 a,b가 가리키는 주소는 달라지게 된다. 

이번에는 obj2의 프로퍼티 c를 20으로변경한다고 생각해보자. obj1과 obj2가 가리키는 주소가 달라질까? 달라지지 않는다. obj들은 여전히 데이터 영역의 한곳을 가리키고 있다. 당연하다. 변경은
그 데이터 영역에 저장된 주소를 타고 들어갈 수 있는 객체의 변수 영역의 c가 변경된 것이니까 말이다. c는 새로운 값 20으로 변경되기 위해 데이터 영역에 20을 생성하고 그 주솟값과 자신을 연결한다.
여기까지 왔다면 기본형과 참조형 데이터의 가장 큰 차이를 이해한것이다.
```javascript
a !== b
obj1 === obj2
```
가 된 것이다. a,b,obj1,obj2 모두 변수 영역에 나란히 서있는데도 말이다.
'기본형은 값을 복사하고 참조형은 주소를 복사한다'는 말은 틀렸음을 여기서 이해할 수 있다. 엄밀히 말하면 모든 데이터는 참조형이다. 지금까지 살펴보았듯, 기본형이던 참조형이던 데이터 영역의
주소를 복사해 자신과 데이터를 연결하는 형식을 가진다. 다만 기본형은 주솟값을 한 번만 복사(데이터 영역 -> 변수 영역)하는 것이고 참조형은 객체의 변수 영역을 가지므로 도달하기 위한 단계가 더 있는 것일 뿐이다.

```javascript
var obj1 = { c: 10, d : 'ddd' };
var obj2 = obj1;

var obj2 = { c: 20, d : 'ddd'};
```
```javascript
obj1 !== obj2
```
마지막으로 obj내부의 프로퍼티를 변경하는 것이 아닌, obj 자체를 변경할때는 어떤 과정이 일어나는지 생각해보자. 이때는 마치 기본형 데이터를 변경하는 것과 똑같은 과정이 일어난다.
데이터 영역에 새로운 주소에 값을 할당하고 그 값과 obj가 연결된다. 물론 그 새로운 주소에는 그 obj의 내부 프로퍼티들이 연결된 객체의 변수 영역의 주소가 담긴다.



